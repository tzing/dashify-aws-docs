<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="es-ES"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Administración de transacciones - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="stored-procedure-transaction-management" /><meta name="default_state" content="stored-procedure-transaction-management" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-transaction-management.html" /><meta name="description" content="Administre transacciones para procedimientos almacenados en Amazon Redshift." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="Guía para desarrolladores de bases de datos" /><meta name="abstract" content="Cree y administre un almacenamiento de datos con Amazon Redshift, un servicio de almacenamiento de datos completamente administrado a escala de petabytes de nivel empresarial." /><meta name="guide-locale" content="es_es" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-transaction-management.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="Guía para desarrolladores de bases de datos" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="Guía para desarrolladores de bases de datos" /><meta id="panorama-serviceConsolePage" value="Administración de transacciones" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Administración de transacciones - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#stored-procedure-transaction-management" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-transaction-management.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-transaction-management.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-transaction-management.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,Clúster,almacenamiento de datos,desarrollador,datos de ejemplo,base de datos,desarrollador de base de datos,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Guía para desarrolladores de bases de datos",
        "item" : "https://docs.aws.amazon.com/es_es/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Creación de procedimientos almacenados en Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-overview.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Información general de procedimientos almacenados en Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-create.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "Administración de transacciones",
        "item" : "https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-create.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#stored-procedure-transaction-management" target="_blank" rel="noopener noreferrer" title="Abrir PDF"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Documentación</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">Guía para desarrolladores de bases de datos</a></div><div id="page-toc-src"><a href="#stored-procedure-transaction-management-default-mode">Administración de transacciones de procedimientos almacenados en modo predeterminado</a><a href="#stored-procedure-transaction-management-nonatomic-mode">Administración de transacciones de procedimientos almacenados en modo no atómico</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="stored-procedure-transaction-management">Administración de transacciones</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p>Puede crear un procedimiento almacenado con un comportamiento de administración de transacciones predeterminado o un comportamiento no atómico. </p>           
            <h2 id="stored-procedure-transaction-management-default-mode">Administración de transacciones de procedimientos almacenados en modo predeterminado</h2>
                 
         <p>El comportamiento de confirmación automática de modo de transacción predeterminado hace que cada comando de SQL ejecutado por separado se confirme individualmente. Una llamada a un procedimiento almacenado se trata como un comando de SQL sencillo. Las instrucciones de SQL dentro de un procedimiento se comportan como si estuvieran en una bloque de transacciones que, de forma implícita, empieza cuando se inicia la llamada y acaba cuando finaliza la llamada. Una llamada anidada en otro procedimiento se trata como cualquier otra instrucción de SQL y opera dentro del contexto de la misma transacción como el intermediario. Para obtener más información acerca del comportamiento de confirmación automática, consulte <a href="./c_serial_isolation.html">Aislamiento serializable</a>.</p>
         

         <p>No obstante, supongamos que llama a un procedimiento almacenado desde dentro de un bloque de transacciones especificado del usuario (definido por BEGIN…COMMIT). En este caso, todas las instrucciones del procedimiento almacenado se ejecutan en el contexto de la transacción especificada por el usuario. El procedimiento no se confirma de forma implícita en la salida. El intermediario controla la confirmación o reversión del procedimiento.</p>
         
         <p>Si hay un error mientras se ejecuta un procedimiento almacenado, se revierten todos los cambios realizados en la transacción actual.</p>

         <p>Puede usar las siguientes instrucciones de control de transacción en un proceso almacenado:</p> 
         <div class="itemizedlist">
             
                         
         <ul class="itemizedlist"><li class="listitem"><p>COMMIT: confirma todo el trabajo realizado en la transacción actual y comienza una nueva transacción de forma implícita. Para obtener más información, consulte <a href="./r_COMMIT.html">COMMIT</a>. </p></li><li class="listitem"><p>ROLLBACK: invierte el trabajo realizado en la transacción actual y comienza una nueva transacción de forma implícita. Para obtener más información, consulte <a href="./r_ROLLBACK.html">ROLLBACK</a>. </p></li></ul></div>
         
         <p>TRUNCATE es otra instrucción que puede surgir en un proceso almacenado e influye en la administración de las transacciones. En Amazon Redshift, TRUNCATE emite una confirmación de forma implícita. Este comportamiento es el mismo en el contexto de procedimientos almacenados. Cuando se emite una instrucción TRUNCATE desde dentro de un procedimiento almacenado, se confirma la transacción actual y empieza una nueva. Para obtener más información, consulte <a href="./r_TRUNCATE.html">TRUNCATE</a>. </p>
         
         <p>Todas las instrucciones que siguen a una instrucción COMMIT, ROLLBACK o TRUNCATE funcionan en el contexto de una nueva transacción. Lo hacen hasta que se halla una instrucción COMMIT, ROLLBACK o TRUNCATE o hasta que el proceso almacenado sale.</p>
         
         <p>Cuando usa COMMIT, ROLLBACK o TRUNCATE desde dentro de un procedimiento almacenado, se aplican las siguientes limitaciones:</p>
         <div class="itemizedlist">
             
             
                        
         <ul class="itemizedlist"><li class="listitem"><p>Si se llama al procedimiento almacenado desde un bloque de transacciones, no puede emitir una instrucción COMMIT, ROLLBACK o TRUNCATE. Esta restricción aplica dentro del propio cuerpo del procedimiento almacenado y dentro de cualquier llamada de un proceso anidado.</p></li><li class="listitem"><p>Si se crea el procedimiento almacenado con opciones <code class="code">SET config</code>, no puede emitir una instrucción COMMIT, ROLLBACK o TRUNCATE. Esta restricción aplica dentro del propio cuerpo del procedimiento almacenado y dentro de cualquier llamada de un proceso anidado. </p></li><li class="listitem"><p>Cualquier cursor abierto (explícita o implícitamente) se cierra automáticamente cuando se procesa una instrucción COMMIT, ROLLBACK o TRUNCATE. Para conocer las limitaciones de cursores explícitas e implícitas, consulte <a href="./stored-procedure-constraints.html">Consideraciones para la compatibilidad con procedimientos almacenados</a>.</p></li></ul></div>
         
         <p>Adicionalmente, no puede ejecutar COMMIT o ROLLBACK usando SQL dinámico. Sin embargo, puede ejecutar TRUNCATE usando SQL dinámico. Para obtener más información, consulte <a href="./c_PLpgSQL-statements.html#r_PLpgSQL-dynamic-sql">SQL dinámico</a>. </p>
         
            
         
         <p>Cuando trabaje con procesos almacenados, considere que las instrucciones BEGIN y END en PL/pgSQL son solo para agrupar. No inician ni finalizan una transacción. Para obtener más información, consulte <a href="./c_PLpgSQL-structure.html#r_PLpgSQL-block">Bloque</a>. </p>
         
         
         
         <p>El siguiente ejemplo muestra el comportamiento de transacción cuando se llama a un procedimiento almacenado desde dentro de un bloque de transacciones explícitas. Las dos instrucciones de inserción emitidas desde fuera del procedimiento almacenado y la que se emite desde dentro forman parte de la misma transacción (3382). La transacción se confirma cuando el usuario emite una confirmación explícita.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_insert_table_a(a int) LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO test_table_a values (a);
END;
$$;

Begin;
  insert into test_table_a values (1);
  Call sp_insert_table_a(2);
  insert into test_table_a values (3);
Commit; 

select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  | pid |  type   |               stmt_text
--------+------+-----+---------+----------------------------------------
    103 | 3382 | 599 | UTILITY | Begin;
    103 | 3382 | 599 | QUERY   | insert into test_table_a values (1);
    103 | 3382 | 599 | UTILITY | Call sp_insert_table_a(2);
    103 | 3382 | 599 | QUERY   | INSERT INTO test_table_a values ( $1 )
    103 | 3382 | 599 | QUERY   | insert into test_table_a values (3);
    103 | 3382 | 599 | UTILITY | COMMIT
</code></pre>
         
         <p>Por contraste, hay un ejemplo cuando las mismas instrucciones se emiten desde el exterior del bloque de una transacción específica y la sesión tiene la autoconfirmación establecida en ON. En este caso, cada instrucción se ejecuta en su propia transacción.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">insert into test_table_a values (1);
Call sp_insert_table_a(2);
insert into test_table_a values (3);

select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  | pid |  type   |                                                                    stmt_text
--------+------+-----+---------+-------------------------------------------------------------------------------------------------------------------------------------------------
    103 | 3388 | 599 | QUERY   | insert into test_table_a values (1);
    103 | 3388 | 599 | UTILITY | COMMIT
    103 | 3389 | 599 | UTILITY | Call sp_insert_table_a(2);
    103 | 3389 | 599 | QUERY   | INSERT INTO test_table_a values ( $1 )
    103 | 3389 | 599 | UTILITY | COMMIT
    103 | 3390 | 599 | QUERY   | insert into test_table_a values (3);
    103 | 3390 | 599 | UTILITY | COMMIT            
</code></pre>
         
         <p>El siguiente ejemplo emite una instrucción TRUNCATE después de realizar una inserción en <code class="code">test_table_a</code>. La instrucción TRUNCATE emite una confirmación implícita que confirma la transacción actual (3335) y empieza una nueva (3336). La nueva transacción se confirma cuando se produce la salida del procedimiento.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_truncate_proc(a int, b int) LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO test_table_a values (a);
  TRUNCATE test_table_b;
  INSERT INTO test_table_b values (b);
END;
$$;

Call sp_truncate_proc(1,2);

select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  |  pid  |  type   |                                                                                             stmt_text
--------+------+-------+---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    103 | 3335 | 23636 | UTILITY | Call sp_truncate_proc(1,2);
    103 | 3335 | 23636 | QUERY   | INSERT INTO test_table_a values ( $1 )
    103 | 3335 | 23636 | UTILITY | TRUNCATE test_table_b
    103 | 3335 | 23636 | UTILITY | COMMIT
    103 | 3336 | 23636 | QUERY   | INSERT INTO test_table_b values ( $1 )
    103 | 3336 | 23636 | UTILITY | COMMIT    
</code></pre>
         
         <p>El siguiente ejemplo emite un TRUNCATE desde una llamada anidada. TRUNCATE confirma todo el trabajo realizado hasta el momento en los procedimientos internos y externos en una transacción (3344). Inicia una nueva transacción (3345). La nueva transacción se confirma cuando se produce la salida del procedimiento externo.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_inner(c int, d int) LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO inner_table values (c);
  TRUNCATE outer_table;
  INSERT INTO inner_table values (d);
END;
$$;

CREATE OR REPLACE PROCEDURE sp_outer(a int, b int, c int, d int) LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO outer_table values (a);
  Call sp_inner(c, d);
  INSERT INTO outer_table values (b);
END;
$$;

Call sp_outer(1, 2, 3, 4);

select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  |  pid  |  type   |                                                                                              stmt_text
--------+------+-------+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    103 | 3344 | 23636 | UTILITY | Call sp_outer(1, 2, 3, 4);
    103 | 3344 | 23636 | QUERY   | INSERT INTO outer_table values ( $1 )
    103 | 3344 | 23636 | UTILITY | CALL sp_inner( $1 , $2 )
    103 | 3344 | 23636 | QUERY   | INSERT INTO inner_table values ( $1 )
    103 | 3344 | 23636 | UTILITY | TRUNCATE outer_table
    103 | 3344 | 23636 | UTILITY | COMMIT
    103 | 3345 | 23636 | QUERY   | INSERT INTO inner_table values ( $1 )
    103 | 3345 | 23636 | QUERY   | INSERT INTO outer_table values ( $1 )
    103 | 3345 | 23636 | UTILITY | COMMIT
</code></pre>
         
         <p>El siguiente ejemplo muestra que el cursor <code class="code">cur1</code> se cerró cuando se confirmó la instrucción TRUNCATE.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_open_cursor_truncate()
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  cur1 cursor for select * from test_table_a order by 1;
BEGIN
  open cur1;
  TRUNCATE table test_table_b;
  Loop
    fetch cur1 into rec;
    raise info '%', rec.c1;
    exit when not found;
  End Loop;
END
$$;

call sp_open_cursor_truncate();
ERROR: cursor "cur1" does not exist
CONTEXT: PL/pgSQL function "sp_open_cursor_truncate" line 8 at fetch
</code></pre>

         <p>El siguiente ejemplo emite una instrucción TRUNCATE y no puede ser llamado desde dentro de un bloque de transacciones explícitas.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_truncate_atomic() LANGUAGE plpgsql
AS $$
BEGIN
  TRUNCATE test_table_b;
END;
$$;

Begin;
  Call sp_truncate_atomic();
ERROR: TRUNCATE cannot be invoked from a procedure that is executing in an atomic context.
HINT: Try calling the procedure as a top-level call i.e. not from within an explicit transaction block. 
Or, if this procedure (or one of its ancestors in the call chain) was created with SET config options, recreate the procedure without them.
CONTEXT: SQL statement "TRUNCATE test_table_b"
PL/pgSQL function "sp_truncate_atomic" line 2 at SQL statement 
</code></pre>
         
         
         <p>El ejemplo siguiente muestra que un usuario que no es un superusuario ni el propietario de una tabla puede emitir una instrucción TRUNCATE en la tabla. El usuario lo hace utilizando un procedimiento almacenado de <code class="code">Security Definer</code>. En el ejemplo se muestran las acciones siguientes: </p>
         <div class="itemizedlist">
             
             
             
             
         <ul class="itemizedlist"><li class="listitem"><p>El usuario 1 crea la tabla <code class="code">test_tbl</code>. </p></li><li class="listitem"><p>El usuario 1 crea un procedimiento almacenado <code class="code">sp_truncate_test_tbl</code>. </p></li><li class="listitem"><p>El usuario 1 concede el privilegio <code class="code">EXECUTE</code> en el procedimiento almacenado al usuario 2. </p></li><li class="listitem"><p>El usuario 2 ejecuta el procedimiento almacenado para truncar la tabla <code class="code">test_tbl</code>. En el ejemplo se muestra el recuento de filas antes y después del comando <code class="code">TRUNCATE</code>. </p></li></ul></div> 
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">set session_authorization to user1;
create table test_tbl(id int, name varchar(20));
insert into test_tbl values (1,'john'), (2, 'mary');
CREATE OR REPLACE PROCEDURE sp_truncate_test_tbl() LANGUAGE plpgsql
AS $$
DECLARE
  tbl_rows int;
BEGIN
  select count(*) into tbl_rows from test_tbl;
  RAISE INFO 'RowCount before Truncate: %', tbl_rows;
  TRUNCATE test_tbl;
  select count(*) into tbl_rows from test_tbl;
  RAISE INFO 'RowCount after Truncate: %', tbl_rows;
END;
$$ SECURITY DEFINER;
grant execute on procedure sp_truncate_test_tbl() to user2;
reset session_authorization;


set session_authorization to user2;
call sp_truncate_test_tbl();
INFO:  RowCount before Truncate: 2
INFO:  RowCount after Truncate: 0
CALL
reset session_authorization;         
</code></pre>
         
                     
         
  
         
         <p>El siguiente ejemplo emite COMMIT dos veces. El primer COMMIT confirma todo el trabajo realizado en la transacción 10363 e implícitamente inicia la transacción 10364. La transacción 10364 se confirma por la segunda instrucción COMMIT. </p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_commit(a int, b int) LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO test_table values (a);
  COMMIT;
  INSERT INTO test_table values (b);
  COMMIT;
END;
$$;

call sp_commit(1,2);

select userid, xid, pid, type, trim(text) as stmt_text
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;
 userid |  xid  | pid  |  type   |                                                                                    stmt_text
--------+-------+------+---------+-----------------------------------------------------------------------------------------------------------------
    100 | 10363 | 3089 | UTILITY | call sp_commit(1,2);
    100 | 10363 | 3089 | QUERY   | INSERT INTO test_table values ( $1 )
    100 | 10363 | 3089 | UTILITY | COMMIT
    100 | 10364 | 3089 | QUERY   | INSERT INTO test_table values ( $1 )
    100 | 10364 | 3089 | UTILITY | COMMIT
</code></pre>
 
   
    
         <p>El siguiente ejemplo emite una instrucción ROLLBACK si <code class="code">sum_vals</code> es mayor que 2. La primera instrucción ROLLBACK revierte todo el trabajo realizado en la transacción 10377 e inicia una nueva transacción 10378. La transacción 10378 se confirma cuando se produce la salida del procedimiento. </p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_rollback(a int, b int) LANGUAGE plpgsql
AS $$
DECLARE
  sum_vals int;
BEGIN
  INSERT INTO test_table values (a);
  SELECT sum(c1) into sum_vals from test_table;
  IF sum_vals &gt; 2 THEN
    ROLLBACK;
  END IF;
  
  INSERT INTO test_table values (b);
END;
$$;

call sp_rollback(1, 2);

select userid, xid, pid, type, trim(text) as stmt_text
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

userid |  xid  | pid  |  type   |                                                                                    stmt_text
--------+-------+------+---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    100 | 10377 | 3089 | UTILITY | call sp_rollback(1, 2);
    100 | 10377 | 3089 | QUERY   | INSERT INTO test_table values ( $1 )
    100 | 10377 | 3089 | QUERY   | SELECT sum(c1) from test_table
    100 | 10377 | 3089 | QUERY   | Undoing 1 transactions on table 133646 with current xid 10377 : 10377
    100 | 10378 | 3089 | QUERY   | INSERT INTO test_table values ( $1 )
    100 | 10378 | 3089 | UTILITY | COMMIT
</code></pre>
          
               
               <h2 id="stored-procedure-transaction-management-nonatomic-mode">Administración de transacciones de procedimientos almacenados en modo no atómico</h2>
               
               
               
               <p>Un procedimiento almacenado creado en modo NONATOMIC tiene un comportamiento de control de transacciones diferente al de un procedimiento creado en modo predeterminado. De forma similar al comportamiento de confirmación automática de los comandos SQL fuera de los procedimientos almacenados, cada instrucción SQL en un procedimiento NONATOMIC se ejecuta en su propia transacción y se confirma automáticamente. Si un usuario inicia un bloque de transacción explícito en un procedimiento almacenado NONATOMIC, las instrucciones SQL del bloque no se confirman automáticamente. El bloque de transacción controla la confirmación o la reversión de las instrucciones que contiene. </p>
               
               <p>En los procedimientos almacenados NONATOMIC, puede abrir un bloque de transacción explícito en el procedimiento mediante la instrucción START TRANSACTION. Sin embargo, si ya hay un bloque de transacción abierto, esta instrucción no servirá de nada porque Amazon Redshift no admite transacciones secundarias. La transacción anterior continúa.</p>
               
               <p>Cuando trabaje con bucles FOR de cursor en un procedimiento NONATOMIC, asegúrese de abrir un bloque de transacción explícito antes de iterar por los resultados de una consulta. De lo contrario, el cursor se cierra cuando la instrucción SQL dentro del bucle se confirma automáticamente.</p>
               
               <p>Algunas de las consideraciones al utilizar el comportamiento del modo NONATOMIC son las siguientes:</p>
               <div class="itemizedlist">
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem"><p>Cada instrucción SQL del procedimiento almacenado se confirma automáticamente si no hay ningún bloque de transacción abierto y la sesión tiene activada la opción de confirmación automática.</p></li><li class="listitem"><p>Puede emitir una instrucción COMMIT/ROLLBACK/TRUNCATE para finalizar la transacción si el procedimiento almacenado se llama desde un bloque de transacción. Esto no es posible en el modo predeterminado.</p></li><li class="listitem"><p>Puede emitir una instrucción START TRANSACTION para iniciar un bloque de transacción en el procedimiento almacenado.</p></li></ul></div>
               
               <p>En los siguientes ejemplos, se muestra el comportamiento de las transacciones cuando se trabaja con procedimientos almacenados NONATOMIC. La sesión de todos los ejemplos siguientes tiene activada la confirmación automática.</p>
               
               <p>En el siguiente ejemplo, un procedimiento almacenado NONATOMIC tiene dos instrucciones INSERT. Cuando se llama al procedimiento fuera de un bloque de transacción, cada instrucción INSERT del procedimiento se confirma automáticamente. </p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE TABLE test_table_a(v int); 
CREATE TABLE test_table_b(v int); 

CREATE OR REPLACE PROCEDURE sp_nonatomic_insert_table_a(a int, b int) NONATOMIC AS
$$
BEGIN
    INSERT INTO test_table_a values (a);
    INSERT INTO test_table_b values (b);
END;
$$ 
LANGUAGE plpgsql;

Call sp_nonatomic_insert_table_a(1,2);

Select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  |    pid     |  type   |               stmt_text                
--------+------+------------+---------+----------------------------------------
      1 | 1792 | 1073807554 | UTILITY | Call sp_nonatomic_insert_table_a(1,2);
      1 | 1792 | 1073807554 | QUERY   | INSERT INTO test_table_a values ( $1 )
      1 | 1792 | 1073807554 | UTILITY | COMMIT
      1 | 1793 | 1073807554 | QUERY   | INSERT INTO test_table_b values ( $1 )
      1 | 1793 | 1073807554 | UTILITY | COMMIT
(5 rows)          
</code></pre>
               
               <p>No obstante, cuando el procedimiento se llama desde un bloque BEGIN..COMMIT, todas las instrucciones forman parte de la misma transacción (xid=1799). </p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">Begin;
  INSERT INTO test_table_a values (10);
  Call sp_nonatomic_insert_table_a(20,30);
  INSERT INTO test_table_b values (40);
Commit; 

Select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  |    pid     |  type   |                stmt_text                 
--------+------+------------+---------+------------------------------------------
      1 | 1799 | 1073914035 | UTILITY | Begin;
      1 | 1799 | 1073914035 | QUERY   | INSERT INTO test_table_a values (10);
      1 | 1799 | 1073914035 | UTILITY | Call sp_nonatomic_insert_table_a(20,30);
      1 | 1799 | 1073914035 | QUERY   | INSERT INTO test_table_a values ( $1 )
      1 | 1799 | 1073914035 | QUERY   | INSERT INTO test_table_b values ( $1 )
      1 | 1799 | 1073914035 | QUERY   | INSERT INTO test_table_b values (40);
      1 | 1799 | 1073914035 | UTILITY | COMMIT
(7 rows)
</code></pre>
               
               <p>En este ejemplo, hay dos instrucciones INSERT entre START TRANSACTION...COMMIT. Cuando se llama al procedimiento fuera de un bloque de transacción, las dos instrucciones INSERT se encuentran en la misma transacción (xid=1866). </p>
               
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_nonatomic_txn_block(a int, b int) NONATOMIC AS
$$
BEGIN
    START TRANSACTION;
    INSERT INTO test_table_a values (a);
    INSERT INTO test_table_b values (b);
    COMMIT;
END;
$$ 
LANGUAGE plpgsql;

Call sp_nonatomic_txn_block(1,2);

Select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  |    pid     |  type   |               stmt_text                
--------+------+------------+---------+----------------------------------------
      1 | 1865 | 1073823998 | UTILITY | Call sp_nonatomic_txn_block(1,2);
      1 | 1866 | 1073823998 | QUERY   | INSERT INTO test_table_a values ( $1 )
      1 | 1866 | 1073823998 | QUERY   | INSERT INTO test_table_b values ( $1 )
      1 | 1866 | 1073823998 | UTILITY | COMMIT
(4 rows)
</code></pre>
               
               <p>Cuando se llama al procedimiento desde dentro de un bloque BEGIN...COMMIT, la instrucción START TRANSACTION en el procedimiento no hace nada porque ya hay una transacción abierta. La instrucción COMMIT en el procedimiento confirma la transacción actual (xid=1876) e inicia una nueva.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">Begin;
  INSERT INTO test_table_a values (10);
  Call sp_nonatomic_txn_block(20,30);
  INSERT INTO test_table_b values (40);
Commit; 

Select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  |    pid     |  type   |               stmt_text                
--------+------+------------+---------+----------------------------------------
      1 | 1876 | 1073832133 | UTILITY | Begin;
      1 | 1876 | 1073832133 | QUERY   | INSERT INTO test_table_a values (10);
      1 | 1876 | 1073832133 | UTILITY | Call sp_nonatomic_txn_block(20,30);
      1 | 1876 | 1073832133 | QUERY   | INSERT INTO test_table_a values ( $1 )
      1 | 1876 | 1073832133 | QUERY   | INSERT INTO test_table_b values ( $1 )
      1 | 1876 | 1073832133 | UTILITY | COMMIT
      1 | 1878 | 1073832133 | QUERY   | INSERT INTO test_table_b values (40);
      1 | 1878 | 1073832133 | UTILITY | COMMIT
(8 rows)
</code></pre>
               
               <p>En este ejemplo, se muestra cómo trabajar con bucles de cursor. La tabla test_table_a tiene tres valores. El objetivo es iterar por los tres valores e insertarlos en la tabla test_table_b. Si se crea un procedimiento almacenado NONATOMIC de la siguiente forma, se generará el error de que el cursor “cur1” no existe después de ejecutar la instrucción INSERT en el primer bucle. Esto se debe a que la confirmación automática de INSERT cierra el cursor abierto.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">insert into test_table_a values (1), (2), (3);

CREATE OR REPLACE PROCEDURE sp_nonatomic_cursor() NONATOMIC
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  cur1 cursor for select * from test_table_a order by 1;
BEGIN
  open cur1;
  Loop
    fetch cur1 into rec;
    exit when not found;
    raise info '%', rec.v;
    insert into test_table_b values (rec.v);
  End Loop;
END
$$;

CALL sp_nonatomic_cursor();

INFO:  1
ERROR:  cursor "cur1" does not exist
CONTEXT:  PL/pgSQL function "sp_nonatomic_cursor" line 7 at fetch
</code></pre>
               
               <p>Para que el bucle de cursor funcione, colóquelo entre START TRANSACTION...COMMIT.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">insert into test_table_a values (1), (2), (3);

CREATE OR REPLACE PROCEDURE sp_nonatomic_cursor() NONATOMIC
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  cur1 cursor for select * from test_table_a order by 1;
BEGIN
  START TRANSACTION;
  open cur1;
  Loop
    fetch cur1 into rec;
    exit when not found;
    raise info '%', rec.v;
    insert into test_table_b values (rec.v);
  End Loop;
  COMMIT;
END
$$;

CALL sp_nonatomic_cursor();

INFO:  1
INFO:  2
INFO:  3
CALL
</code></pre>
               
            <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Aviso" /> <strong>JavaScript está desactivado o no está disponible en su navegador.</strong></p><p>Para utilizar la documentación de AWS, debe estar habilitado JavaScript. Para obtener más información, consulte las páginas de ayuda de su navegador.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Convenciones del documento</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./stored-procedure-result-set.html">Devolución de un conjunto de resultados</div><div id="next" class="next-link" accesskey="n" href="./stored-procedure-trapping-errors.html">Errores de captura</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">¿Le ha servido de ayuda esta página? - Sí</div><div class="content"><p>Gracias por hacernos saber que estamos haciendo un buen trabajo.</p><p>Si tiene un momento, díganos qué es lo que le ha gustado para que podamos seguir trabajando en esa línea.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Comentarios" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-transaction-management.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">¿Le ha servido de ayuda esta página? - No</div><div class="content"><p>Gracias por informarnos de que debemos trabajar en esta página. Lamentamos haberle defraudado.</p><p>Si tiene un momento, díganos cómo podemos mejorar la documentación.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Comentarios" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-transaction-management.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>