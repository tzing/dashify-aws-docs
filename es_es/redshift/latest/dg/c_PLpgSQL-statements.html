<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="es-ES"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Instrucciones de PL/pgSQL admitidas - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="c_PLpgSQL-statements" /><meta name="default_state" content="c_PLpgSQL-statements" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="description" content="Trabaje con instrucciones PL/pgSQL admitidas por Amazon Redshift." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="Guía para desarrolladores de bases de datos" /><meta name="abstract" content="Cree y administre un almacenamiento de datos con Amazon Redshift, un servicio de almacenamiento de datos completamente administrado a escala de petabytes de nivel empresarial." /><meta name="guide-locale" content="es_es" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="Guía para desarrolladores de bases de datos" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="Guía para desarrolladores de bases de datos" /><meta id="panorama-serviceConsolePage" value="Instrucciones de PL/pgSQL admitidas" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Instrucciones de PL/pgSQL admitidas - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#c_PLpgSQL-statements" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,Clúster,almacenamiento de datos,desarrollador,datos de ejemplo,base de datos,desarrollador de base de datos,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Guía para desarrolladores de bases de datos",
        "item" : "https://docs.aws.amazon.com/es_es/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Creación de procedimientos almacenados en Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-overview.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Referencia del lenguaje PL/pgSQL",
        "item" : "https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_pl_pgSQL_reference.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "Instrucciones de PL/pgSQL admitidas",
        "item" : "https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_pl_pgSQL_reference.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#c_PLpgSQL-statements" target="_blank" rel="noopener noreferrer" title="Abrir PDF"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Documentación</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">Guía para desarrolladores de bases de datos</a></div><div id="page-toc-src"><a href="#r_PLpgSQL-assignment">Asignación</a><a href="#r_PLpgSQL-select-into">SELECT INTO</a><a href="#r_PLpgSQL-no-op">No-op</a><a href="#r_PLpgSQL-dynamic-sql">SQL dinámico</a><a href="#r_PLpgSQL-return">Return</a><a href="#r_PLpgSQL-conditionals-if">Condicionales: IF </a><a href="#r_PLpgSQL-conditionals-case">Condicionales: CASE</a><a href="#r_PLpgSQL-loops">Bucles</a><a href="#r_PLpgSQL-cursors">Cursores</a><a href="#r_PLpgSQL-messages-errors">RAISE</a><a href="#r_PLpgSQL-transaction-control">Control de la transacción</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="c_PLpgSQL-statements">Instrucciones de PL/pgSQL admitidas</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p> Las instrucciones PL/pgSQL aumentan los comandos SQL con construcciones de procedimiento, entre las que se incluyen expresiones condicionales y bucles, para controlar el flujo lógico. Se puede usar la mayoría de los comandos SQL, lo que incluye el lenguaje de manipulación de datos (DML), como COPY, UNLOAD e INSERT, y el lenguaje de definición de datos (DDL), como CREATE TABLE. Para ver una lista completa de comandos SQL, consulte <a href="./c_SQL_commands.html">Comandos SQL</a>. Además, Amazon Redshift admite las siguientes instrucciones PL/pgSQL. </p><div class="highlights" id="inline-topiclist"><h6>Temas</h6><ul><li><a href="#r_PLpgSQL-assignment">Asignación</a></li><li><a href="#r_PLpgSQL-select-into">SELECT INTO</a></li><li><a href="#r_PLpgSQL-no-op">No-op</a></li><li><a href="#r_PLpgSQL-dynamic-sql">SQL dinámico</a></li><li><a href="#r_PLpgSQL-return">Return</a></li><li><a href="#r_PLpgSQL-conditionals-if">Condicionales: IF</a></li><li><a href="#r_PLpgSQL-conditionals-case">Condicionales: CASE</a></li><li><a href="#r_PLpgSQL-loops">Bucles</a></li><li><a href="#r_PLpgSQL-cursors">Cursores</a></li><li><a href="#r_PLpgSQL-messages-errors">RAISE</a></li><li><a href="#r_PLpgSQL-transaction-control">Control de la transacción</a></li></ul></div>
            <h2 id="r_PLpgSQL-assignment">Asignación</h2>  
            
            <p>La instrucción de asignación asigna un valor a una variable. La expresión debe devolver un valor único.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">identifier := expression;</code></pre>
            
            <p>También es posible usar <code class="code">=</code> no estándar para la asignación, en lugar de <code class="code">:=</code>.</p>
            
           <p>Si el tipo de datos de la expresión no coincide con el tipo de datos de la variable o si la variable tiene un tamaño o precisión conocidos, el valor del resultado se convertirá de forma implícita.</p>
      <p>A continuación se muestran ejemplos.</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">customer_number := 20;
tip := subtotal * 0.15;</code></pre>
            
          
            <h2 id="r_PLpgSQL-select-into">SELECT INTO</h2> 
            
           
            <p>La instrucción SELECT INTO asigna el resultado de varias columnas (pero solo una fila) a una variable de registro o lista de variables escalares.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">SELECT INTO <code class="replaceable">target</code> <code class="replaceable">select_expressions</code> FROM ...;</code></pre>  
            
            
            <p>En la sintaxis anterior, el <code class="replaceable">destino</code> puede ser una variable de registro o una lista separada por comas de variables simples y campos de registro. La lista <code class="replaceable">seleccionar_expresiones</code> y el resto del comando son iguales que en SQL normal.</p>
            <p>Si se usa como <code class="replaceable">destino</code> una lista de variables, los valores seleccionados deben coincidir exactamente con la estructura del destino o se producirá un error de tiempo de ejecución. Cuando el destino es una variable de registro, se configura automáticamente al tipo fila de las columnas resultantes de la consulta.</p>
            <p>La cláusula INTO puede aparece casi en cualquier parte en la instrucción SELECT. Normalmente, aparece justo después de la cláusula SELECT o justo antes de la cláusula FROM. Es decir, aparece justo antes o justo después de la lista <code class="replaceable">seleccionar_expresiones</code>.</p>
            <p>Si la consulta no devuelve ninguna fila, se asignan valores NULL al <code class="replaceable">destino</code>. Si la consulta devuelve varias filas, se asigna la primera fila al <code class="replaceable">destino</code> y el resto se descartan. A menos que la instrucción contenga un comando ORDER BY, la primera fila no es determinista.</p>
            <p>Para determinar si la asignación devuelve al menos una fila, use la variable especial FOUND.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">SELECT INTO customer_rec * FROM cust WHERE custname = lname;
IF NOT FOUND THEN
  RAISE EXCEPTION 'employee % not found', lname;
END IF;
</code></pre>
            
            <p>Para probar si un resultado de registro es nulo, puede usar el condicional IS NULL. No hay forma de determinar si se han descartado filas adicionales. En el siguiente ejemplo, se gestiona un caso donde no se devuelven filas.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE select_into_null(return_webpage OUT varchar(256))
AS $$
DECLARE
  customer_rec RECORD;
BEGIN
  SELECT INTO customer_rec * FROM users WHERE user_id=3;
  IF customer_rec.webpage IS NULL THEN
    -- user entered no webpage, return "http://"
    return_webpage = 'http://';
  END IF;
END;
$$ LANGUAGE plpgsql;         
</code></pre>
            
          
            <h2 id="r_PLpgSQL-no-op">No-op</h2>  
           
            <p>La instrucción no-op (<code class="code">NULL;</code>) es una instrucción de marcador de posición que no hace nada. La instrucción no-op puede indicar que una ramificación de una cadena IF-THEN-ELSE está vacía.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="">NULL;</code></pre> 
 
 
            
          
            <h2 id="r_PLpgSQL-dynamic-sql">SQL dinámico</h2>  
            
            <p>Para generar comandos dinámicos que puedan implicar diferentes tablas o diferentes tipos de datos cada vez que se ejecutan desde un procedimiento almacenado de PL/pgSQL, use el comando <code class="code">EXECUTE</code>.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">EXECUTE <code class="replaceable">command-string</code> [ INTO target ];</code></pre> 
            
            <p>En lo anterior, <code class="replaceable">cadena-comando</code> es una expresión que contiene una cadena (de tipo texto) que contiene el comando que se va a ejecutar. Esta valor de <code class="replaceable">cadena-comando</code> se envía al motor de SQL. No se realiza sustitución de variables de PL/pgSQL en la cadena del comando. Los valores de las variables se deben insertar en la cadena en el momento de su construcción.</p>
           
           <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>nota</h6></div><div class="awsdocs-note-text"><p>No puede utilizar las instrucciones COMMIT y ROLLBACK desde un SQL dinámico. Para más información sobre el uso de las instrucciones COMMIT y ROLLBACK en un proceso almacenado, vea <a href="./stored-procedure-transaction-management.html">Administración de transacciones</a>. </p></div></div> 
            
            <p>Al trabajar con comandos dinámicos, a menudo tendrá que gestionar el escape de comillas simples. Recomendamos poner el texto fijo entrecomillas en el cuerpo de la función mediante signos de dólar. Los valores dinámicos que se van a insertar en una consulta construida requieren gestión especial porque ellos mismos pueden estar entrecomillados. En el siguiente ejemplo, se supone que hay entrecomillado con signos de dólar de la función como un todo, de modo que las comillas no tienen que ser dobles.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">EXECUTE 'UPDATE tbl SET '
  || quote_ident(colname)
  || ' = '
  || quote_literal(newvalue)
  || ' WHERE key = '
  || quote_literal(keyvalue);               
</code></pre>
            
            <p>El ejemplo anterior muestra las funciones <code class="code">quote_ident(text)</code> y <code class="code">quote_literal(text)</code>. Este ejemplo pasa variables que contienen identificadores de columna y tabla a la función <code class="code">quote_ident</code>. También pasa variables que contienen cadenas literales en el comando construido a la función <code class="code">quote_literal</code>. Ambas funciones realizan los pasos adecuados para devolver el texto que se ingresó encerrado entre comillas dobles o simples, respectivamente, con cualquier carácter especial integrado con los identificadores de escape adecuados.</p>
            <p>El entrecomillado con signos de dólar solo es útil para entrecomillar texto fijo. No escriba el ejemplo anterior en el formato siguiente.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">EXECUTE 'UPDATE tbl SET '
  || quote_ident(colname)
  || ' = $$'
  || newvalue
  || '$$ WHERE key = '
  || quote_literal(keyvalue);               
</code></pre>
            
            <p>Esto no se hace porque el ejemplo produce un error si el contenido de <code class="code">newvalue</code> tiene $$. El mismo problema ocurre con otros delimitadores de dólar que pueda usar. Para entrecomillar de manera segura texto que no conoce de antemano, use la función <code class="code">quote_literal</code>.</p>
            
          
            <h2 id="r_PLpgSQL-return">Return</h2>   
            
            <p>La instrucción RETURN vuelve al intermediario de un procedimiento almacenado.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="">RETURN;</code></pre>
            
            <p>A continuación se muestra un ejemplo.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE return_example(a int)
AS $$  
BEGIN
  FOR b in 1..10 LOOP
    IF b &lt; a THEN
      RAISE INFO 'b = %', b;
    ELSE
      RETURN;
    END IF;
  END LOOP;
END;
$$ LANGUAGE plpgsql;               
</code></pre>
            
          
            <h2 id="r_PLpgSQL-conditionals-if">Condicionales: IF</h2>  
           
           
            
            <p>La instrucción condicional IF puede adoptar las siguientes formas en el lenguaje PL/pgSQL que utiliza Amazon Redshift:</p>
            
            
            <div class="itemizedlist">
                
               
               
               
                  

                
            
            <ul class="itemizedlist"><li class="listitem"><p>IF ... THEN</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
END IF;
</code></pre>
                  
            <p>A continuación se muestra un ejemplo.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF v_user_id &lt;&gt; 0 THEN
  UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;               
</code></pre>
            
            </li><li class="listitem"><p>IF ... THEN ... ELSE</p>
 <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
ELSE
  statements
END IF;
</code></pre>
                  
               <p>A continuación se muestra un ejemplo.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF parentid IS NULL OR parentid = ''
THEN
  return_name = fullname;
  RETURN;
ELSE
  return_name = hp_true_filename(parentid) || '/' || fullname;
  RETURN;
END IF;           
</code></pre>
                  
               </li><li class="listitem"><p>IF ... THEN ... ELSIF ... THEN ... ELSE </p>
                  <p>La palabra clave ELSIF también puede deletrearse ELSEIF.</p>                  
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
[ ELSIF boolean-expression THEN
  statements
[ ELSIF boolean-expression THEN
  statements
    ...] ]
[ ELSE
  statements ]
END IF;
</code></pre>                  
               

               
               <p>A continuación se muestra un ejemplo.</p>
               
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF number = 0 THEN
  result := 'zero';
ELSIF number &gt; 0 THEN
  result := 'positive';
ELSIF number &lt; 0 THEN
  result := 'negative';
ELSE
  -- the only other possibility is that number is null
  result := 'NULL';
END IF;                  
</code></pre>
               </li></ul></div>
            
           
            
          
            <h2 id="r_PLpgSQL-conditionals-case">Condicionales: CASE</h2>  
           <p>La instrucción condicional CASE puede adoptar las siguientes formas en el lenguaje PL/pgSQL que utiliza Amazon Redshift:</p>
            <div class="itemizedlist">
                
                 

            <ul class="itemizedlist"><li class="listitem"><p>CASE simple </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CASE <code class="replaceable">search-expression</code>
WHEN <code class="replaceable">expression</code> [, <code class="replaceable">expression</code> [ ... ]] THEN
  <code class="replaceable">statements</code>
[ WHEN <code class="replaceable">expression</code> [, <code class="replaceable">expression</code> [ ... ]] THEN
  <code class="replaceable">statements</code>
  ... ]
[ ELSE
  <code class="replaceable">statements</code> ]
END CASE;
</code></pre>
                  
                  <p>La instrucción CASE simple proporciona ejecución condicional basada en la igualdad de los operandos.</p>
                  
                  <p>El valor de <code class="replaceable">expresión-búsqueda</code> se evalúa una vez y se compara sucesivamente a cada <code class="replaceable">expresión</code> en la cláusula WHEN. Si se encuentra una coincidencia, se ejecuta la <code class="replaceable">instrucción</code> correspondiente y, a continuación, el control pasa a la siguiente instrucción después de END CASE. Las expresiones WHEN posteriores no se evalúan. Si no se encuentra una coincidencia, se ejecuta la <code class="replaceable">instrucción</code> ELSE. No obstante, si ELSE no está presente, entonces se genera una excepción CASE_NOT_FOUND.</p>
                  
               <p>A continuación se muestra un ejemplo.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CASE x
WHEN 1, 2 THEN
  msg := 'one or two';
ELSE
  msg := 'other value than one or two';
END CASE;                  
</code></pre>
                  
               </li><li class="listitem"><p>CASE de búsqueda </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CASE
WHEN <code class="replaceable">boolean-expression</code> THEN
  statements
[ WHEN <code class="replaceable">boolean-expression</code> THEN
  statements
  ... ]
[ ELSE
  statements ]
END CASE;
</code></pre>
                  
                  <p>La forma de búsqueda de CASE proporciona ejecución condicional basada en expresiones boolenas verdaderas. </p>
                  
                  <p>Cada <code class="replaceable">expresión-boleana</code> de la cláusula WHEN se evalúa por turno, hasta encontrar una que dé como resultado true. A continuación se ejecuta la instrucción correspondiente y el control pasa a la siguiente instrucción después de END CASE. Las <code class="replaceable">expresiones</code> WHEN posteriores no se evalúan. Si no se encuentra ningún resultado true, se ejecutan las <code class="replaceable">instrucciones</code> ELSE. No obstante, si ELSE no está presente, entonces se genera una excepción CASE_NOT_FOUND.</p>
                  
                  <p>A continuación se muestra un ejemplo.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CASE
WHEN x BETWEEN 0 AND 10 THEN
  msg := 'value is between zero and ten';
WHEN x BETWEEN 11 AND 20 THEN
  msg := 'value is between eleven and twenty';
END CASE;                                
</code></pre>
                  
               </li></ul></div>                      
            
          
            <h2 id="r_PLpgSQL-loops">Bucles</h2>  
            
           <p>Las instrucciones bucle pueden adoptar las siguientes formas en el lenguaje PL/pgSQL que utiliza Amazon Redshift:</p>
            <div class="itemizedlist">
                
               
                 
               
                 
               
                
               
                 
               
                 
               
               
               
                                  
               
               
            <ul class="itemizedlist"><li class="listitem"><p>Bucle simple </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
LOOP
  statements
END LOOP [ label ];
</code></pre>
                  
                  <p>Un bucle simple define un bucle incondicional que se repite indefinidamente hasta que es terminado por una instrucción EXIT o RETURN. Las instrucciones EXIT y CONTINUE pueden utilizar la etiqueta opcional dentro de los bucles anidados para especificar a qué bucle se refiere la instrucción EXIT y CONTINUE.</p>
                  
               <p>A continuación se muestra un ejemplo.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE simple_loop()
LANGUAGE plpgsql
AS $$
BEGIN
  &lt;&lt;simple_while&gt;&gt;
  LOOP
    RAISE INFO 'I am raised once';  
    EXIT simple_while;
    RAISE INFO 'I am not raised';
  END LOOP;
  RAISE INFO 'I am raised once as well';
END;
$$;                
</code></pre>

               </li><li class="listitem"><p>Bucle Exit</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">EXIT [ <code class="replaceable">label</code> ] [ WHEN <code class="replaceable">expression</code> ];
</code></pre> 
                 <p>Si no está presente la<code class="replaceable">etiqueta</code>, se termina el bucle más interno y, a continuación, se ejecuta la instrucción después de END LOOP. Si la <code class="replaceable">etiqueta</code> está presente, debe ser la etiqueta del nivel actual o de uno superior del bloque o bucle anidado. A continuación, el bucle o bloque mencionado se termina y el control continúa con la instrucción después del correspondiente END del bucle o bloque.</p>
                  <p>Si se especifica WHEN, solo se produce la salida del bucle si la <code class="replaceable">expresión</code> es verdadera. De no ser así, el control pasa a la instrucción después de EXIT.</p>
                  <p>Puede usar EXIT con todos los tipos de bucles; su uso no se limita a bucles incondicionales.</p>
                  <p>Cuando se usa con un bloque BEGIN, EXIT pasa el control a la siguiente instrucción después del final del bloque. Debe usarse una etiqueta para este propósito. Un EXIT sin etiqueta no se considera una coincidencia para un bloque BEGIN.</p>
                  <p>A continuación se muestra un ejemplo.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE simple_loop_when(x int)
LANGUAGE plpgsql
AS $$
DECLARE i INTEGER := 0;
BEGIN
  &lt;&lt;simple_loop_when&gt;&gt;
  LOOP
    RAISE INFO 'i %', i;
    i := i + 1;
    EXIT simple_loop_when WHEN (i &gt;= x);
  END LOOP;
END;
$$;                     
</code></pre>
               </li><li class="listitem"><p>Bucle Continue </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CONTINUE [ <code class="replaceable">label</code> ] [ WHEN <code class="replaceable">expression</code> ];
</code></pre> 
                  <p>Si no se proporciona una <code class="replaceable">etiqueta</code>, la ejecución salta a la siguiente iteración del bucle más interno. Es decir, se omiten todas las instrucciones restantes en el cuerpo del bucle. El control vuelve a la expresión de control del bucle (de haberla) para determinar si se necesita otra iteración del bucle. Si la <code class="replaceable">etiqueta</code> está presente, especifica la etiqueta del bucle cuya ejecución se continúa.</p>
                  <p>Si se especifica WHEN, la siguiente iteración del bucle solo empieza si la <code class="replaceable">expresión </code> es verdadera. De no ser así, el control pasa a la instrucción después de CONTINUE.</p>
                  <p>Puede usar CONTINUE con todos los tipos de bucles; su uso no se limita a bucles incondicionales.</p>
                  
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CONTINUE mylabel;
</code></pre> 
                  
               </li><li class="listitem"><p>Bucle WHILE </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
WHILE expression LOOP
  statements
END LOOP [ label ];
</code></pre> 
                  
               <p>La instrucción WHILE repite una secuencia de instrucciones siempre que la <code class="replaceable">expresión-boleana</code> sea verdadera. La expresión se comprueba justo antes de cada entrada al cuerpo del bucle.</p> 
               <p>A continuación se muestra un ejemplo.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
  -- some computations here
END LOOP;

WHILE NOT done LOOP
  -- some computations here
END LOOP;                  
</code></pre>
               </li><li class="listitem"><p>Bucle FOR (variante de entero) </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR name IN [ REVERSE ] expression .. expression LOOP
  statements
END LOOP [ label ];
</code></pre> 
                  
                  <p>El bucle FOR (variante de entero) crea un bucle que se repite a lo largo de un intervalo de valores enteros. El nombre de la variable se define automáticamente como de tipo entero y solo existe dentro del bucle. Se hace caso omiso de cualquier definición existente del nombre de la variable dentro del bucle. Las dos expresiones que indican los límites inferior y superior del intervalo se evalúan una vez cuando se entra en el bucle. Si especifica REVERSE, el valor de paso se sustrae, en lugar de sumarse después de cada iteración.</p> 
                  
                  <p>Si el límite inferior es mayor que el superior (o menor en el caso de REVERSE), el cuerpo del bucle no se ejecuta. No se genera un error.</p>
                  
                  <p>Si se adjunta una etiqueta al bucle FOR, puede hacer referencia a la variable de bucle de valor entero con un nombre cualificado, usando esa etiqueta.</p>
                  
               <p>A continuación se muestra un ejemplo.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">FOR i IN 1..10 LOOP
  -- i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop
END LOOP;

FOR i IN REVERSE 10..1 LOOP
  -- i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop
END LOOP;                
</code></pre>  

               </li><li class="listitem"><p>Bucle FOR (variante de conjunto de resultados) </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR <code class="replaceable">target</code> IN query LOOP
  statements
END LOOP [ label ];
</code></pre>
                  <p>El <code class="replaceable">destino</code> es una variable de registro o lista separada por comas de variables escalares. Se asigna sucesivamente al destino cada fila resultante de la consulta; el cuerpo del bucle se ejecuta para cada fila.</p> 
                  
                  <p>El bucle FOR (variante de conjunto de resultados) permite que un procedimiento almacenado se repita a lo largo de los resultados de una consulta y manipula esos datos en consecuencia.</p>
                  <p>A continuación se muestra un ejemplo.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE PROCEDURE cs_refresh_reports() AS $$
DECLARE
  reports RECORD;
BEGIN
  FOR reports IN SELECT * FROM cs_reports ORDER BY sort_key LOOP
    -- Now "reports" has one record from cs_reports
    EXECUTE 'TRUNCATE TABLE ' || quote_ident(reports.report_name);
    EXECUTE 'INSERT INTO ' || quote_ident(reports.report_name) || ' ' || reports.report_query;
  END LOOP;
  RETURN;
END;
$$ LANGUAGE plpgsql;                   
</code></pre>
               </li><li class="listitem"><p>Bucle FOR con SQL dinámico</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR record_or_row IN EXECUTE text_expression LOOP 
  statements
END LOOP;
</code></pre>
                  
                  <p>El bucle FOR con SQL dinámico permite a un procedimiento almacenado repetirse a lo largo de los resultados de una consulta dinámica y manipula esos datos en consecuencia.</p>  
                  
               <p>A continuación se muestra un ejemplo.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE for_loop_dynamic_sql(x int)
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  query text;
BEGIN
  query := 'SELECT * FROM tbl_dynamic_sql LIMIT ' || x;
  FOR rec IN EXECUTE query
  LOOP
    RAISE INFO 'a %', rec.a;
  END LOOP;
END;
$$;</code></pre>
               </li></ul></div>                      
            
          
            <h2 id="r_PLpgSQL-cursors">Cursores</h2>  
            
            <p>En lugar de ejecutar una consulta completa a la vez, puede establecer un cursor. Un <em>cursor </em>encapsula una consulta y después lee el resultado de la consulta una pocas filas a la vez. Una de las razones por las que se hace esto es evitar desbordar la memoria cuando el resultado contiene un gran número de filas. Otra razón es devolver una referencia a un cursor que ha creado un procedimiento almacenado, lo que permite al intermediario leer las filas. Esta estrategia ofrece una forma eficiente de devolver grandes conjuntos de filas desde los procedimientos almacenados.</p>
           
           <p>Para utilizar los cursores en un procedimiento almacenado NONATOMIC, coloque el bucle de cursor entre START TRANSACTION...COMMIT.</p>

            
            
            
            

               <p>Para establecer un cursor, primero debe declarar una variable de cursor. Todos los accesos a cursores en PL/pgSQL pasan por variables de cursor, que son siempre del tipo de datos especial <code class="code">refcursor</code>. Un tipo de datos <code class="code">refcursor</code> simplemente contiene una referencia a un cursor. </p>
      <p>Una manera de crear una variable de cursor es declararla como una variable de tipo <code class="code">refcursor</code>. También puede utilizar la siguiente sintaxis de declaración del cursor.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">name CURSOR [ ( <code class="replaceable">arguments</code> ) ] FOR <code class="replaceable">query</code> ;
</code></pre> 
                  <p>En lo anterior, la lista de <code class="replaceable">argumentos</code> (si se especifica) es una lista separada por comas de pares de <code class="replaceable">nombre tipo de datos</code> que definen los nombres que se sustituirán por valores de los parámetros de la <code class="replaceable">consulta</code>. Los valores reales que se sustituirán para estos nombres se especifican más adelante, cuando se abre el cursor.</p>
                  <p>A continuación se muestran ejemplos.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">DECLARE
  curs1 refcursor;
  curs2 CURSOR FOR SELECT * FROM tenk1;
  curs3 CURSOR (key integer) IS SELECT * FROM tenk1 WHERE unique1 = key;                     
</code></pre>
                  <p>Estas tres variables tienen el tipo de datos <code class="code">refcursor</code>, pero la primera se puede usar con cualquier consulta. En contraste, la segunda tiene una consulta totalmente especificada vinculada a ella y la última tiene una consulta parametrizada vinculada a ella. El valor <code class="code">key</code> se sustituye por un valor de parámetro de número entero cuando se abre el cursor. Se dice que la variable <code class="code">curs1</code> es <em>no vinculada</em>porque no está vinculada a ninguna consulta en particular.</p>
               
              <p>Antes de usar el cursor para recuperar filas, debe abrirse el cursor. PL/pgSQL tiene tres formas de la instrucción OPEN, dos de las cuales utilizan variables de cursor no vinculadas mientras que la tercera utiliza una variable de cursor vinculada.</p>
           <div class="itemizedlist">
              
              
              
           <ul class="itemizedlist"><li class="listitem">
                          <p>Abrir para seleccionar: la variable de cursor se abre y se le entrega la consulta específica que debe ejecutar. El cursor no puede estar abierto aun. Además, tiene que haberse declarado como un cursor no vinculado (es decir, como una variable <code class="code">refcursor</code> simple). La consulta SELECT se trata del mismo modo que otras instrucciones SELECT en PL/pgSQL. </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN cursor_name FOR SELECT ...;                     
</code></pre> 
                  <p>A continuación se muestra un ejemplo.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;    
</code></pre>
             </li><li class="listitem">
                  <p>Abrir para ejecutar: la variable de cursor se abre y se le entrega la consulta específica que debe ejecutar. El cursor no puede estar abierto aun. Además, tiene que haberse declarado como un cursor no vinculado (es decir, como una variable <code class="code">refcursor</code> simple). La consulta se especifica como una expresión de cadena del mismo modo que el comando EXECUTE. Esta estrategia proporciona flexibilidad porque la consulta puede variar de una ejecución a otra.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN cursor_name FOR EXECUTE query_string;
</code></pre>
                  <p>A continuación se muestra un ejemplo.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs1 FOR EXECUTE 'SELECT * FROM ' || quote_ident($1);</code></pre>                 
             </li><li class="listitem">
                  <p>Abrir un cursor vinculado: esta forma de OPEN se usa para abrir una variable de cursor que tenía una consulta vinculada cuando se declaró. El cursor no puede estar abierto aun. Debe aparecer una lista de expresiones de argumento si, y solo si, se había declarado que el cursor tenía argumentos. Estos valores se sustituyen en la consulta. </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN bound_cursor_name [ ( argument_values ) ];
</code></pre>

                  <p>A continuación se muestra un ejemplo.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs2;
OPEN curs3(42);
</code></pre>                            
             </li></ul></div>
                  <p>Después de abrir un cursor, puede trabajar con él usando las instrucciones descritas a continuación. Estas instrucciones no tienen que ocurrir necesariamente en el mismo procedimiento almacenado en el que inicialmente se abrió el cursor. Puede devolver un valor <code class="code">refcursor</code> de una procedimiento almacenado y dejar que el intermediario opere en el cursor. Todos los portales se cierran de forma implícita al final de la transacción. Por lo tanto, un valor <code class="code">refcursor</code> se puede utilizar para hacer referencia a un cursor abierto solo hasta el final de la transacción.</p>
           <div class="itemizedlist">
              
              
           <ul class="itemizedlist"><li class="listitem">
                  <p>FETCH recupera la siguiente fila del cursor en un destino. El destino puede ser una variable de fila, una variable de registro o una lista separada por comas de variables simples, como con SELECT INTO. Al igual que con SELECT INTO, puede comprobar la variable especial FOUND para ver si se ha obtenido una fila.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">FETCH cursor INTO target;
</code></pre> 
                  <p>A continuación se muestra un ejemplo.</p> 
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">FETCH curs1 INTO rowvar;</code></pre>               
             </li><li class="listitem">
                  <p>CLOSE cierra el portar subyacente de un cursor abierto. Puede usar esta instrucción para liberar recursos antes del final de la transacción. También puede usar esta instrucción para liberar la variable de cursor para poder abrirla de nuevo.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CLOSE cursor;
</code></pre>
                <p>A continuación se muestra un ejemplo.</p> 
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CLOSE curs1;</code></pre>               
             </li></ul></div>
             
          
            <h2 id="r_PLpgSQL-messages-errors">RAISE</h2>
           
           
           <p>Utilice la instrucción <code class="code">RAISE level</code> para comunicar mensajes y generar errores.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE level 'format' [, variable [, ...]];</code></pre>
            <p>Los niveles posibles son NOTICE, INFO, LOG, WARNING y EXCEPTION. EXCEPTION genera un error, que normalmente cancela la transacción en curso. Los demás niveles solo generan mensajes con distintos grados de prioridad. </p>
           <p>Dentro de la cadena de formato, % se sustituye por la siguiente representación de la cadena del argumento opcional. Escriba %% para emitir un % literal. Actualmente, los argumentos opcionales deben ser variables simples, no expresiones, y el formato debe ser una simple cadena literal.</p>
            <p>En el siguiente ejemplo, el valor de <code class="code">v_job_id</code> sustituye el % en la cadena.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;</code></pre>
            
           
            
           <p>Utilice la instrucción <code class="code">RAISE</code> para volver a generar la excepción detectada por un bloque de gestión de excepciones. Esta instrucción solo es válida en bloques de gestión de excepciones de procedimientos almacenados de modo NONATOMIC.</p>
           <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE;</code></pre>
          
          <h2 id="r_PLpgSQL-transaction-control">Control de la transacción</h2>
          <p>Puede trabajar con instrucciones de control de la transacción en el lenguaje PL/pgSQL que utiliza Amazon Redshift. Para más información sobre el uso de las instrucciones COMMIT, ROLLBACK y TRUNCATE en un proceso almacenado, vea <a href="./stored-procedure-transaction-management.html">Administración de transacciones</a>. </p>  
          
          <p>En los procedimientos almacenados de modo NONATOMIC, use <code class="code">START TRANSACTION</code> para iniciar un bloque de transacción.</p>
          <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">START TRANSACTION;</code></pre>
          <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>nota</h6></div><div class="awsdocs-note-text"><p>La instrucción START TRANSACTION de PL/pgSQL difiere del comando SQL START TRANSACTION en los siguientes aspectos:</p><div class="itemizedlist">
               
               
            <ul class="itemizedlist"><li class="listitem"><p>En los procedimientos almacenados, START TRANSACTION no es sinónimo de BEGIN.</p></li><li class="listitem"><p>La instrucción PL/pgSQL no admite palabras clave opcionales de nivel de aislamiento ni de permiso de acceso.</p></li></ul></div></div></div>

          
        <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Aviso" /> <strong>JavaScript está desactivado o no está disponible en su navegador.</strong></p><p>Para utilizar la documentación de AWS, debe estar habilitado JavaScript. Para obtener más información, consulte las páginas de ayuda de su navegador.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Convenciones del documento</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./c_PLpgSQL-structure.html">Estructura de PL/pgSQL</div><div id="next" class="next-link" accesskey="n" href="./materialized-view-overview.html">Creación de vistas materializadas</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">¿Le ha servido de ayuda esta página? - Sí</div><div class="content"><p>Gracias por hacernos saber que estamos haciendo un buen trabajo.</p><p>Si tiene un momento, díganos qué es lo que le ha gustado para que podamos seguir trabajando en esa línea.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Comentarios" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">¿Le ha servido de ayuda esta página? - No</div><div class="content"><p>Gracias por informarnos de que debemos trabajar en esta página. Lamentamos haberle defraudado.</p><p>Si tiene un momento, díganos cómo podemos mejorar la documentación.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Comentarios" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>