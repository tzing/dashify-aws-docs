<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="id-ID"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Didukung pernyataan PL/pgSQL - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="c_PLpgSQL-statements" /><meta name="default_state" content="c_PLpgSQL-statements" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="description" content="Bekerja dengan pernyataan PL/PgSQL yang didukung oleh Amazon Redshift." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="Panduan Pengembang Database" /><meta name="abstract" content="Buat dan kelola gudang data dengan Amazon Redshift, skala petabyte tingkat perusahaan, layanan pergudangan data yang dikelola sepenuhnya." /><meta name="guide-locale" content="id_id" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="Panduan Pengembang Database" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="Panduan Pengembang Database" /><meta id="panorama-serviceConsolePage" value="Didukung pernyataan PL/pgSQL" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Didukung pernyataan PL/pgSQL - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#c_PLpgSQL-statements" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="keywords" content="Amazon Redshift,AWSPergeseran Merah,Redshift,Spektrum Pergeseran Merah,Klaster,gudang data,pengembang,data sampel,database,pengembang basis data,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Panduan Pengembang Database",
        "item" : "https://docs.aws.amazon.com/id_id/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Membuat prosedur tersimpan di Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/id_id/redshift/latest/dg/stored-procedure-overview.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Referensi bahasa PL/pgSQL",
        "item" : "https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_pl_pgSQL_reference.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "Didukung pernyataan PL/pgSQL",
        "item" : "https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_pl_pgSQL_reference.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#c_PLpgSQL-statements" target="_blank" rel="noopener noreferrer" title="Buka PDF"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Dokumentasi</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">Panduan Pengembang Database</a></div><div id="page-toc-src"><a href="#r_PLpgSQL-assignment">Penugasan</a><a href="#r_PLpgSQL-select-into">PILIH KE</a><a href="#r_PLpgSQL-no-op">Tidak-op</a><a href="#r_PLpgSQL-dynamic-sql">SQL Dinamis</a><a href="#r_PLpgSQL-return">Kembali</a><a href="#r_PLpgSQL-conditionals-if">Kondisional: IF </a><a href="#r_PLpgSQL-conditionals-case">Conditionals: KASUS</a><a href="#r_PLpgSQL-loops">Loop</a><a href="#r_PLpgSQL-cursors">Cursors</a><a href="#r_PLpgSQL-messages-errors">MENAIKKAN</a><a href="#r_PLpgSQL-transaction-control">Kontrol Transaksi</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><awsui-alert class="awsdocs-page-banner awsui-util-mb-l"><p>Terjemahan disediakan oleh mesin penerjemah. Jika konten terjemahan yang diberikan bertentangan dengan versi bahasa Inggris aslinya, utamakan versi bahasa Inggris.</p></awsui-alert><h1 class="topictitle" id="c_PLpgSQL-statements">Didukung pernyataan PL/pgSQL</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p> pernyataan PL/PGSQL menambah perintah SQL dengan konstruksi prosedural, termasuk perulangan dan ekspresi kondisional, untuk mengontrol aliran logis. Sebagian besar perintah SQL dapat digunakan, termasuk bahasa manipulasi data (DDL) seperti COPY, dan INSERT, dan bahasa definisi data (DDL). Untuk daftar lengkap metri SQL yang lengkap, lihat<a href="./c_SQL_commands.html">Perintah SQL</a>. Selain itu, pernyataan PL/PGSQL berikut didukung oleh Amazon Redshift. </p><div class="highlights" id="inline-topiclist"><h6>Topik</h6><ul><li><a href="#r_PLpgSQL-assignment">Penugasan</a></li><li><a href="#r_PLpgSQL-select-into">PILIH KE</a></li><li><a href="#r_PLpgSQL-no-op">Tidak-op</a></li><li><a href="#r_PLpgSQL-dynamic-sql">SQL Dinamis</a></li><li><a href="#r_PLpgSQL-return">Kembali</a></li><li><a href="#r_PLpgSQL-conditionals-if">Kondisional: IF</a></li><li><a href="#r_PLpgSQL-conditionals-case">Conditionals: KASUS</a></li><li><a href="#r_PLpgSQL-loops">Loop</a></li><li><a href="#r_PLpgSQL-cursors">Cursors</a></li><li><a href="#r_PLpgSQL-messages-errors">MENAIKKAN</a></li><li><a href="#r_PLpgSQL-transaction-control">Kontrol Transaksi</a></li></ul></div>
            <h2 id="r_PLpgSQL-assignment">Penugasan</h2>  
            
            <p>Pernyataan penugasan memberikan nilai ke variabel. Ekspresi harus mengembalikan nilai tunggal.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">identifier := expression;</code></pre>
            
            <p>Menggunakan tidak standar <code class="code">=</code> untuk tugas, bukan, juga <code class="code">:=</code> diterima.</p>
            
           <p>Jika tipe data ekspresi tidak cocok dengan tipe data variabel atau variabel memiliki ukuran atau presisi, nilai hasil secara implisit dikonversi.</p>
      <p>Berikut ini menunjukkan contoh.</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">customer_number := 20;
tip := subtotal * 0.15;</code></pre>
            
          
            <h2 id="r_PLpgSQL-select-into">PILIH KE</h2> 
            
           
            <p>The SELECT INTO pernyataan memberikan hasil dari beberapa kolom (tapi hanya satu baris) ke dalam variabel record atau daftar variabel skalar.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">SELECT INTO <code class="replaceable">target</code> <code class="replaceable">select_expressions</code> FROM ...;</code></pre>  
            
            
            <p>Dalam sintaks sebelumnya, <code class="replaceable">target</code> dapat menjadi variabel record atau daftar dipisahkan koma variabel sederhana dan bidang record. Daftar <code class="replaceable">select_expressions</code> dan sisa perintah adalah sama seperti di SQL biasa.</p>
            <p>Jika daftar variabel digunakan sebagai <code class="replaceable">target</code>, nilai yang dipilih harus sama persis dengan struktur target, atau kesalahan runtime terjadi. Ketika variabel record adalah target, secara otomatis mengkonfigurasi dirinya untuk jenis baris kolom hasil query.</p>
            <p>The INTO klausa dapat muncul hampir di mana saja dalam pernyataan SELECT. Biasanya muncul setelah klausa SELECT, atau sebelum klausa FROM. Artinya, muncul tepat sebelum atau tepat setelah daftar <code class="replaceable">select_expressions</code>.</p>
            <p>Jika query mengembalikan nol baris, nilai NULL ditugaskan untuk <code class="replaceable">menargetkan</code>. Jika query mengembalikan beberapa baris, baris pertama ditugaskan untuk <code class="replaceable">menargetkan</code> dan sisanya dibuang. Kecuali pernyataan berisi ORDER BY, baris pertama tidak deterministik.</p>
            <p>Untuk menentukan apakah tugas mengembalikan setidaknya satu baris, gunakan variabel FOUND khusus.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">SELECT INTO customer_rec * FROM cust WHERE custname = lname;
IF NOT FOUND THEN
  RAISE EXCEPTION 'employee % not found', lname;
END IF;
</code></pre>
            
            <p>Untuk menguji apakah hasil record adalah null, Anda dapat menggunakan IS NULL bersyarat. Tidak ada cara untuk menentukan apakah ada baris tambahan yang mungkin telah dibuang. Contoh berikut menangani kasus di mana tidak ada baris telah dikembalikan.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE select_into_null(return_webpage OUT varchar(256))
AS $$
DECLARE
  customer_rec RECORD;
BEGIN
  SELECT INTO customer_rec * FROM users WHERE user_id=3;
  IF customer_rec.webpage IS NULL THEN
    -- user entered no webpage, return "http://"
    return_webpage = 'http://';
  END IF;
END;
$$ LANGUAGE plpgsql;         
</code></pre>
            
          
            <h2 id="r_PLpgSQL-no-op">Tidak-op</h2>  
           
            <p>Pernyataan no-op (<code class="code">NULL;</code>) adalah pernyataan placeholder yang tidak melakukan apa-apa. Pernyataan no-op dapat menunjukkan bahwa satu cabang dari rantai IF-THEN-ELSE kosong.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="">NULL;</code></pre> 
 
 
            
          
            <h2 id="r_PLpgSQL-dynamic-sql">SQL Dinamis</h2>  
            
            <p>Untuk menghasilkan perintah dinamis yang dapat melibatkan tabel yang berbeda atau tipe data yang berbeda setiap kali mereka dijalankan dari prosedur PL/pgSQL disimpan, menggunakan pernyataan. <code class="code">EXECUTE</code></p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">EXECUTE <code class="replaceable">command-string</code> [ INTO target ];</code></pre> 
            
            <p>Dalam sebelumnya, <code class="replaceable">command-string</code> adalah ekspresi menghasilkan string (tipe teks) yang berisi perintah yang akan dijalankan. Nilai <code class="replaceable">command-string</code> ini dikirim ke mesin SQL. Tidak ada substitusi variabel PL/pgSQL dilakukan pada string perintah. Nilai-nilai variabel harus dimasukkan dalam string perintah seperti yang dibangun.</p>
           
           <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>catatan</h6></div><div class="awsdocs-note-text"><p>Anda tidak dapat menggunakan COMMIT dan ROLLBACK pernyataan dari dalam SQL dinamis. Untuk informasi tentang menggunakan COMMIT dan ROLLBACK pernyataan dalam prosedur yang disimpan, lihat. <a href="./stored-procedure-transaction-management.html">Mengelola transaksi</a> </p></div></div> 
            
            <p>Ketika bekerja dengan perintah dinamis, Anda sering harus menangani melarikan diri dari tanda kutip tunggal. Sebaiknya lampirkan teks tetap dalam tanda kutip di badan fungsi Anda menggunakan kutipan dolar. Nilai dinamis untuk dimasukkan ke dalam query dibangun memerlukan penanganan khusus karena mereka sendiri mungkin mengandung tanda kutip. Contoh berikut mengasumsikan dolar mengutip untuk fungsi secara keseluruhan, sehingga tanda kutip tidak perlu dua kali lipat.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">EXECUTE 'UPDATE tbl SET '
  || quote_ident(colname)
  || ' = '
  || quote_literal(newvalue)
  || ' WHERE key = '
  || quote_literal(keyvalue);               
</code></pre>
            
            <p>Contoh sebelumnya menunjukkan fungsi <code class="code">quote_ident(text)</code> dan<code class="code">quote_literal(text)</code>. Contoh ini melewati variabel yang berisi kolom dan tabel pengidentifikasi untuk fungsi. <code class="code">quote_ident</code> Hal ini juga melewati variabel yang berisi string literal dalam perintah dibangun untuk <code class="code">quote_literal</code> fungsi. Kedua fungsi mengambil langkah-langkah yang tepat untuk mengembalikan teks masukan tertutup dalam tanda kutip ganda atau tunggal masing-masing, dengan karakter khusus tertanam benar lolos.</p>
            <p>Kutipan dolar hanya berguna untuk mengutip teks tetap. Jangan menulis contoh sebelumnya dalam format berikut.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">EXECUTE 'UPDATE tbl SET '
  || quote_ident(colname)
  || ' = $$'
  || newvalue
  || '$$ WHERE key = '
  || quote_literal(keyvalue);               
</code></pre>
            
            <p>Anda tidak melakukan ini karena contoh istirahat jika isi <code class="code">newvalue</code> terjadi mengandung $$. Masalah yang sama berlaku untuk pembatas kutipan dolar lainnya yang mungkin Anda pilih. Untuk mengutip teks dengan aman yang tidak diketahui sebelumnya, gunakan <code class="code">quote_literal</code> fungsinya.</p>
            
          
            <h2 id="r_PLpgSQL-return">Kembali</h2>   
            
            <p>Pernyataan RETURN kembali ke pemanggil dari prosedur yang disimpan.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="">RETURN;</code></pre>
            
            <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE return_example(a int)
AS $$  
BEGIN
  FOR b in 1..10 LOOP
    IF b &lt; a THEN
      RAISE INFO 'b = %', b;
    ELSE
      RETURN;
    END IF;
  END LOOP;
END;
$$ LANGUAGE plpgsql;               
</code></pre>
            
          
            <h2 id="r_PLpgSQL-conditionals-if">Kondisional: IF</h2>  
           
           
            
            <p>Pernyataan kondisional IF dapat mengambil formulir berikut dalam bahasa PL/pgSQL yang digunakan Amazon Redshift:</p>
            
            
            <div class="itemizedlist">
                
               
               
               
                  

                
            
            <ul class="itemizedlist"><li class="listitem"><p>JIKA... KEMUDIAN</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
END IF;
</code></pre>
                  
            <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF v_user_id &lt;&gt; 0 THEN
  UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;               
</code></pre>
            
            </li><li class="listitem"><p>JIKA... LALU... LAIN</p>
 <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
ELSE
  statements
END IF;
</code></pre>
                  
               <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF parentid IS NULL OR parentid = ''
THEN
  return_name = fullname;
  RETURN;
ELSE
  return_name = hp_true_filename(parentid) || '/' || fullname;
  RETURN;
END IF;           
</code></pre>
                  
               </li><li class="listitem"><p>JIKA... LALU... ELSIF... LALU... LAIN </p>
                  <p>Kata kunci ELSIF juga bisa dieja ELSEIF.</p>                  
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
[ ELSIF boolean-expression THEN
  statements
[ ELSIF boolean-expression THEN
  statements
    ...] ]
[ ELSE
  statements ]
END IF;
</code></pre>                  
               

               
               <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
               
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF number = 0 THEN
  result := 'zero';
ELSIF number &gt; 0 THEN
  result := 'positive';
ELSIF number &lt; 0 THEN
  result := 'negative';
ELSE
  -- the only other possibility is that number is null
  result := 'NULL';
END IF;                  
</code></pre>
               </li></ul></div>
            
           
            
          
            <h2 id="r_PLpgSQL-conditionals-case">Conditionals: KASUS</h2>  
           <p>Pernyataan kondisional CASE dapat mengambil formulir berikut dalam bahasa PL/pgSQL yang digunakan Amazon Redshift:</p>
            <div class="itemizedlist">
                
                 

            <ul class="itemizedlist"><li class="listitem"><p>KASUS Simple </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CASE <code class="replaceable">search-expression</code>
WHEN <code class="replaceable">expression</code> [, <code class="replaceable">expression</code> [ ... ]] THEN
  <code class="replaceable">statements</code>
[ WHEN <code class="replaceable">expression</code> [, <code class="replaceable">expression</code> [ ... ]] THEN
  <code class="replaceable">statements</code>
  ... ]
[ ELSE
  <code class="replaceable">statements</code> ]
END CASE;
</code></pre>
                  
                  <p>Sebuah pernyataan CASE sederhana menyediakan eksekusi kondisional berdasarkan kesetaraan operan.</p>
                  
                  <p>Nilai <code class="replaceable">penelusuran-ekspresi</code> dievaluasi satu kali dan berturut-turut dibandingkan dengan setiap <code class="replaceable">ekspresi</code> dalam klausa WHEN. Jika pertandingan ditemukan, maka <code class="replaceable">pernyataan</code> yang sesuai berjalan, dan kemudian kontrol lolos ke pernyataan berikutnya setelah END KASUS. Ekspresi WHEN berikutnya tidak dievaluasi. Jika tidak ada kecocokan ditemukan, <code class="replaceable">pernyataan</code> ELSE dijalankan. Namun, jika ELSE tidak ada, maka pengecualian CASE_NOT_FOUND akan dinaikkan.</p>
                  
               <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CASE x
WHEN 1, 2 THEN
  msg := 'one or two';
ELSE
  msg := 'other value than one or two';
END CASE;                  
</code></pre>
                  
               </li><li class="listitem"><p>CASE yang dicari </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CASE
WHEN <code class="replaceable">boolean-expression</code> THEN
  statements
[ WHEN <code class="replaceable">boolean-expression</code> THEN
  statements
  ... ]
[ ELSE
  statements ]
END CASE;
</code></pre>
                  
                  <p>Bentuk dicari CASE menyediakan eksekusi kondisional berdasarkan kebenaran ekspresi Boolean. </p>
                  
                  <p>Setiap <code class="replaceable">ekspresi boolean</code> klausa WHEN dievaluasi secara bergantian, sampai ditemukan bahwa menghasilkan true. Kemudian pernyataan yang sesuai berjalan, dan kemudian kontrol lolos ke pernyataan berikutnya setelah END CASE. <code class="replaceable">Ekspresi</code> WHEN berikutnya tidak dievaluasi. Jika tidak ada hasil yang benar ditemukan, <code class="replaceable">pernyataan</code> ELSE dijalankan. Namun, jika ELSE tidak ada, maka pengecualian CASE_NOT_FOUND akan dinaikkan.</p>
                  
                  <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CASE
WHEN x BETWEEN 0 AND 10 THEN
  msg := 'value is between zero and ten';
WHEN x BETWEEN 11 AND 20 THEN
  msg := 'value is between eleven and twenty';
END CASE;                                
</code></pre>
                  
               </li></ul></div>                      
            
          
            <h2 id="r_PLpgSQL-loops">Loop</h2>  
            
           <p>Pernyataan loop dapat mengambil formulir berikut dalam bahasa PL/pgSQL yang digunakan Amazon Redshift:</p>
            <div class="itemizedlist">
                
               
                 
               
                 
               
                
               
                 
               
                 
               
               
               
                                  
               
               
            <ul class="itemizedlist"><li class="listitem"><p>Lingkaran sederhana </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
LOOP
  statements
END LOOP [ label ];
</code></pre>
                  
                  <p>Sebuah loop sederhana mendefinisikan loop tanpa syarat yang diulang tanpa batas sampai diakhiri oleh EXIT atau RETURN pernyataan. Label opsional dapat digunakan oleh EXIT dan CONTINUE pernyataan dalam loop bersarang untuk menentukan loop EXIT dan CONTINUE pernyataan merujuk ke.</p>
                  
               <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE simple_loop()
LANGUAGE plpgsql
AS $$
BEGIN
  &lt;&lt;simple_while&gt;&gt;
  LOOP
    RAISE INFO 'I am raised once';  
    EXIT simple_while;
    RAISE INFO 'I am not raised';
  END LOOP;
  RAISE INFO 'I am raised once as well';
END;
$$;                
</code></pre>

               </li><li class="listitem"><p>Keluar dari loop</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">EXIT [ <code class="replaceable">label</code> ] [ WHEN <code class="replaceable">expression</code> ];
</code></pre> 
                 <p>Jika <code class="replaceable">label</code> tidak hadir, loop terdalam diakhiri dan pernyataan berikut END LOOP berjalan berikutnya. Jika <code class="replaceable">label</code> hadir, itu harus menjadi label saat ini atau beberapa tingkat luar loop bersarang atau blok. Kemudian, loop bernama atau blok diakhiri dan kontrol berlanjut dengan pernyataan setelah loop atau blok yang sesuai END.</p>
                  <p>Jika WHEN ditentukan, keluar loop terjadi hanya jika <code class="replaceable">ekspresi</code> benar. Jika tidak, kontrol lolos ke pernyataan setelah EXIT.</p>
                  <p>Anda dapat menggunakan EXIT dengan semua jenis loop; tidak terbatas untuk digunakan dengan loop tanpa syarat.</p>
                  <p>Ketika digunakan dengan BEGIN blok, EXIT melewati kontrol ke pernyataan berikutnya setelah akhir blok. Label harus digunakan untuk tujuan ini. EXIT yang tidak berlabel tidak pernah dianggap cocok dengan blok BEGIN.</p>
                  <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE simple_loop_when(x int)
LANGUAGE plpgsql
AS $$
DECLARE i INTEGER := 0;
BEGIN
  &lt;&lt;simple_loop_when&gt;&gt;
  LOOP
    RAISE INFO 'i %', i;
    i := i + 1;
    EXIT simple_loop_when WHEN (i &gt;= x);
  END LOOP;
END;
$$;                     
</code></pre>
               </li><li class="listitem"><p>Lanjutkan loop </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CONTINUE [ <code class="replaceable">label</code> ] [ WHEN <code class="replaceable">expression</code> ];
</code></pre> 
                  <p>Jika <code class="replaceable">label</code> tidak diberikan, eksekusi melompat ke iterasi berikutnya dari loop terdalam. Artinya, semua pernyataan yang tersisa dalam tubuh loop dilewati. Kontrol kemudian kembali ke ekspresi kontrol loop (jika ada) untuk menentukan apakah iterasi loop lain diperlukan. Jika <code class="replaceable">label</code> hadir, itu menentukan label loop yang eksekusi dilanjutkan.</p>
                  <p>Jika WHEN ditentukan, iterasi berikutnya dari loop dimulai hanya jika <code class="replaceable">ekspresi</code> benar. Jika tidak, kontrol lolos ke pernyataan setelah CONTINUE.</p>
                  <p>Anda dapat menggunakan CONTINUE dengan semua jenis loop; tidak terbatas untuk digunakan dengan loop tanpa syarat.</p>
                  
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CONTINUE mylabel;
</code></pre> 
                  
               </li><li class="listitem"><p>LINGKARAN SEMENTARA </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
WHILE expression LOOP
  statements
END LOOP [ label ];
</code></pre> 
                  
               <p>Pernyataan WHILE mengulangi urutan pernyataan asalkan <code class="replaceable">boolean-ekspresi mengevaluasi</code> ke true. Ekspresi diperiksa sebelum setiap entri ke tubuh loop.</p> 
               <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
  -- some computations here
END LOOP;

WHILE NOT done LOOP
  -- some computations here
END LOOP;                  
</code></pre>
               </li><li class="listitem"><p>UNTUK loop (varian integer) </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR name IN [ REVERSE ] expression .. expression LOOP
  statements
END LOOP [ label ];
</code></pre> 
                  
                  <p>FOR loop (integer varian) menciptakan loop yang iterates atas berbagai nilai integer. Nama variabel secara otomatis didefinisikan sebagai tipe integer dan hanya ada di dalam loop. Setiap definisi yang ada dari nama variabel diabaikan dalam loop. Dua ekspresi memberikan batas bawah dan atas kisaran dievaluasi satu kali ketika memasuki loop. Jika Anda menentukan REVERSE, maka nilai langkah dikurangi, daripada ditambahkan, setelah setiap iterasi.</p> 
                  
                  <p>Jika batas bawah lebih besar dari batas atas (atau kurang dari, dalam kasus REVERSE), tubuh loop tidak berjalan. Tidak ada kesalahan yang dinaikkan.</p>
                  
                  <p>Jika label melekat pada FOR loop, maka Anda dapat referensi variabel loop integer dengan nama yang memenuhi syarat, menggunakan label itu.</p>
                  
               <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">FOR i IN 1..10 LOOP
  -- i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop
END LOOP;

FOR i IN REVERSE 10..1 LOOP
  -- i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop
END LOOP;                
</code></pre>  

               </li><li class="listitem"><p>UNTUK loop (hasil set varian) </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR <code class="replaceable">target</code> IN query LOOP
  statements
END LOOP [ label ];
</code></pre>
                  <p><code class="replaceable">Target</code> adalah variabel record atau dipisahkan koma daftar variabel skalar. Target berturut-turut ditugaskan setiap baris yang dihasilkan dari query, dan tubuh loop dijalankan untuk setiap baris.</p> 
                  
                  <p>FOR loop (hasil set varian) memungkinkan prosedur yang disimpan untuk iterate melalui hasil query dan memanipulasi data yang sesuai.</p>
                  <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE PROCEDURE cs_refresh_reports() AS $$
DECLARE
  reports RECORD;
BEGIN
  FOR reports IN SELECT * FROM cs_reports ORDER BY sort_key LOOP
    -- Now "reports" has one record from cs_reports
    EXECUTE 'TRUNCATE TABLE ' || quote_ident(reports.report_name);
    EXECUTE 'INSERT INTO ' || quote_ident(reports.report_name) || ' ' || reports.report_query;
  END LOOP;
  RETURN;
END;
$$ LANGUAGE plpgsql;                   
</code></pre>
               </li><li class="listitem"><p>UNTUK loop dengan SQL dinamis</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR record_or_row IN EXECUTE text_expression LOOP 
  statements
END LOOP;
</code></pre>
                  
                  <p>Sebuah FOR loop dengan SQL dinamis memungkinkan prosedur yang disimpan untuk iterate melalui hasil query dinamis dan memanipulasi data yang sesuai.</p>  
                  
               <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE for_loop_dynamic_sql(x int)
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  query text;
BEGIN
  query := 'SELECT * FROM tbl_dynamic_sql LIMIT ' || x;
  FOR rec IN EXECUTE query
  LOOP
    RAISE INFO 'a %', rec.a;
  END LOOP;
END;
$$;</code></pre>
               </li></ul></div>                      
            
          
            <h2 id="r_PLpgSQL-cursors">Cursors</h2>  
            
            <p>Daripada menjalankan seluruh kueri sekaligus, Anda dapat mengatur kursor. Sebuah <em>kursor</em> merangkum query dan membaca hasil query beberapa baris pada suatu waktu. Salah satu alasan untuk melakukan ini adalah untuk menghindari overrun memori ketika hasilnya berisi sejumlah besar baris. Alasan lain adalah mengembalikan referensi ke kursor yang telah dibuat oleh prosedur tersimpan, yang memungkinkan pemanggil membaca baris. Pendekatan ini menyediakan cara yang efisien untuk mengembalikan set baris besar dari prosedur yang disimpan.</p>
           
           <p>Untuk menggunakan kursor dalam prosedur NONATOMIC disimpan, menempatkan loop kursor antara START TRANSACTION... COMMIT.</p>

            
            
            
            

               <p>Untuk mengatur kursor, pertama Anda mendeklarasikan variabel kursor. Semua akses ke kursor di PL/PGSQL melewati variabel kursor, yang selalu dari tipe data khusus. <code class="code">refcursor</code> Sebuah tipe <code class="code">refcursor</code> data hanya memegang referensi ke kursor. </p>
      <p>Anda dapat membuat variabel kursor dengan mendeklarasikannya sebagai variabel tipe<code class="code">refcursor</code>. Atau, Anda dapat menggunakan sintaks deklarasi kursor berikut.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">name CURSOR [ ( <code class="replaceable">arguments</code> ) ] FOR <code class="replaceable">query</code> ;
</code></pre> 
                  <p><code class="replaceable">Dalam sebelumnya, <code class="replaceable">argumen</code> (jika ditentukan) adalah daftar dipisahkan koma pasangan <code class="replaceable">nama datatype yang masing-masing mendefinisikan nama</code> yang akan diganti dengan nilai parameter dalam query.</code> Nilai aktual untuk menggantikan nama-nama ini ditentukan kemudian, ketika kursor dibuka.</p>
                  <p>Berikut ini menunjukkan contoh.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">DECLARE
  curs1 refcursor;
  curs2 CURSOR FOR SELECT * FROM tenk1;
  curs3 CURSOR (key integer) IS SELECT * FROM tenk1 WHERE unique1 = key;                     
</code></pre>
                  <p>Ketiga variabel ini memiliki tipe data<code class="code">refcursor</code>, tapi yang pertama dapat digunakan dengan query apapun. Sebaliknya, yang kedua memiliki kueri yang ditentukan sepenuhnya yang sudah terikat padanya, dan yang terakhir memiliki kueri berparameter yang terikat padanya. <code class="code">key</code>Nilai diganti dengan nilai parameter integer saat kursor dibuka. Variabel <code class="code">curs1</code> dikatakan <em>tidak terikat</em> karena tidak terikat untuk setiap query tertentu.</p>
               
              <p>Sebelum Anda dapat menggunakan kursor untuk mengambil baris, itu harus dibuka. PL/pgSQL memiliki tiga bentuk pernyataan OPEN, yang dua menggunakan variabel kursor terikat dan yang ketiga menggunakan variabel kursor terikat:</p>
           <div class="itemizedlist">
              
              
              
           <ul class="itemizedlist"><li class="listitem">
                          <p>Buka untuk pilih: Variabel kursor dibuka dan diberi permintaan yang ditentukan untuk dijalankan. Kursor belum bisa dibuka. Juga, itu harus telah dinyatakan sebagai kursor tak terikat (yaitu, sebagai <code class="code">refcursor</code> variabel sederhana). Query SELECT diperlakukan dengan cara yang sama seperti pernyataan SELECT lainnya di PL/PGSQL. </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN cursor_name FOR SELECT ...;                     
</code></pre> 
                  <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;    
</code></pre>
             </li><li class="listitem">
                  <p>Terbuka untuk mengeksekusi: Variabel kursor dibuka dan diberi permintaan yang ditentukan untuk dijalankan. Kursor belum bisa dibuka. Juga, itu harus telah dinyatakan sebagai kursor tak terikat (yaitu, sebagai <code class="code">refcursor</code> variabel sederhana). Query ditentukan sebagai ekspresi string dengan cara yang sama seperti pada perintah EXECUTE. Pendekatan ini memberikan fleksibilitas sehingga query dapat bervariasi dari satu run ke yang berikutnya.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN cursor_name FOR EXECUTE query_string;
</code></pre>
                  <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs1 FOR EXECUTE 'SELECT * FROM ' || quote_ident($1);</code></pre>                 
             </li><li class="listitem">
                  <p>Buka kursor terikat: Bentuk OPEN ini digunakan untuk membuka variabel kursor yang kueri terikat padanya saat dideklarasikan. Kursor belum bisa dibuka. Daftar ekspresi nilai argumen aktual harus muncul jika dan hanya jika kursor dideklarasikan untuk mengambil argumen. Nilai-nilai ini diganti dalam query. </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN bound_cursor_name [ ( argument_values ) ];
</code></pre>

                  <p>Bagian berikut ini menunjukkan sebuah contoh.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs2;
OPEN curs3(42);
</code></pre>                            
             </li></ul></div>
                  <p>Setelah kursor dibuka, Anda dapat bekerja dengannya dengan menggunakan pernyataan yang dijelaskan berikut. Pernyataan ini tidak harus terjadi dalam prosedur tersimpan yang sama yang membuka kursor. Anda dapat mengembalikan <code class="code">refcursor</code> nilai dari prosedur yang disimpan dan membiarkan pemanggil beroperasi pada kursor. Semua portal ditutup secara implisit pada akhir transaksi. Dengan demikian, Anda dapat menggunakan <code class="code">refcursor</code> nilai untuk referensi kursor terbuka hanya sampai akhir transaksi.</p>
           <div class="itemizedlist">
              
              
           <ul class="itemizedlist"><li class="listitem">
                  <p>FETCH mengambil baris berikutnya dari kursor ke target. Target ini dapat berupa variabel baris, variabel record, atau daftar variabel sederhana yang dipisahkan koma, sama seperti SELECT INTO. Seperti SELECT INTO, Anda dapat memeriksa variabel khusus DITEMUKAN untuk melihat apakah baris diperoleh.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">FETCH cursor INTO target;
</code></pre> 
                  <p>Bagian berikut ini menunjukkan sebuah contoh.</p> 
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">FETCH curs1 INTO rowvar;</code></pre>               
             </li><li class="listitem">
                  <p>CLOSE menutup portal yang mendasari kursor terbuka. Anda dapat menggunakan pernyataan ini untuk melepaskan sumber daya lebih awal dari akhir transaksi. Anda juga dapat menggunakan pernyataan ini untuk membebaskan variabel kursor untuk dibuka lagi.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CLOSE cursor;
</code></pre>
                <p>Bagian berikut ini menunjukkan sebuah contoh.</p> 
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CLOSE curs1;</code></pre>               
             </li></ul></div>
             
          
            <h2 id="r_PLpgSQL-messages-errors">MENAIKKAN</h2>
           
           
           <p>Gunakan <code class="code">RAISE level</code> pernyataan untuk melaporkan pesan dan meningkatkan kesalahan.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE level 'format' [, variable [, ...]];</code></pre>
            <p>Tingkat yang mungkin adalah PEMBERITAHUAN, INFO, LOG, PERINGATAN, dan PENGECUALIAN. PENGECUALIAN menimbulkan kesalahan, yang biasanya membatalkan transaksi saat ini. Tingkat lain hanya menghasilkan pesan dari tingkat prioritas yang berbeda. </p>
           <p>Di dalam format string,% digantikan oleh representasi string argumen opsional berikutnya. Tulis%% untuk memancarkan literal%. Saat ini, argumen opsional harus variabel sederhana, bukan ekspresi, dan formatnya harus berupa string literal sederhana.</p>
            <p>Dalam contoh berikut, nilai <code class="code">v_job_id</code> menggantikan% dalam string.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;</code></pre>
            
           
            
           <p>Gunakan <code class="code">RAISE</code> pernyataan untuk kembali membuang pengecualian tertangkap oleh blok penanganan pengecualian. Pernyataan ini hanya berlaku di blok penanganan pengecualian modus NONATOMIC disimpan prosedur.</p>
           <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE;</code></pre>
          
          <h2 id="r_PLpgSQL-transaction-control">Kontrol Transaksi</h2>
          <p>Anda dapat bekerja dengan pernyataan kontrol transaksi dalam bahasa PL/PgSQL yang digunakan Amazon Redshift. Untuk informasi tentang menggunakan pernyataan COMMIT, ROLLBACK, dan TRUNCATE dalam prosedur yang disimpan, lihat. <a href="./stored-procedure-transaction-management.html">Mengelola transaksi</a> </p>  
          
          <p>Dalam mode NONATOMIC disimpan prosedur, gunakan <code class="code">START TRANSACTION</code> untuk memulai blok transaksi.</p>
          <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Salinan"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">START TRANSACTION;</code></pre>
          <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>catatan</h6></div><div class="awsdocs-note-text"><p>Pernyataan PL/PGSQL MULAI TRANSAKSI berbeda dari perintah SQL MULAI TRANSAKSI dengan cara berikut:</p><div class="itemizedlist">
               
               
            <ul class="itemizedlist"><li class="listitem"><p>Dalam prosedur yang tersimpan, MULAI TRANSAKSI tidak identik dengan BEGIN.</p></li><li class="listitem"><p>Pernyataan PL/pgSQL tidak mendukung tingkat isolasi opsional dan kata kunci izin akses.</p></li></ul></div></div></div>

          
        <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Awas" /> <strong>Javascript dinonaktifkan atau tidak tersedia di browser Anda.</strong></p><p>Untuk menggunakan Dokumentasi AWS, Javascript harus diaktifkan. Lihat halaman Bantuan browser Anda untuk petunjuk.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Konvensi Dokumen</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./c_PLpgSQL-structure.html">Struktur PL/pgSQL</div><div id="next" class="next-link" accesskey="n" href="./materialized-view-overview.html">Membuat tampilan terwujud</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">Apakah halaman ini membantu Anda? - Ya</div><div class="content"><p>Terima kasih telah memberitahukan bahwa hasil pekerjaan kami sudah baik.</p><p>Jika Anda memiliki waktu luang, beri tahu kami aspek apa saja yang sudah bagus, agar kami dapat menerapkannya secara lebih luas.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Umpan Balik" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">Apakah halaman ini membantu Anda? - Tidak</div><div class="content"><p>Terima kasih telah memberi tahu kami bahwa halaman ini perlu ditingkatkan. Maaf karena telah mengecewakan Anda.</p><p>Jika Anda memiliki waktu luang, beri tahu kami bagaimana dokumentasi ini dapat ditingkatkan.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Umpan Balik" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>