<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="ko-KR"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>수동 WLM 구현 - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="cm-c-defining-query-queues" /><meta name="default_state" content="cm-c-defining-query-queues" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/cm-c-defining-query-queues.html" /><meta name="description" content="클러스터가 슈퍼 사용자 대기열 외에 최대 8개의 쿼리 대기열을 정의하도록 Amazon Redshift에서 수동 WLM 구성을 수정하여 쿼리 대기열을 정의합니다." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="데이터베이스 개발자 안내서" /><meta name="abstract" content="페타바이트 규모의 엔터프라이즈급 완전관리형 데이터 웨어하우징 서비스인 Amazon Redshift로 데이터 웨어하우스를 생성하고 관리합니다." /><meta name="guide-locale" content="ko_kr" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/cm-c-defining-query-queues.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/cm-c-defining-query-queues.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="데이터베이스 개발자 안내서" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="데이터베이스 개발자 안내서" /><meta id="panorama-serviceConsolePage" value="수동 WLM 구현" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>수동 WLM 구현 - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#cm-c-defining-query-queues" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/cm-c-defining-query-queues.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/cm-c-defining-query-queues.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/cm-c-defining-query-queues.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,cluster,데이터 웨어하우스,샘플 데이터,데이터베이스,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "데이터베이스 개발자 안내서",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "워크로드 관리 구현",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/cm-c-implementing-workload-management.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "수동 WLM 구현",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/cm-c-implementing-workload-management.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#cm-c-defining-query-queues" target="_blank" rel="noopener noreferrer" title="pdf-tooltip"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">aws-documentation</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">데이터베이스 개발자 안내서</a></div><div id="page-toc-src"><a href="#concurrency-scaling-mode">동시성 확장 모드</a><a href="#cm-c-defining-query-queues-concurrency-level">동시성 레벨</a><a href="#cm-c-defining-query-queues-user-groups">사용자 그룹</a><a href="#cm-c-defining-query-queues-query-groups">쿼리 그룹</a><a href="#wlm-wildcards">와일드카드</a><a href="#wlm-memory-percent">사용할 WLM 메모리 비율</a><a href="#wlm-timeout">WLM 제한 시간</a><a href="#wlm-query-monitoring-rules">쿼리 모니터링 규칙</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="cm-c-defining-query-queues">수동 WLM 구현</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p>수동 WLM에서는 WLM 구성을 수정하여 장시간 실행되는 쿼리와 단시간 실행되는 쿼리에 대해 별도의 대기열을 생성함으로써 시스템 성능과 사용자 경험을 관리할 수 있습니다.</p><p>사용자가 Amazon Redshift에서 쿼리를 실행할 때는 쿼리가 쿼리 대기열로 라우팅됩니다. 각 쿼리 대기열에는 다수의 쿼리 슬롯이 포함되어 있습니다. 또한 클러스터에서 사용할 수 있는 메모리가 부분적으로 할당됩니다. 이렇게 할당된 대기열의 메모리는 다시 쿼리 슬롯으로 분할됩니다. Amazon Redshift가 자동 WLM으로 쿼리 동시성을 관리하도록 할 수 있습니다. 자세한 내용은 <a href="./automatic-wlm.html">자동 WLM 구현</a> 섹션을 참조하세요.</p><p>또는 쿼리 대기열마다 WLM 속성을 구성할 수 있습니다. 이를 통해 메모리가 여러 슬롯에 할당되는 방식과 런타임 시 쿼리가 특정 대기열로 라우팅되는 방식을 지정할 수 있습니다. 장기 실행되는 쿼리를 취소하도록 WLM 속성을 구성할 수도 있습니다.</p><p>Amazon Redshift에는 다음 쿼리 대기열이 기본적으로 구성되어 있습니다.</p><div class="itemizedlist">
          
          
      <ul class="itemizedlist"><li class="listitem">
            <p> <b>수퍼유저 대기열 1개</b> </p>
            <p>수퍼유저 대기열은 수퍼유저 전용으로 예약되어 따로 구성할 수 없습니다. 시스템에 영향을 미치는 쿼리나 문제 해결이 목적인 쿼리를 실행할 때만 이 대기열을 사용합니다. 예를 들어 장시간 실행 중인 쿼리를 취소하거나 사용자에게 데이터베이스를 추가해야 할 때는 이 대기열을 사용하십시오. 일반적인 쿼리를 실행하는 데는 사용하지 마십시오. 대기열이 콘솔에는 표시되지 않지만 데이터베이스의 시스템 테이블에 5번째 대기열로 표시됩니다. 수퍼유저 대기열에서 쿼리를 실행하기 위해서는 사용자가 수퍼유저 권한으로 로그인한 후 사전 설정된 <code class="code">superuser</code> 쿼리 그룹을 사용하여 쿼리를 실행해야 합니다.</p>
         </li><li class="listitem">
            <p> <b>기본 사용자 대기열 1개</b> </p>
            <p>기본 대기열에서는 동시에 실행할 수 있는 쿼리가 처음에 5개로 구성됩니다. 수동 WLM을 사용하면 기본 대기열의 동시성, 제한 시간 및 메모리 할당 속성을 변경할 수는 있지만 사용자 그룹이나 쿼리 그룹은 지정할 수 없습니다. 기본 대기열은 WLM 구성에서 마지막 대기열이 되어야 합니다. 다른 대기열로 라우팅되지 않는 쿼리는 모두 기본 대기열에서 실행됩니다.</p>
         </li></ul></div><p>쿼리 대기열은 WLM 구성에서 정의합니다. WLM 구성은 파라미터 그룹에서 편집이 가능한 파라미터(<code class="code">wlm_json_configuration</code>)로서 클러스터 1개 이상과 연결할 수 있습니다. 자세한 내용은 <em>Amazon Redshift 관리 가이드</em>의 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/workload-mgmt-config.html">워크로드 관리 구성</a> 섹션을 참조하세요.</p><p>쿼리 대기열은 기본 WLM 구성에 추가할 수 있으며, 이때 사용자 대기열의 최대 수는 8개입니다. 각 쿼리 대기열마다 다음과 같은 속성을 구성할 수 있습니다.</p><div class="itemizedlist">
          
          
          
          
          
          
          
          
      <ul class="itemizedlist"><li class="listitem">
            <p>동시성 확장 모드 </p>
         </li><li class="listitem">
            <p>동시성 레벨 </p>
         </li><li class="listitem">
            <p>사용자 그룹 </p>
         </li><li class="listitem">
            <p>쿼리 그룹 </p>
         </li><li class="listitem">
            <p>사용할 WLM 메모리 비율</p>
         </li><li class="listitem">
            <p>WLM 제한 시간</p>
         </li><li class="listitem">
            <p>WLM 쿼리 대기열 건너뛰기</p>
         </li><li class="listitem">
            <p>쿼리 모니터링 규칙</p>
         </li></ul></div>
         <h2 id="concurrency-scaling-mode">동시성 확장 모드</h2>
         <p>동시성 크기 조정이 사용되면 동시 읽기 및 쓰기 쿼리의 증가를 처리하는 데 필요한 추가 클러스터 용량을 Amazon Redshift에서 자동으로 추가합니다. 쿼리가 기본 클러스터에서 실행되든 동시성 확장 클러스터에서 실행되든 사용자에게는 최신 데이터가 보입니다.</p>
         <p>WLM 대기열을 구성하여 동시성 확장 클러스터에 보낸 쿼리를 관리합니다. 대기열에 동시성 크기 조정을 사용하면 대기열에서 기다리는 대신 적격 쿼리가 동시성 크기 조정 확장 클러스터로 전송됩니다. 자세한 내용은 <a href="./concurrency-scaling.html">동시성 확장 작업</a> 섹션을 참조하세요.</p>
       
         <h2 id="cm-c-defining-query-queues-concurrency-level">동시성 레벨</h2>
         <p>대기열의 쿼리는 해당 대기열에 정의된 WLM 쿼리 슬롯 수 또는 <em>동시성</em> 레벨에 도달할 때까지 동시에 실행됩니다. 이후의 쿼리들은 대기열에서 대기합니다.</p>
         <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>참고</h6></div><div class="awsdocs-note-text"><p>WLM 동시 실행 수준은 한 클러스터에 만들 수 있는 동시 사용자 연결 수와 다릅니다. 자세한 내용은 <em>Amazon Redshift 관리 가이드</em>의 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/connecting-to-cluster.html">클러스터에 연결</a> 섹션을 참조하세요.</p></div></div>
         <p>자동 WLM 구성(권장)에는 동시성 수준이 <b>자동</b>으로 설정되어 있습니다. Amazon Redshift는 쿼리에 메모리를 동적으로 할당하고, 쿼리는 이후에 동시에 실행할 메모리를 결정합니다. 이는 실행 중인 쿼리와 대기열에 있는 쿼리에 모두 필요한 리소스를 기반으로 합니다. 자동 WLM은 구성할 수 없습니다. 자세한 내용은 <a href="./automatic-wlm.html">자동 WLM 구현</a> 섹션을 참조하세요.</p>
        
         <p>수동 WLM 구성에서 Amazon Redshift는 고정된 양의 메모리를 각 대기열에 정적으로 할당합니다. 큐의 메모리는 쿼리 슬롯 간에 균등하게 분할됩니다. 예를 들어, 대기열에 클러스터 메모리의 20%가 할당되고 10개의 슬롯이 있는 경우 각 쿼리에는 클러스터 메모리의 2%가 할당됩니다. 메모리 할당은 동시에 실행되는 쿼리 수에 관계없이 고정된 상태로 유지됩니다. 고정된 메모리 할당으로 인해 슬롯 수가 5일 때 메모리에서만 실행되는 쿼리는 슬롯 수가 20으로 증가될 경우 중간 결과를 디스크에 작성해야 할 수도 있습니다. 이 경우 각 쿼리의 대기열 메모리 점유율은 1/5에서 1/20로 감소합니다. 결국 디스크 I/O가 추가로 발생하여 성능이 떨어지게 됩니다.</p>
         <p>모든 사용자 정의 대기열의 최대 슬롯 수는 50입니다. 이렇게 하면 기본 대기열을 포함한 모든 대기열의 총 슬롯이 제한됩니다. 제한이 적용되지 않는 유일한 대기열은 예약된 수퍼유저 대기열입니다.</p>
      
  
         
   
         <p>기본적으로 수동 WLM 대기열의 동시성 레벨은 5입니다. 하지만 다음과 같은 경우에는 동시성 레벨을 높여 워크로드의 이점을 얻을 수도 있습니다.</p>
         <div class="itemizedlist">
             
             
         <ul class="itemizedlist"><li class="listitem">
               <p>많은 수의 작은 쿼리가 장기 실행 쿼리를 대기해야 하는 경우 슬롯 수가 많은 별도의 대기열을 생성하고 작은 쿼리를 해당 대기열에 할당합니다. 동시성 레벨이 높은 대기열은 각 쿼리 슬롯에 할당되는 메모리 크기가 작기는 하지만 쿼리 용량이 낮을수록 필요한 메모리 크기 역시 작습니다.</p>
               <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>참고</h6></div><div class="awsdocs-note-text"><p>단기 쿼리 가속화(SQA)를 활성화하면 WLM은 자동으로 장기 실행 쿼리보다 단기 쿼리를 우선적으로 처리하므로, 대부분의 워크플로우에서 단기 쿼리에 별도의 대기열이 필요 없습니다. 자세한 내용은 <a href="./wlm-short-query-acceleration.html">단기 쿼리 가속화 작업</a> 섹션을 참조하세요.</p></div></div>
            </li><li class="listitem">
               <p>단일 조각의 데이터에 각각 액세스하는 쿼리가 여러 개인 경우 이러한 쿼리를 동시에 실행하도록 별도의 WLM 대기열을 설정합니다. Amazon Redshift는 동시 쿼리를 별도의 조각에 할당하므로 여러 쿼리를 여러 조각에서 병렬로 실행할 수 있습니다. 예를 들어 분산 키를 기준으로 조건자를 사용한 단순 집계 쿼리인 경우에는 쿼리 데이터가 단일 조각에 저장됩니다.</p>
            </li></ul></div>
    
          
            <h3 id="cm-c-defining-query-queues-concurrency-level-example">수동 WLM 예제</h3>
            <p> 이 예제는 슬롯과 메모리를 할당하는 방법을 보여주는 간단한 수동 WLM 시나리오입니다. 다음과 같은 세 개의 대기열로 수동 WLM을 구현합니다.</p>
            <div class="itemizedlist">
                
                
                
            <ul class="itemizedlist"><li class="listitem"><p><em>data-ingestion 대기열</em> – 데이터 모으기를 위해 설정됩니다. 클러스터 메모리의 20%가 할당되고 5개의 슬롯이 있습니다. 이후 대기열에서 5개의 쿼리를 동시에 실행할 수 있으며 각 쿼리에는 메모리의 4% 가 할당됩니다.</p></li><li class="listitem"><p><em>data-scientist 대기열</em> – 메모리를 많이 사용하는 쿼리를 위해 설계되었습니다. 클러스터 메모리의 40%가 할당되고 5개의 슬롯이 있습니다. 이후 5개의 쿼리를 동시에 실행할 수 있으며 각 쿼리에는 메모리의 8% 가 할당됩니다.</p></li><li class="listitem"><p><em>default 대기열</em> – 조직 내 대다수 사용자를 위해 설계되었습니다. 여기에는 일반적으로 복잡하지 않은 단기 또는 중기 실행 쿼리를 사용하는 영업 및 회계 그룹이 포함됩니다. 클러스터 메모리의 40%가 할당되고 40개의 슬롯이 있습니다. 이 대기열에서는 40개의 쿼리를 동시에 실행할 수 있으며 각 쿼리에는 메모리의 1%가 할당됩니다. 대기열 전체의 제한은 50개이므로 이 대기열에 할당할 수 있는 최대 슬롯 수입니다.</p></li></ul></div>
  
          
         
         <p>자동 WLM을 실행 중이고 워크로드를 병렬로 실행하기 위해 15개가 넘는 쿼리가 필요한 경우 동시성 확장을 켜는 것이 좋습니다. 쿼리 슬롯 수가 15개를 초과하면 시스템 리소스에 대한 경합이 발생하여 단일 클러스터의 전체 처리량이 제한될 수 있기 때문입니다. 동시성 확장을 사용하면 동시성 확장 클러스터의 구성된 수까지 수백 개의 쿼리를 병렬로 실행할 수 있습니다. 동시성 확장 클러스터의 수는 <a href="./r_max_concurrency_scaling_clusters.html">max_concurrency_scaling_clusters</a>에서 제어합니다. 동시성 조정에 대한 자세한 내용은 <a href="./concurrency-scaling.html">동시성 확장 작업</a> 섹션을 참조하세요.</p>
            
             
         
         
         
         
   
         <p>자세한 내용은 <a href="./query-performance-improvement-opportunities.html"> 쿼리 성능 개선</a> 섹션을 참조하세요.</p>
       
         <h2 id="cm-c-defining-query-queues-user-groups">사용자 그룹</h2>
         
         
         <p>사용자 그룹은 사용자 그룹 이름을 지정하거나 와일드카드를 사용하여 대기열에 할당할 수 있습니다. 나열된 사용자 그룹의 멤버가 쿼리를 실행할 경우에는 해당 대기열에서 실행됩니다. 대기열에 할당할 수 있는 사용자 그룹의 수는 제한이 없습니다. 자세한 내용은 <a href="./cm-c-executing-queries.html#cm-c-executing-queries-assigning-queries-to-queues-based-on-user-groups">사용자 그룹을 기반으로 대기열에 쿼리 할당</a> 섹션을 참조하세요.</p>
       
         <h2 id="cm-c-defining-query-queues-query-groups">쿼리 그룹 </h2>
         
         
         <p>쿼리 그룹은 쿼리 그룹 이름을 지정하거나 와일드카드를 사용하여 대기열에 할당할 수 있습니다. 쿼리 그룹이란 쉽게 말해서 레이블을 의미합니다. 실행 시간에 쿼리 그룹 레이블을 일련의 쿼리에 지정할 수 있습니다. 목록에 있는 쿼리 그룹에 지정된 모든 쿼리는 해당 대기열에서 실행됩니다. 대기열에 할당할 수 있는 쿼리 그룹의 수는 제한이 없습니다. 자세한 내용은 <a href="./cm-c-executing-queries.html#cm-c-executing-queries-assigning-a-query-to-a-query-group">쿼리 그룹에 쿼리 할당</a> 섹션을 참조하세요.</p>
       
         <h2 id="wlm-wildcards">와일드카드</h2>
         
         <p>WLM 대기열 구성에서 와일드카드가 활성화되어 있으면 사용자 그룹이나 쿼리 그룹을 개별적으로, 혹은 Unix 셸 스타일 와일드카드를 사용하여 할당할 수 있습니다. 패턴 일치는 대/소문자를 구분하지 않습니다.</p>
         <p>예를 들어 '*' 와일드카드 문자는 모든 복수 문자와 일치합니다. 따라서 대기열의 사용자 그룹 목록에 <code class="code">dba_*</code>를 추가하면 이름이 <code class="code">dba_</code>로 시작되는 그룹에 속한 사용자 실행 쿼리는 모두 해당 대기열에 할당됩니다. <code class="code">dba_admin</code> 또는 <code class="code">DBA_primary</code>를 예로 들 수 있습니다. ‘?’ 와일드카드 문자는 모든 단일 문자와 일치합니다. 따라서 대기열에 <code class="code">dba?1</code>이라는 이름의 사용자 그룹이 할당되어 있으면 <code class="code">dba11</code>이나 <code class="code">dba21</code> 같은 사용자 그룹은 모두 일치하지만 <code class="code">dba12</code>는 일치하지 않습니다.</p>
         <p>와일드카드는 기본적으로 해제되어 있습니다.</p>
       
         <h2 id="wlm-memory-percent">사용할 WLM 메모리 비율</h2>
         <p>자동 WLM 구성에서 메모리 비율은 <code class="userinput">auto</code>로 설정되어 있습니다. 자세한 내용은 <a href="./automatic-wlm.html">자동 WLM 구현</a> 섹션을 참조하세요.</p>
         
         <p>수동 WLM 구성에서 쿼리에 할당할 수 있는 메모리 크기를 지정하려면 <code class="code">WLM Memory Percent to Use</code> 파라미터를 설정할 수 있습니다. 기본적으로 각 사용자 정의 대기열에는 사용자 정의 쿼리에 사용할 수 있는 메모리가 균일하게 할당됩니다. 예를 들어 사용자 정의 대기열이 4개라면 각 대기열마다 사용할 수 있는 메모리가 25%씩 할당됩니다. 수퍼유저 대기열에는 메모리가 따로 할당되며, 이를 수정할 수 없습니다. 할당 비율을 변경하려면 각 대기열마다 메모리를 총 100%까지 정수 비율로 할당하면 됩니다. 할당되지 않는 메모리는 Amazon Redshift에서 관리하며, 데이터 처리를 위해 추가 메모리를 요청하는 대기열에 임시로 할당됩니다.</p>
         <p>예를 들어 대기열을 4개 구성할 경우 20%, 30%, 15%, 15%씩 메모리를 할당할 수 있습니다. 나머지 20%가 미할당 메모리가 되며, 서비스에서 관리합니다.</p>
       
         <h2 id="wlm-timeout">WLM 제한 시간</h2>
         <p>WLM 제한 시간(<code class="code">max_execution_time</code>)은 더 이상 사용되지 않습니다. 대신 <code class="code">query_execution_time</code>을 통해 QMR(쿼리 모니터링 규칙)을 생성하여 쿼리 실행 경과 시간을 제한하십시오. 자세한 내용은 <a href="./cm-c-wlm-query-monitoring-rules.html">WLM 쿼리 모니터링 규칙</a> 섹션을 참조하세요.</p>
         
         <p>임의의 WLM 대기열에서 쿼리가 사용할 수 있는 시간 크기를 제한할 때는 각 대기열마다 WLM 제한 시간 값을 설정할 수 있습니다. 시간 제한 파라미터는 Amazon Redshift가 쿼리를 취소하거나 건너뛸 때까지 쿼리 실행을 대기하는 시간(밀리초)을 지정합니다. 제한 시간은 쿼리 실행 시간에 따라 달라지며 대기열에서 대기하는 시간은 포함되지 않습니다.</p>
         <p>WLM은 <a href="./r_CREATE_TABLE_AS.html">CREATE TABLE AS</a>(CTAS) 문과 읽기 전용 쿼리(예: SELECT 문)만 건너뛰려고 합니다. 건너뛸 수 없는 쿼리는 취소됩니다. 자세한 내용은 <a href="./wlm-queue-hopping.html">WLM 쿼리 대기열 건너뛰기</a> 섹션을 참조하세요.</p>
         <p>WLM 제한 시간은 returning 상태에 도달한 쿼리에는 적용되지 않습니다. 커서의 상태를 보려면 <a href="./r_STV_WLM_QUERY_STATE.html">STV_WLM_QUERY_STATE</a> 시스템 테이블을 참조하십시오. COPY 문과 유지 관리 작업(예: ANALYZE 및 VACUUM)에는 WLM 제한 시간이 적용되지 않습니다.</p>
         <p>WLM 제한 시간 함수는 <a href="./r_statement_timeout.html">statement_timeout</a> 구성 파라미터와 비슷합니다. <code class="code">statement_timeout</code> 구성 파라미터가 전체 클러스터에 적용되는 반면 WLM 제한 시간은 WLM 구성에 속한 단일 대기열에만 적용된다는 점이 다릅니다.</p>
         <p><a href="./r_statement_timeout.html">statement_timeout</a>도 지정하는 경우에는 statement_timeout과 WLM 제한 시간(max_execution_time) 중에서 더 낮은 값이 사용됩니다.</p>
       
         <h2 id="wlm-query-monitoring-rules">쿼리 모니터링 규칙</h2>
         

         <p>쿼리 모니터링 규칙은 WLM 대기열의 지표 기반 성능 경계를 정의하고 쿼리가 해당 경계를 벗어날 때 실행할 작업을 지정합니다. 예를 들어 단시간 실행되는 쿼리 전용 대기열일 때는 60초 이상 실행되는 쿼리를 취소하는 규칙을 생성할 수도 있습니다. 그 밖에 잘못 설계된 쿼리를 추적할 목적으로 중첩 루프가 포함된 쿼리를 기록하는 규칙을 따로 만들 수도 있습니다. 자세한 내용은 <a href="./cm-c-wlm-query-monitoring-rules.html">WLM 쿼리 모니터링 규칙</a> 섹션을 참조하세요.</p>
      <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="주의" /> <strong>javascript가 브라우저에서 비활성화되거나 사용이 불가합니다.</strong></p><p>AWS 설명서를 사용하려면 Javascript가 활성화되어야 합니다. 지침을 보려면 브라우저의 도움말 페이지를 참조하십시오.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">문서 규칙</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./query-priority.html">쿼리 우선 순위</div><div id="next" class="next-link" accesskey="n" href="./wlm-queue-hopping.html">WLM 쿼리 대기열 건너뛰기</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">이 페이지의 내용이 도움이 되었습니까? - 예</div><div class="content"><p>칭찬해 주셔서 감사합니다!</p><p>잠깐 시간을 내어 좋았던 부분을 알려 주시면 더 열심히 만들어 보겠습니다.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="feedback-tell-us" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/cm-c-defining-query-queues.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">이 페이지의 내용이 도움이 되었습니까? - 아니요</div><div class="content"><p>이 페이지에 작업이 필요하다는 점을 알려 주셔서 감사합니다. 실망시켜 드려 죄송합니다.</p><p>잠깐 시간을 내어 설명서를 향상시킬 수 있는 방법에 대해 말씀해 주십시오.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="feedback-tell-us" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/cm-c-defining-query-queues.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>