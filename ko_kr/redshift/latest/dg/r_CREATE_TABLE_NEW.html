<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="ko-KR"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE TABLE - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="r_CREATE_TABLE_NEW" /><meta name="default_state" content="r_CREATE_TABLE_NEW" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/r_CREATE_TABLE_NEW.html" /><meta name="description" content="현재 데이터베이스에서 새 테이블을 생성합니다. 테이블의 소유자는 CREATE TABLE 명령의 발행자입니다." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="데이터베이스 개발자 안내서" /><meta name="abstract" content="페타바이트 규모의 엔터프라이즈급 완전관리형 데이터 웨어하우징 서비스인 Amazon Redshift로 데이터 웨어하우스를 생성하고 관리합니다." /><meta name="guide-locale" content="ko_kr" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/r_CREATE_TABLE_NEW.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_TABLE_NEW.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="데이터베이스 개발자 안내서" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="데이터베이스 개발자 안내서" /><meta id="panorama-serviceConsolePage" value="CREATE TABLE" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>CREATE TABLE - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#r_CREATE_TABLE_NEW" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/r_CREATE_TABLE_NEW.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/r_CREATE_TABLE_NEW.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/r_CREATE_TABLE_NEW.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,cluster,데이터 웨어하우스,샘플 데이터,데이터베이스,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "데이터베이스 개발자 안내서",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "SQL 참조",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/cm_chap_SQLCommandRef.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "SQL 명령",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_SQL_commands.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "CREATE TABLE",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_SQL_commands.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#r_CREATE_TABLE_NEW" target="_blank" rel="noopener noreferrer" title="pdf-tooltip"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">aws-documentation</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">데이터베이스 개발자 안내서</a></div><div id="page-toc-src"><a href="#r_CREATE_TABLE-privileges">필수 권한</a><a href="#r_CREATE_TABLE_NEW-synopsis">명령문</a><a href="#r_CREATE_TABLE_NEW-parameters">파라미터</a><a href="#r_CREATE_TABLE_usage">사용 노트</a><a href="#r_CREATE_TABLE_usage-examples">예</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="r_CREATE_TABLE_NEW">CREATE TABLE</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p>현재 데이터베이스에서 새 테이블을 생성합니다. 열 목록을 정의합니다. 각 열에는 고유한 유형의 데이터가 들어 있습니다. 테이블의 소유자는 CREATE TABLE 명령의 발행자입니다.</p>
         <h2 id="r_CREATE_TABLE-privileges">필수 권한</h2>
         <p>CREATE TABLE에 필요한 권한은 다음과 같습니다.</p>
         <div class="itemizedlist">
             
             
         <ul class="itemizedlist"><li class="listitem"><p>수퍼유저</p></li><li class="listitem"><p>CREATE TABLE 권한이 있는 사용자</p></li></ul></div>
       
         <h2 id="r_CREATE_TABLE_NEW-synopsis">명령문</h2>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE [ [LOCAL ] <span>{</span> TEMPORARY | TEMP } ] TABLE
[ IF NOT EXISTS ] <em>table_name</em>
( <span>{</span> <em>column_name data_type</em> [<em>column_attributes</em>] [ <em>column_constraints</em> ]
  | <em>table_constraints</em>
  | LIKE <em>parent_table</em> [ <span>{</span> INCLUDING | EXCLUDING } DEFAULTS ] }
  [, ... ]  )
[ BACKUP <span>{</span> YES | NO } ]
[<em>table_attributes</em>]

where <em>column_attributes</em> are:
  [ DEFAULT <em>default_expr</em> ]
  [ IDENTITY ( <em>seed</em>, <em>step</em> ) ]
  [ GENERATED BY DEFAULT AS IDENTITY ( <em>seed</em>, <em>step</em> ) ]
  [ ENCODE <em>encoding</em> ]
  [ DISTKEY ]
  [ SORTKEY ]
  [ COLLATE CASE_SENSITIVE | COLLATE CASE_INSENSITIVE  ]

and <em>column_constraints</em> are:
  [ <span>{</span> NOT NULL | NULL } ]
  [ <span>{</span> UNIQUE  |  PRIMARY KEY } ]
  [ REFERENCES <em>reftable</em> [ ( <em>refcolumn</em> ) ] ]

and <em>table_constraints</em>  are:
  [ UNIQUE ( <em>column_name</em> [, ... ] ) ]
  [ PRIMARY KEY ( <em>column_name</em> [, ... ] )  ]
  [ FOREIGN KEY (<em>column_name</em> [, ... ] ) REFERENCES <em>reftable</em> [ ( <em>refcolumn</em> ) ]


and <em>table_attributes</em> are:
  [ DISTSTYLE <span>{</span> AUTO | EVEN | KEY | ALL } ]
  [ DISTKEY ( <em>column_name</em> ) ]
  [ [COMPOUND | INTERLEAVED ] SORTKEY (<em> column_name</em> [,...]) |  [ SORTKEY AUTO ] ]
  [ ENCODE AUTO ]
         </code></pre>
       
         <h2 id="r_CREATE_TABLE_NEW-parameters">파라미터</h2>
         <div class="variablelist">
             
             
             
             
             
             
             
            
             
            
             
             
             
             

            
             


             
             
             
             
             
             
             
             
             

            
             
             
             
             
         <dl>
               <dt><span class="term">LOCAL </span></dt>
               <dd>
                  <p>선택 사항입니다. 이 키워드는 문에서 허용되지만, Amazon Redshift에는 아무런 효과도 없습니다.</p>
               </dd>
             
               <dt><span class="term">TEMPORARY | TEMP </span></dt>
               <dd>
                  <p>현재 세션 내에서만 보이는 임시 테이블을 생성하는 키워드입니다. 이 테이블은 자신이 생성된 세션이 끝날 때 자동으로 삭제됩니다. 임시 테이블의 이름은 영구 테이블의 이름과 같을 수 있습니다. 임시 테이블은 세션별로 별개의 스키마에서 생성됩니다. (이 스키마의 이름을 지정할 수는 없습니다.) 이 임시 스키마는 검색 경로의 첫 번째 스키마가 되므로, 영구 테이블에 액세스하려고 스키마 이름으로 테이블 이름을 정규화하지 않는 한 임시 테이블이 영구 테이블보다 우선하게 됩니다. 스키마와 우선 순위에 대한 자세한 내용은 <a href="./r_search_path.html">search_path</a> 섹션을 참조하세요.</p>
                  <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>참고</h6></div><div class="awsdocs-note-text"><p>기본적으로, 데이터베이스 사용자는 PUBLIC 그룹에서 자동 멤버십으로 임시 테이블을 생성할 권한이 있습니다. 어떤 사용자에 대해 이 권한을 거부하려면 PUBLIC 그룹에서 TEMP 권한을 취소한 다음, 특정 사용자 또는 사용자 그룹에게만 TEMP 권한을 명시적으로 허용하십시오.</p></div></div>
               </dd>
             
               <dt><span class="term">IF NOT EXISTS</span></dt>
               <dd>
                  <p>지정된 테이블이 이미 존재하는 경우 오류 메시지와 함께 중지하는 대신, 명령이 아무 것도 변경하지 않고 테이블이 존재한다는 메시지를 반환함을 나타내는 절입니다. 참고로, 기존 테이블은 사용자가 생성하려고 했던 테이블과는 전혀 다를 수도 있습니다. 테이블 이름만 비교됩니다.</p>
                  <p>이 절은 스크립트 작성 시 유용하므로, CREATE TABLE이 이미 존재하는 테이블의 생성을 시도하는 경우에는 스크립트가 실패하지 않습니다.</p>
               </dd>
             
               <dt><span class="term"> <em>table_name</em> </span></dt>
               <dd>
                  <p>생성할 테이블의 이름입니다.</p>
                  <div class="awsdocs-note awsdocs-important"><div class="awsdocs-note-title"><awsui-icon name="status-warning" variant="error"></awsui-icon><h6>중요</h6></div><div class="awsdocs-note-text"><p>'#'으로 시작하는 테이블 이름을 지정하면 테이블이 임시 테이블로 생성됩니다. 다음은 그 예제입니다.</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">create table #newtable (id int);</code></pre><p>'#' 기호를 사용하여 테이블을 참조할 수도 있습니다. 예: </p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">select * from #newtable;</code></pre></div></div>
                  <p>테이블 이름의 최대 길이는 127바이트이며, 이보다 긴 이름은 127바이트까지 표시되고 나머지는 잘립니다. 최대 4바이트까지 UTF-8 멀티바이트 문자를 사용할 수 있습니다. Amazon Redshift는 사용자 정의 임시 테이블과 쿼리 처리 또는 시스템 유지 관리 중에 Amazon Redshift에서 생성한 임시 테이블을 포함하여 노드 유형별로 클러스터당 테이블 수 할당량을 적용합니다. 선택적으로, 데이터베이스 및 스키마 이름으로 테이블 이름을 정규화할 수 있습니다. 다음 예에서는 데이터베이스 이름이 <code class="code">tickit</code>이고, 스키마 이름은 <code class="code">public</code>이며, 테이블 이름은 <code class="code">test</code>입니다.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">create table tickit.public.test (c1 int);
</code></pre>
                  <p>데이터베이스 또는 스키마가 존재하지 않는 경우 테이블이 생성되지 않으며, 이 명령문은 오류를 반환합니다. 시스템 데이터베이스 <code class="code">template0</code>, <code class="code">template1</code>, <code class="code">padb_harvest</code> 또는 <code class="code">sys:internal</code>에서 테이블 또는 뷰를 생성할 수 없습니다.</p>
                  <p>스키마 이름이 주어지는 경우 새 테이블은 그 스키마에서 생성됩니다(생성자가 해당 스키마에 액세스할 수 있다고 가정). 테이블 이름은 그 스키마에 대한 고유한 이름이어야 합니다. 아무런 스키마도 지정되지 않으면 현재 데이터베이스 스키마를 사용하여 테이블이 생성됩니다. 임시 테이블을 생성할 경우, 임시 테이블이 특수한 스키마에 존재하므로 스키마 이름을 지정할 수 없습니다.</p>
                  <p>같은 이름을 가진 여러 임시 테이블이 각각 별도의 세션에서 생성되는 경우에는 각기 다른 스키마에 할당되므로, 이런 테이블은 같은 데이터베이스에 동시에 존재할 수 있습니다. 유효한 이름에 대한 자세한 내용은 <a href="./r_names.html">이름 및 식별자</a> 섹션을 참조하세요.</p>
               </dd>
             
               <dt><span class="term"> <em>column_name</em> </span></dt>
               <dd>
                  <p>새 테이블에 생성할 열의 이름입니다. 열 이름의 최대 길이는 127바이트이며, 이보다 긴 이름은 127바이트까지 표시되고 나머지는 잘립니다. 최대 4바이트까지 UTF-8 멀티바이트 문자를 사용할 수 있습니다. 단일 테이블에서 정의할 수 있는 최대 열 수는 1,600개입니다. 유효한 이름에 대한 자세한 내용은 <a href="./r_names.html">이름 및 식별자</a> 섹션을 참조하세요.</p>
                  <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>참고</h6></div><div class="awsdocs-note-text"><p>"넓은 테이블"을 생성할 경우에는 로드 및 쿼리 처리 중에 열의 목록이 중간 결과에 대한 행 너비 경계를 초과하지 않도록 주의하십시오. 자세한 내용은 <a href="#r_CREATE_TABLE_usage">사용 노트</a> 단원을 참조하십시오.</p></div></div>
               </dd>
             
               <dt><span class="term"> <em>data_type</em> </span></dt>
               <dd>
                  <p>생성되는 열의 데이터 형식입니다. CHAR 및 VARCHAR 열의 경우 최대 길이를 선언하는 대신 MAX 키워드를 사용할 수 있습니다. MAX는 최대 길이를 CHAR의 경우 4,096바이트, VARCHAR의 경우 65,535바이트로 설정합니다. GEOMETRY 객체의 최대 크기는 1,048,447바이트입니다.</p>
                  <p>Amazon Redshift에서 지원하는 데이터 형식에 대한 자세한 내용은 <a href="./c_Supported_data_types.html">데이터 타입</a> 섹션을 참조하세요.</p>
               </dd>
             
               <dt id="create-table-default"><span class="term">DEFAULT <em>default_expr</em> </span></dt>
               <dd>
                  <p>열의 기본 데이터 값을 할당하는 절입니다. <em>default_expr</em>의 데이터 형식은 열의 데이터 형식과 일치해야 합니다. DEFAULT 값은 변수가 없는 표현식이어야 합니다. 하위 쿼리, 현재 테이블에 있는 다른 열과의 상호 참조, 사용자 정의 함수는 허용되지 않습니다.</p>
                  <p><em>default_expr</em> 표현식은 열의 값을 지정하지 않는 INSERT 작업에 사용됩니다. 기본값이 지정되지 않은 경우 열의 기본값은 Null입니다.</p>
                  <p>열 목록이 정의된 COPY 작업에서 DEFAULT 값을 가진 열을 생략하는 경우 COPY 명령은 <em>default_expr</em>의 값을 삽입합니다.</p>
               </dd>
             
               <dt id="identity-clause"><span class="term">IDENTITY(<em>seed</em>, <em>step</em>) </span></dt>
               <dd>
                  <p>열이 IDENTITY 열임을 지정하는 절입니다. IDENTITY 열에는 자동 생성되는 고유한 값이 있습니다. IDENTITY 열의 데이터 형식은 INT 또는 BIGINT여야 합니다.</p>
                  <p><code class="code">INSERT</code> 또는 <code class="code">INSERT INTO
                        [tablename] VALUES()</code> 문을 사용하여 행을 추가할 때 이런 값은 <em>seed</em>로 지정되는 값으로 시작하고 <em>단계</em>로 지정되는 수만큼 증가합니다.</p>
                  <p><code class="code">INSERT INTO [tablename] SELECT *
                        FROM</code> 또는 <code class="code">COPY</code> 문을 사용하여 테이블을 로드하면 데이터가 병렬로 로드되고 노드 조각으로 배포됩니다. 자격 증명 값을 생성할 때는 자격 증명 값이 고유할 수 있도록 Amazon Redshift가 다수의 값을 건너뜁니다. 자격 증명 값은 고유하지만 순서는 소스 파일의 순서와 일치하지 않을 수 있습니다.</p>
               </dd>
             
               <dt id="identity-generated-bydefault-clause"><span class="term">GENERATED BY DEFAULT AS IDENTITY(<em>seed</em>, <em>step</em>) </span></dt>
               <dd>
                  <p>열이 기본 IDENTITY 열임을 지정하고, 사용자가 열에 고유한 값을 자동으로 할당할 수 있는 절. IDENTITY 열의 데이터 형식은 INT 또는 BIGINT여야 합니다. 값 없이 행을 추가할 때 이런 값은 <em>seed</em>로 지정되는 값으로 시작하고 <em>단계</em>로 지정되는 수만큼 증가합니다. 값이 생성되는 과정에 대한 자세한 내용은 <a href="#identity-clause">IDENTITY</a>를 참조하십시오.</p>
                  <p>또한 INSERT, UPDATE 또는 COPY 중 EXPLICIT_IDS 없이 값을 제공할 수 있습니다. Amazon Redshift는 시스템 생성 값을 사용하는 대신 해당 값을 사용하여 자격 증명 열에 삽입합니다. 이 값은 seed보다 작은 중복 값 또는 단계 값 사이의 값일 수 있습니다. Amazon Redshift는 열에서 값의 고유성을 확인하지 않습니다. 값을 입력해도 다음 시스템 생성 값에는 영향을 미치지 않습니다.</p>
                  <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>참고</h6></div><div class="awsdocs-note-text"><p>열에 고유성이 필요한 경우 중복 값을 추가하지 마십시오. 대신, seed보다 작거나 단계 값 사이의 고유한 값을 추가합니다.</p></div></div>
                  
                  <p>기본 자격 증명 열의 경우, 다음에 유의하십시오.</p>
                  <div class="itemizedlist">
                      
                      
                      
                      
                      
                  <ul class="itemizedlist"><li class="listitem">
                        <p>기본 자격 증명 열은 NOT NULL입니다. NULL을 삽입할 수 없습니다.</p>
                     </li><li class="listitem">
                        <p>생성된 값을 기본 자격 증명 열에 삽입하려면 키워드 <code class="code">DEFAULT</code>를 사용하십시오.</p>
                        <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">INSERT INTO <code class="replaceable">tablename</code> (<code class="replaceable">identity-column-name</code>) VALUES (DEFAULT);</code></pre>
                     </li><li class="listitem">
                        <p>기본 자격 증명 열의 값을 재정의해도 다음에 생성되는 값에는 영향을 미치지 않습니다.</p>
                     </li><li class="listitem">
                        <p>ALTER TABLE ADD COLUMN 문으로 기본 자격 증명 열을 추가할 수 없습니다.</p>
                     </li><li class="listitem">
                        <p>ALTER TABLE APPEND 문으로 기본 자격 증명 열을 추가할 수 있습니다.</p>
                     </li></ul></div>
               </dd>
             
               <dt id="create-table-encode"><span class="term">ENCODE <em>encoding</em> </span></dt>
               <dd>
                  <p>열에 대한 압축 인코딩입니다. ENCODE AUTO는 테이블의 기본값입니다. Amazon Redshift는 테이블의 모든 열에 대한 압축 인코딩을 자동으로 관리하지 않습니다. 테이블의 열에 압축 인코딩을 지정하면 테이블이 더 이상 ENCODE AUTO로 설정되지 않습니다. Amazon Redshift는 더 이상 테이블의 모든 열에 대한 압축 인코딩을 자동으로 관리하지 않습니다. 테이블에 대해 ENCODE AUTO 옵션을 지정하여 Amazon Redshift에서 테이블의 모든 열에 대한 압축 인코딩을 자동으로 관리하도록 할 수 있습니다.</p>
                  <p></p>


                  <p>Amazon Redshift는 다음과 같이 압축 인코딩을 지정하지 않은 열에 초기 압축 인코딩을 자동으로 할당합니다.</p>
                  <div class="itemizedlist">
                      
                      
                      
                      
                      
                  <ul class="itemizedlist"><li class="listitem">
                        <p>임시 테이블의 모든 열은 기본적으로 RAW 압축으로 할당됩니다.</p>
                     </li><li class="listitem">
                        <p>정렬 키로 정의된 열은 RAW 압축이 할당됩니다.</p>
                     </li><li class="listitem">
                        
                        <p>BOOLEAN, REAL, DOUBLE PRECISION, GEOMETRY 또는 GEOGRAPHY 데이터 유형으로 정의된 열은 RAW 압축이 할당됩니다.</p>
                     </li><li class="listitem">

                        <p>SMALLINT, INTEGER, BIGINT, DECIMAL, DATE, TIME, TIMETZ, TIMESTAMP 또는 TIMESTAMPTZ로 정의된 열에는 AZ64 압축이 할당됩니다.</p>

                     </li><li class="listitem">
                        <p>CHAR, VARCHAR 또는 VARBYTE로 정의된 열에는 LZO 압축이 할당됩니다.</p>
                     </li></ul></div>
                  <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>참고</h6></div><div class="awsdocs-note-text"><p>열을 압축하지 않으려면 RAW 인코딩을 명시적으로 지정하십시오.</p></div></div>
                  <p> 다음 모듈을 지원합니다.<a href="./c_Compression_encodings.html#compression-encoding-list">compression encodings</a></p>
                  <div class="itemizedlist">
                     
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                  <ul class="itemizedlist"><li class="listitem">
                        <p>AZ64</p>
                     </li><li class="listitem">
                        <p>BYTEDICT</p>
                     </li><li class="listitem">
                        <p>델타</p>
                     </li><li class="listitem">
                        <p>델타</p>
                     </li><li class="listitem">
                        <p>LZO</p>
                     </li><li class="listitem">
                        <p>LZO</p>
                     </li><li class="listitem">
                        <p>LZO</p>
                     </li><li class="listitem">
                        <p>LZO</p>
                     </li><li class="listitem">
                        <p>RAW(압축 없음)</p>
                     </li><li class="listitem">
                        <p>RUNLENGTH</p>
                     </li><li class="listitem">
                        <p>TEXT255</p>
                     </li><li class="listitem">
                        <p>TEXT32K</p>
                     </li><li class="listitem">
                        <p>ZSTD</p>
                     </li></ul></div>
               </dd>
             
               <dt><span class="term">DISTKEY</span></dt>
               <dd>
                  <p>해당 열이 테이블에 대한 배포 키임을 지정하는 키워드입니다. 테이블에서는 한 개의 열만 배포 키일 수 있습니다. DISTKEY 키워드를 열 이름 뒤에 사용하거나 DISTKEY (<em>column_name</em>) 구문을 사용하여 테이블 정의의 일부로 사용할 수 있습니다. 둘 중 어떤 방법을 사용하든 그 효과는 똑같습니다. 자세한 내용은 이 주제의 뒷부분에 나오는 DISTSTYLE 파라미터를 참조하십시오.</p>
                  
                  <p>배포 키 열의 데이터 형식은 BOOLEAN, REAL, DOUBLE PRECISION, SMALLINT, INTEGER, BIGINT, DECIMAL, DATE, TIME, TIMETZ, TIMESTAMP 또는 TIMESTAMPTZ, CHAR 또는 VARCHAR일 수 있습니다.</p>
               </dd>
             
               <dt><span class="term">SORTKEY</span></dt>
               <dd>
                  <p>해당 열이 테이블에 대한 정렬 키임을 지정하는 키워드입니다. 데이터가 테이블로 로드될 때 데이터는 정렬 키로 지정되는 하나 이상의 열을 기준으로 정렬됩니다. 열 이름 뒤에 SORTKEY 키워드를 사용하여 단일 열 정렬 키를 지정하거나, SORTKEY (<em>column_name</em> [, ...]) 구문을 사용하여 하나 이상의 열을 테이블의 정렬 키 열로 지정할 수 있습니다. 이 구문을 사용하면 복합 정렬 키만 생성됩니다.</p>
                  <p>테이블당 최대 400개의 SORTKEY 열을 정의할 수 있습니다.</p>
                  
                  <p>정렬 키 열의 데이터 형식은 BOOLEAN, REAL, DOUBLE PRECISION, SMALLINT, INTEGER, BIGINT, DECIMAL, DATE, TIME, TIMETZ, TIMESTAMP 또는 TIMESTAMPTZ, CHAR 또는 VARCHAR일 수 있습니다.</p>

               </dd>
             
               <dt><span class="term">COLLATE CASE_SENSITIVE | COLLATE CASE_INSENSITIVE</span></dt>
               <dd>
                  <p>열의 문자열 검색 또는 비교가 CASE_SENSITIVE인지, CASE_INSENSITIVE인지를 지정하는 절입니다. 기본값은 데이터베이스의 현재 대/소문자 구분 구성과 동일합니다.</p>

              <p>데이터베이스 데이터 정렬 정보를 찾으려면 다음 명령을 사용합니다.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">SELECT db_collation();
                     
<code class="computeroutput" copy="false">db_collation
----------------
 case_sensitive
(1 row)</code></code></pre>
                  </dd>
             
               <dt><span class="term">NOT NULL | NULL </span></dt>
               <dd>
                  <p>NOT NULL은 열이 null 값을 포함하도록 허용되지 않도록 지정합니다. 기본값인 NULL은 열이 null 값을 허용하도록 지정합니다. IDENTITY 열은 기본적으로 NOT NULL로 선언됩니다.</p>
               </dd>
             
               <dt><span class="term">UNIQUE</span></dt>
               <dd>
                  <p>해당 열이 고유한 값만 포함할 수 있음을 지정하는 키워드입니다. 고유한 테이블 제약 조건의 동작은 여러 열에 적용할 수 있는 추가적인 기능과 함께, 열 제약 조건에 대한 동작과 동일합니다. 고유한 테이블 제약 조건을 정의하려면 UNIQUE ( <em>column_name</em> [, ... ] ) 구문을 사용하십시오.</p>
                  <div class="awsdocs-note awsdocs-important"><div class="awsdocs-note-title"><awsui-icon name="status-warning" variant="error"></awsui-icon><h6>중요</h6></div><div class="awsdocs-note-text"><p>고유 제약 조건은 정보를 제공하기 위한 것으로, 시스템에서 이를 강제 적용하지는 않습니다.</p></div></div>
               </dd>
             
               <dt><span class="term">PRIMARY KEY</span></dt>
               <dd>
                  <p>해당 열이 테이블에 대한 기본 키임을 지정하는 키워드입니다. 열 정의를 사용하면 한 개의 열만 기본 키로 정의할 수 있습니다. 다중 열 기본 키로 테이블 제약 조건을 정의하려면 PRIMARY KEY ( <em>column_name</em> [, ... ] ) 구문을 사용하십시오.</p>
                  <p>열을 기본 키로 식별하면 스키마의 설계에 대한 메타데이터가 제공됩니다. 기본 키는 다른 테이블들이 이 열 집합을 행의 고유 식별자로 사용할 수 있음을 암시합니다. 테이블에 대해 한 개의 기본 키를 열 제약 조건이나 테이블 조약 조건으로 지정할 수 있습니다. 기본 키 제약 조건은 같은 테이블에 대해 정의된 고유 제약 조건에 의해 명명되는 다른 열 집합과는 상이한 열 집합을 명명해야 합니다.</p>
                  
                  <p>PRIMARY KEY 열도 NOT NULL로 정의됩니다.</p>
                  <div class="awsdocs-note awsdocs-important"><div class="awsdocs-note-title"><awsui-icon name="status-warning" variant="error"></awsui-icon><h6>중요</h6></div><div class="awsdocs-note-text"><p>기본 키 제약 조건은 정보 제공만을 목적으로 합니다. 기본 키 제약 조건은 시스템에서 강제 적용되지 않지만, 플래너는 이 제약 조건을 사용합니다.</p></div></div>
               </dd>
             
               <dt><span class="term">References <em>reftable</em> [ ( <em>refcolumn</em> ) ]</span></dt>
               <dd>
                  <p>외래 키 제약 조건을 지정하는 절로, 해당 열은 참조되는 테이블의 어떤 행에서 참조되는 열에 있는 값과 일치하는 값만 포함해야 함을 암시합니다. 참조되는 열은 참조되는 테이블에서 고유 키 또는 기본 키 제약 조건의 열이어야 합니다.</p>
                  <div class="awsdocs-note awsdocs-important"><div class="awsdocs-note-title"><awsui-icon name="status-warning" variant="error"></awsui-icon><h6>중요</h6></div><div class="awsdocs-note-text"><p> 외래 키 제약 조건은 정보 제공만을 목적으로 합니다. 기본 키 제약 조건은 시스템에서 강제 적용되지 않지만, 플래너는 이 제약 조건을 사용합니다.</p></div></div>
               </dd>
             
               <dt id="create-table-like"><span class="term">LIKE <em>parent_table</em> [ <span>{</span> INCLUDING | EXCLUDING } DEFAULTS ] </span></dt>
               <dd>
                  <p>새 테이블이 열 이름, 데이터 형식 및 NOT NULL 제약 조건을 자동으로 복사하는 기존 원본 테이블을 지정하는 절입니다. 새 테이블과 상위 테이블이 분리되고, 상위 테이블에 대한 변경 사항이 새 테이블에 적용되지 않습니다. 복사된 열 정의에 대한 기본 표현식은 INCLUDING DEFAULTS가 지정된 경우에만 복사됩니다. 기본 표현식을 제외하는 것이 기본 동작이므로, 새 테이블의 모든 열에 null 기본값이 있습니다.</p>
                  <p>LIKE 옵션으로 생성되는 테이블은 기본 키 및 외래 키 제약 조건을 상속하지 않습니다. 배포 스타일, 정렬 키, BACKUP 및 NULL 속성은 LIKE 테이블에 상속되지만 CREATE TABLE ...에서 명시적으로 설정할 수 없습니다. LIKE 문에서 이런 속성을 명시적으로 설정할 수 없습니다.</p>
               </dd>
             
               <dt id="create-table-backup"><span class="term">BACKUP <span>{</span> YES | NO } </span></dt>
               <dd>
                  <p>자동 및 수동 클러스터 스냅샷에 테이블을 포함해야 할지 여부를 지정하는 절입니다. 중요한 데이터를 포함하지 않는 스테이징 테이블과 같은 테이블의 경우 BACKUP NO를 지정하여 스냅샷을 생성하고 스냅샷으로부터 복원할 때의 처리 시간을 절약하고 Amazon Simple Storage Service의 스토리지 공간을 줄입니다. BACKUP NO 설정은 클러스터 내에 있는 다른 노드로의 데이터 자동 복제에 아무런 영향도 미치지 않으므로 노드 장애 시 BACKUP NO가 지정된 테이블이 복원됩니다. 기본값은 BACKUP YES입니다.</p>
               </dd>
             
               <dt><span class="term">DISTSTYLE <span>{</span> AUTO | EVEN | KEY | ALL }</span></dt>
               <dd>
                  <p>전체 테이블의 데이터 배포 스타일을 정의하는 키워드입니다. Amazon Redshift는 테이블에 대해 지정된 배포 스타일에 따라 컴퓨팅 노드에 테이블의 행을 배포합니다. 기본값은 AUTO입니다.</p>
                  <p>테이블에 대해 선택하는 분산 스타일이 데이터베이스의 전체 성능에 영향을 미칩니다. 자세한 내용은 <a href="./t_Distributing_data.html">데이터 배포 스타일 작업</a> 단원을 참조하십시오. 가능한 분산 스타일은 다음과 같습니다.</p>
                  <div class="itemizedlist">
                     
                      
                      
                      
                      
                  <ul class="itemizedlist"><li class="listitem">


                        

                        
                        <p>AUTO: Amazon Redshift에서 테이블 데이터를 기반으로 최적의 배포 스타일을 할당합니다. 예를 들어 AUTO 배포 스타일을 지정하면 Amazon Redshift는 처음에 작은 테이블에 ALL 배포 스타일을 할당합니다. 테이블이 커지면 Amazon Redshift는 배포 스타일을 KEY로 변경하여 기본 키(또는 복합 기본 키의 열)를 DISTKEY로 선택할 수 있습니다. 테이블이 커지고 DISTKEY로 적합한 열이 없으면 Amazon Redshift는 배포 스타일을 EVEN으로 변경합니다. 배포 스타일 변경은 사용자 쿼리에 미치는 영향을 최소화하면서 백그라운드에서 이루어집니다.</p>

                           <p>테이블에 적용된 분산 스타일을 보려면 PG_CLASS 시스템 카탈로그 테이블을 쿼리합니다. 자세한 내용은 <a href="./viewing-distribution-styles.html">분산 스타일 보기</a> 단원을 참조하십시오.</p>

                     </li><li class="listitem">
                        <p>EVEN: 테이블의 데이터가 클러스터의 노드들에 걸쳐 라운드 로빈 배포 방식으로 균등하게 분포됩니다. 행 ID는 배포의 결정에 사용되며, 대략적으로 같은 수의 행이 각 노드로 배포됩니다.</p>
                     </li><li class="listitem">
                        <p>KEY: 데이터가 DISTKEY 열에 있는 값을 기준으로 배포됩니다. 조인 테이블의 조인 열을 배포 키로 설정하면 두 테이블 모두의 조인 행이 컴퓨팅 노드에 배치됩니다. 데이터가 배치되면 최적화 프로그램이 조인을 더 효율적으로 수행할 수 있습니다. DISTSTYLE KEY를 지정하는 경우 테이블에 대해, 또는 열 정의의 일부로서 DISTKEY 열의 이름을 지정해야 합니다. 자세한 내용은 이 주제의 앞부분에 나오는 DISTKEY 파라미터를 참조하십시오.</p>
                     </li><li class="listitem">
                        <p> ALL: 전체 테이블의 복사본이 모든 노드로 배포됩니다. 이 분산 스타일은 임의의 조인에 필요한 모든 행을 모든 노드에서 사용할 수 있도록 보장하지만, 스토리지 요구량이 몇 배로 늘고 테이블의 로드 시간과 유지 관리 시간도 증가합니다. ALL 배포는 KEY 배포가 적절하지 않은 특정 차원 테이블과 함께 사용할 때 실행 시간을 개선할 수 있지만, 성능 개선 정도를 유지 관리 비용과 비교 검토해야 합니다.</p>
                     </li></ul></div>
               </dd>
             
               <dt><span class="term">DISTKEY ( <em>column_name</em> )</span></dt>
               <dd>
                  <p>해당 열을 테이블에 대한 배포 키로 사용해야 함을 지정하는 제약 조건입니다. DISTKEY 키워드를 열 이름 뒤에 사용하거나 DISTKEY (<em>column_name</em>) 구문을 사용하여 테이블 정의의 일부로 사용할 수 있습니다. 둘 중 어떤 방법을 사용하든 그 효과는 똑같습니다. 자세한 내용은 이 주제의 앞부분에 나오는 DISTSTYLE 파라미터를 참조하십시오.</p>
               </dd>
             
               
               <dt><span class="term">[COMPOUND | INTERLEAVED ] SORTKEY (<em> column_name</em> [,...]) | [ SORTKEY AUTO ]</span></dt>


               <dd>
                  
                  
                  <p>테이블에 대해 하나 이상의 정렬 키를 지정합니다. 데이터가 테이블로 로드될 때 데이터는 정렬 키로 지정되는 열을 기준으로 정렬됩니다. 열 이름 뒤에 SORTKEY 키워드를 사용하여 단일 열 정렬 키를 지정하거나, <code class="code">SORTKEY (column_name [ , ... ] )</code> 구문을 사용하여 하나 이상의 열을 테이블의 정렬 키 열로 지정할 수 있습니다.</p>
                  <p>COMPOUND 또는 INTERLEAVED 정렬 스타일을 선택적으로 지정할 수 있습니다. 열과 함께 SORTKEY를 지정하는 경우 기본값은 COMPOUND입니다. 자세한 내용은 <a href="./t_Sorting_data.html">정렬 키 작업</a> 단원을 참조하십시오.</p>
                  <p>정렬 키 옵션을 지정하지 않는 경우 기본값은 AUTO입니다.</p>
                  <p>테이블당 최대 400개의 COMPOUND SORTKEY 열 또는 8개의 INTERLEAVED SORTKEY 열을 정의할 수 있습니다.</p>

                  <div class="variablelist">
                     
                      

                      
                      
                  <dl>
                        <dt><span class="term">AUTO</span></dt>
                        <dd>
                           <p>Amazon Redshift에서 테이블 데이터를 기반으로 최적의 정렬 키를 할당하도록 지정합니다. 예를 들어 AUTO 정렬 키가 지정된 경우 Amazon Redshift는 처음에 테이블에 정렬 키를 할당하지 않습니다. 정렬 키가 쿼리 성능을 향상시킬 것이라고 판단되면 Amazon Redshift는 테이블의 정렬 키를 변경할 수 있습니다. 테이블의 실제 정렬은 자동 테이블 정렬에 의해 수행됩니다. 자세한 내용은 <a href="./t_Reclaiming_storage_space202.html#automatic-table-sort">자동 테이블 정렬</a> 단원을 참조하십시오.</p>

                           <p>Amazon Redshift는 기존 정렬 또는 배포 키가 있는 테이블을 수정하지 않습니다. 한 가지 예외를 제외하고 테이블에 JOIN에서 사용된 적이 없는 배포 키가 있는 경우 Amazon Redshift에서 더 나은 키가 있다고 판단하면 키가 변경될 수 있습니다.</p>

                           <p>테이블의 정렬 키를 보려면 SVV_TABLE_INFO 시스템 카탈로그 뷰를 쿼리합니다. 자세한 내용은 <a href="./r_SVV_TABLE_INFO.html">SVV_TABLE_INFO</a> 단원을 참조하십시오. 테이블에 대한 Amazon Redshift Advisor 권장 사항을 보려면 SVV_ALTER_TABLE_RECOMMENDATIONS 시스템 카탈로그 뷰를 쿼리합니다. 자세한 내용은 <a href="./r_SVV_ALTER_TABLE_RECOMMENDATIONS.html">SVV_ALTER_TABLE_RECOMMENDATIONS</a> 단원을 참조하십시오. Amazon Redshift에서 수행한 작업을 보려면 SVL_AUTO_WORKER_ACTION 시스템 카탈로그 뷰를 쿼리합니다. 자세한 내용은 <a href="./r_SVL_AUTO_WORKER_ACTION.html">SVL_AUTO_WORKER_ACTION</a> 단원을 참조하십시오.</p>

                        </dd>
                      
                        <dt><span class="term">COMPOUND</span></dt>
                        <dd>
                           <p>목록에 표시되는 모든 열로 구성된 복합 키를 사용하여 데이터가 나열되는 순서대로 정렬됨을 지정합니다. 복합 정렬 키는 쿼리가 정렬 열의 순서에 따라 행을 스캔할 때 가장 유용합니다. 쿼리가 보조 정렬 열에 의존할 때는 복합 키로 정렬함으로써 얻는 성능상의 이점이 감소합니다. 테이블당 최대 400개의 COMPOUND SORTKEY 열을 정의할 수 있습니다.</p>
                        </dd>
                      
                        <dt><span class="term">INTERLEAVED</span></dt>
                        <dd>
                           <p>데이터가 인터리브 정렬 키를 사용하여 정렬됨을 지정합니다. 인터리브 정렬 키에 대해 최대 8개의 열을 지정할 수 있습니다.</p>
                           <p>인터리브 정렬에서는 정렬 키에서 각 열이나 열의 하위 집합에 똑같은 가중치를 부여하므로, 쿼리가 정렬 키에 있는 열의 순서에 종속되지 않습니다. 쿼리가 하나 이상의 보조 정렬 열을 사용하는 경우 인터리브 정렬은 쿼리 성능을 크게 높여줍니다. 인터리브 정렬에는 데이터 로드와 vacuum 작업에 약간의 오버헤드 비용이 수반됩니다.</p>
                           <div class="awsdocs-note awsdocs-important"><div class="awsdocs-note-title"><awsui-icon name="status-warning" variant="error"></awsui-icon><h6>중요</h6></div><div class="awsdocs-note-text"><p>자격 증명 열, 날짜, 타임스탬프처럼 단순 증가하는 속성이 있는 열에 인터리브 정렬 키를 쓰지 마십시오.</p></div></div>
                        </dd>
                     </dl></div>
               </dd>
             
               <dt><span class="term">ENCODE AUTO </span></dt>
               <dd><p>Amazon Redshift에서 테이블의 모든 열에 대한 인코딩 형식을 자동으로 조정하여 쿼리 성능을 최적화할 수 있도록 합니다. ENCODE AUTO는 테이블 생성 시 지정한 초기 인코딩 형식을 유지합니다. 그런 다음 새 인코딩 형식이 쿼리 성능을 향상시킬 수 있다고 판단되면 Amazon Redshift가 테이블 열의 인코딩 형식을 변경할 수 있습니다. 테이블의 열에 인코딩 형식을 지정하지 않으면 ENCODE AUTO가 기본값입니다.</p>

               </dd>
             
               <dt><span class="term">UNIQUE ( <em>column_name</em> [,...] )</span></dt>
               <dd>
                  <p>테이블에서 하나 이상의 열로 구성된 그룹은 고유한 값만 포함할 수 있음을 지정하는 제약 조건입니다. 고유한 테이블 제약 조건의 동작은 여러 열에 적용할 수 있는 추가적인 기능과 함께, 열 제약 조건에 대한 동작과 동일합니다. 고유한 제약 조건이라는 맥락에서, null 값은 같은 값으로 간주되지 않습니다. 각각의 고유 테이블 제약 조건은 테이블에 대해 정의된 다른 고유 제약 조건이나 기본 키 제약 조건에 의해 명명되는 열의 집합과는 상이한 열 집합을 명명해야 합니다.</p>
                  <div class="awsdocs-note awsdocs-important"><div class="awsdocs-note-title"><awsui-icon name="status-warning" variant="error"></awsui-icon><h6>중요</h6></div><div class="awsdocs-note-text"><p> 고유 제약 조건은 정보를 제공하기 위한 것으로, 시스템에서 이를 강제 적용하지는 않습니다.</p></div></div>
               </dd>
             
               <dt><span class="term">PRIMARY KEY ( <em>column_name</em> [,...] )</span></dt>
               <dd>
                  <p>테이블의 한 열 또는 여러 개의 열이 null이 아닌 고유한(중복되지 않는) 값만 포함할 수 있음을 지정하는 제약 조건입니다. 열 집합을 기본 키로 식별하면 스키마의 설계에 대한 메타데이터도 제공됩니다. 기본 키는 다른 테이블들이 이 열 집합을 행의 고유 식별자로 사용할 수 있음을 암시합니다. 테이블에 대해 한 개의 기본 키를 단일 열 제약 조건이나 테이블 조약 조건으로 지정할 수 있습니다. 기본 키 제약 조건은 같은 테이블에 대해 정의된 고유 제약 조건에 의해 명명되는 다른 열 집합과는 상이한 열 집합을 명명해야 합니다.</p>
                  <div class="awsdocs-note awsdocs-important"><div class="awsdocs-note-title"><awsui-icon name="status-warning" variant="error"></awsui-icon><h6>중요</h6></div><div class="awsdocs-note-text"><p> 기본 키 제약 조건은 정보 제공만을 목적으로 합니다. 기본 키 제약 조건은 시스템에서 강제 적용되지 않지만, 플래너는 이 제약 조건을 사용합니다.</p></div></div>
               </dd>
             
               <dt><span class="term">FOREIGN KEY ( <em>column_name</em> [, ... ] ) REFERENCES <em>reftable</em> [ ( <em>refcolumn</em> ) ] </span></dt>
               <dd>
                  <p>외래 키 제약 조건을 지정하는 제약 조건으로, 새 테이블에서 하나 이상의 열로 구성된 그룹이 참조되는 테이블의 어떤 행에서 참조되는 열에 있는 값과 일치하는 값만 포함해야 하도록 요구합니다. <em>refcolumn</em>이 생략된 경우에는 <em>reftable</em>의 기본 키가 사용됩니다. 참조되는 열은 참조되는 테이블에서 고유 키 또는 기본 키 제약 조건의 열이어야 합니다.</p>
                  <div class="awsdocs-note awsdocs-important"><div class="awsdocs-note-title"><awsui-icon name="status-warning" variant="error"></awsui-icon><h6>중요</h6></div><div class="awsdocs-note-text"><p>외래 키 제약 조건은 정보 제공만을 목적으로 합니다. 기본 키 제약 조건은 시스템에서 강제 적용되지 않지만, 플래너는 이 제약 조건을 사용합니다.</p></div></div>
               </dd>
            </dl></div>
       
         <h2 id="r_CREATE_TABLE_usage">사용 노트</h2>
         
         <p>고유성, 프라이머리 키 및 외래 키 제약 조건은 참고용일 뿐 표를 채울 때 <em>Amazon Redshift에 적용되지는 않습니다</em>. 예를 들어 종속성이 있는 테이블에 데이터를 삽입하면 제약 조건을 위반하더라도 삽입이 성공할 수 있습니다. 그래도 기본 키와 외래 키는 계획 힌트로 사용되며, ETL 프로세스 또는 애플리케이션의 다른 프로세스가 무결성을 적용하는 경우에는 선언되어야 합니다. 종속성이 있는 테이블을 삭제하는 방법에 대한 내용은 <a href="./r_DROP_TABLE.html">DROP TABLE</a> 섹션을 참조하세요.</p>
         
          
            <h3 id="r_CREATE_TABLE_usage-limits">제한 및 할당량</h3>
            <p>테이블을 생성할 경우 다음 제한 사항을 고려하십시오.</p>
            <div class="itemizedlist">
               
                
                
                
                
               
            <ul class="itemizedlist"><li class="listitem">
                  <p>노드 유형별로 클러스터의 최대 테이블 수가 제한되어 있습니다. 자세한 내용은 <em>Amazon Redshift 관리 가이드</em>의 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">제한</a> 섹션을 참조하세요.</p>
               </li><li class="listitem">
                  <p>테이블 이름으로 입력할 수 있는 최대 문자 수는 127자입니다.</p>
               </li><li class="listitem">
                  <p>단일 테이블에서 정의할 수 있는 최대 열 수는 1,600개입니다.</p>
               </li><li class="listitem">
                  <p>단일 테이블에서 정의할 수 있는 최대 SORTKEY 열 수는 400개입니다.</p>
               </li></ul></div>
          
          
            <h3 id="r_CREATE_TABLE_usage-summary_of_settings">열 수준 설정 및 테이블 수준 설정의 요약</h3>
            <p> 여러 속성과 설정은 열 수준 또는 테이블 수준에서 설정될 수 있습니다. 어떤 경우에는 열 수준 또는 테이블 수준에서 속성이나 제약 조건을 설정하는 효과가 동일합니다. 다른 경우에는 다른 결과를 낳습니다.</p>
            <p> 다음 목록에 열 수준 설정 및 테이블 수준 설정이 요약되어 있습니다.</p>
            <div class="variablelist">
                
                
               
                
                
                
                
            <dl>
                  <dt><span class="term">DISTKEY</span></dt>
                  <dd>
                     <p>열 수준이나 테이블 수준 중 어떤 수준에서 설정되든 실제로는 차이가 없습니다.</p>
                     <p>DISTKEY가 설정된 경우 열 수준 또는 테이블 수준 중 하나에서 DISTSTYLE이 KEY로 설정되거나 전혀 설정되지 않아야 합니다. DISTSTYLE은 테이블 수준에서만 설정될 수 있습니다.</p>
                  </dd>
                
                  <dt><span class="term">SORTKEY</span></dt>
                  <dd>
                     <p>열 수준에서 설정되는 경우 SORTKEY는 단일 열이어야 합니다. SORTKEY가 테이블 수준에서 설정된 경우 하나 이상의 열이 복합 또는 인터리브 합성 정렬 키를 구성할 수 있습니다.</p>
                  </dd>
                
                  <dt><span class="term">COLLATE CASE_SENSITIVE | COLLATE CASE_INSENSITIVE</span></dt>
                  <dd><p>Amazon Redshift는 열에 대한 대/소문자 구분 구성 변경을 지원하지 않습니다. 테이블에 새 열을 추가하면 Amazon Redshift는 대/소문자 구분에 기본값을 사용합니다. Amazon Redshift는 새 열을 추가할 때 COLLATE 키워드를 지원하지 않습니다.</p>
                     <p>데이터베이스 데이터 정렬을 사용하여 데이터베이스를 생성하는 방법에 대한 자세한 내용은 <a href="./r_CREATE_DATABASE.html">데이터베이스 생성</a> 섹션을 참조하세요.</p>
                     <p>COLLATE 함수에 대한 자세한 내용은 <a href="./r_COLLATE.html">COLLATE 함수</a> 섹션을 참조하세요.</p>
                  </dd>
                  
                
                  <dt><span class="term">UNIQUE</span></dt>
                  <dd>
                     <p>열 수준에서는 하나 이상의 키가 UNIQUE로 설정될 수 있고, UNIQUE 제약 조건이 각각의 열에 개별적으로 적용됩니다. UNIQUE가 테이블 수준에서 설정된 경우 하나 이상의 열이 복합 UNIQUE 제약 조건을 구성할 수 있습니다.</p>
                  </dd>
                
                  <dt><span class="term">PRIMARY KEY</span></dt>
                  <dd>
                     <p>열 수준에서 설정되는 경우 PRIMARY KEY는 단일 열이어야 합니다. PRIMARY KEY가 테이블 수준에서 설정된 경우 하나 이상의 열이 복합 기본 키를 구성할 수 있습니다.</p>
                  </dd>
                
                  <dt><span class="term">FOREIGN KEY</span></dt>
                  <dd>
                     <p>FOREIGN KEY가 열 수준이나 테이블 수준 중 어떤 수준에서 설정되든 실제로는 차이가 없습니다. 열 수준에서, 구문은 간단히 <code class="code">REFERENCES</code> <em>reftable</em> [ ( <em>refcolumn</em> )]입니다.</p>
                  </dd>
               </dl></div>
          
          
            <h3 id="r_CREATE_TABLE_usage-distribution-of-incoming-data">수신 데이터의 배포</h3>
            <p>수신 데이터의 해시 배포 구성표가 대상 테이블의 해시 배포 구성표와 일치하는 경우, 데이터 로드 시 데이터를 물리적으로 배포할 필요는 실제로 없습니다. 예를 들어, 새 테이블에 대해 배포 키가 설정되고 같은 키 열에 배포된 다른 테이블에서 데이터가 삽입되고 있는 경우, 같은 노드와 조각을 사용하여 데이터가 적절히 로드됩니다. 하지만 원본 테이블과 대상 테이블이 모두 EVEN 배포로 설정되어 있는 경우 데이터는 대상 테이블로 다시 배포됩니다.</p>
          
          
            <h3 id="r_CREATE_TABLE_usage-wide-tables">넓은 테이블</h3>
            <p>폭이 매우 넓은 테이블을 만들 수는 있겠지만 그런 테이블에서는 INSERT 또는 SELECT 문과 같은 쿼리 처리를 수행하지 못할 수도 있습니다. CHAR과 같이 열 너비가 고정된 테이블의 최대 너비는 64KB - 1(또는 65535바이트)입니다. 테이블에 VARCHAR 열이 포함되어 있는 경우, VARCHARS 열이 선언된 전체 너비를 계산된 쿼리 처리 제한에 산입하지 않기 때문에 테이블은 오류를 반환하지 않고 더 큰 값으로 선언된 너비를 가질 수 있습니다. VARCHAR 열을 포함한 유효 쿼리 처리 제한은 요소의 수에 따라 달라집니다.</p>
            <p>테이블이 너무 넓어 삽입 또는 선택 작업을 수행할 수 없는 경우 다음 오류가 발생합니다.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">ERROR:  8001
DETAIL:  The combined length of columns processed in the SQL statement
exceeded the query-processing limit of 65535 characters (pid:7627)</code></pre>
            
          
         
         
         
         
       
         <h2 id="r_CREATE_TABLE_usage-examples">예</h2>
         <p>CREATE TABLE 명령을 사용하는 방법을 보여주는 예제는 <a href="./r_CREATE_TABLE_examples.html">예</a> 주제를 참조하세요.</p>
      <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="주의" /> <strong>javascript가 브라우저에서 비활성화되거나 사용이 불가합니다.</strong></p><p>AWS 설명서를 사용하려면 Javascript가 활성화되어야 합니다. 지침을 보려면 브라우저의 도움말 페이지를 참조하십시오.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">문서 규칙</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./r_CREATE_SCHEMA.html">CREATE SCHEMA</div><div id="next" class="next-link" accesskey="n" href="./r_CREATE_TABLE_examples.html">예</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">이 페이지의 내용이 도움이 되었습니까? - 예</div><div class="content"><p>칭찬해 주셔서 감사합니다!</p><p>잠깐 시간을 내어 좋았던 부분을 알려 주시면 더 열심히 만들어 보겠습니다.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="feedback-tell-us" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/r_CREATE_TABLE_NEW.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">이 페이지의 내용이 도움이 되었습니까? - 아니요</div><div class="content"><p>이 페이지에 작업이 필요하다는 점을 알려 주셔서 감사합니다. 실망시켜 드려 죄송합니다.</p><p>잠깐 시간을 내어 설명서를 향상시킬 수 있는 방법에 대해 말씀해 주십시오.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="feedback-tell-us" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/r_CREATE_TABLE_NEW.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>