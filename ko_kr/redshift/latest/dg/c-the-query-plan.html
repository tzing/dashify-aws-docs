<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="ko-KR"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>쿼리 계획 - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="c-the-query-plan" /><meta name="default_state" content="c-the-query-plan" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-the-query-plan.html" /><meta name="description" content="쿼리 계획을 해석하는 방법에 대해서 설명합니다." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="데이터베이스 개발자 안내서" /><meta name="abstract" content="페타바이트 규모의 엔터프라이즈급 완전관리형 데이터 웨어하우징 서비스인 Amazon Redshift로 데이터 웨어하우스를 생성하고 관리합니다." /><meta name="guide-locale" content="ko_kr" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-the-query-plan.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c-the-query-plan.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c-the-query-plan.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c-the-query-plan.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c-the-query-plan.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c-the-query-plan.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c-the-query-plan.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c-the-query-plan.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c-the-query-plan.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-the-query-plan.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-the-query-plan.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c-the-query-plan.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c-the-query-plan.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c-the-query-plan.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c-the-query-plan.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-the-query-plan.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-the-query-plan.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c-the-query-plan.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c-the-query-plan.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/c-the-query-plan.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/c-the-query-plan.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c-the-query-plan.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="데이터베이스 개발자 안내서" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="데이터베이스 개발자 안내서" /><meta id="panorama-serviceConsolePage" value="쿼리 계획" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>쿼리 계획 - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#c-the-query-plan" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-the-query-plan.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-the-query-plan.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-the-query-plan.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,cluster,데이터 웨어하우스,샘플 데이터,데이터베이스,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "데이터베이스 개발자 안내서",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "쿼리 성능 튜닝",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-optimizing-query-performance.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "쿼리 처리",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-query-processing.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "쿼리 계획",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-query-processing.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#c-the-query-plan" target="_blank" rel="noopener noreferrer" title="pdf-tooltip"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">aws-documentation</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">데이터베이스 개발자 안내서</a></div><div id="page-toc-src"><a href="#EXPLAIN-operators">EXPLAIN 연산자</a><a href="#joins-in-EXPLAIN">EXPLAIN의 조인 유형</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="c-the-query-plan">쿼리 계획</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p>쿼리 계획은 쿼리를 실행하는 데 필요한 개별 작업에 대한 정보를 확인하는 용도로 사용할 수 있습니다. 하지만 쿼리 계획을 사용하기 앞서서 먼저 Amazon Redshift가 쿼리를 처리하거나 쿼리 계획을 작성하는 방식부터 이해하는 것이 좋습니다. 자세한 내용은 <a href="./c-query-planning.html">쿼리 계획 및 실행 워크플로우</a> 섹션을 참조하세요.</p><p>쿼리 계획을 작성하려면 실제 쿼리 텍스트와 함께 <a href="./r_EXPLAIN.html">EXPLAIN</a> 명령을 실행하세요. 쿼리 계획은 다음과 같은 정보를 제공합니다.</p><div class="itemizedlist">
             
             
             
             
             
         <ul class="itemizedlist"><li class="listitem">
               <p>실행 엔진이 수행한 작업(상향식 결과 확인)</p>
            </li><li class="listitem">
               <p>각 작업이 수행한 단계 유형</p>
            </li><li class="listitem">
               <p>각 작업에서 사용되는 테이블과 열</p>
            </li><li class="listitem">
               <p>행의 수와 데이터 폭(바이트)을 기준으로 한 각 작업의 데이터 처리량</p>
            </li><li class="listitem">
               <p>상대적 작업 비용. 여기에서 <em>비용</em>이란 계획 내 각 단계의 상대적 실행 시간을 비교하는 척도를 말합니다. 그렇다고 비용이 실제 실행 시간이나 메모리 사용량에 대해 정확한 정보를 제공하는 것은 아니며, 마찬가지로 실행 계획 간 비교가 유의미하지도 않습니다. 단지 쿼리에서 가장 많은 리소스를 사용하는 작업이 무엇인지 알려주는 역할을 합니다.</p>
            </li></ul></div><p>EXPLAIN 명령은 실제로 쿼리를 실행하지는 않습니다. 쿼리가 현재 작업 조건에서 실행되는 경우 Amazon Redshift의 실행 계획을 보여줄 뿐입니다. 테이블 스키마 또는 데이터를 변경한 후 <a href="./r_ANALYZE.html">ANALYZE</a>를 다시 실행하여 통계 메타데이터를 업데이트하면 쿼리 계획도 달라질 수 있습니다.</p><p>EXPLAIN에서 출력되는 쿼리 계획은 쿼리 실행을 단순하지만 종합적으로 나타냅니다. 병렬 쿼리 처리에 대한 세부 정보까지 표시하지는 않습니다. 세부 정보를 보려면 쿼리 자체를 실행한 후 SVL_QUERY_SUMMARY 또는 SVL_QUERY_REPORT 뷰에서 쿼리 요약 정보를 가져옵니다. 이러한 뷰를 사용하는 자세한 방법은 <a href="./c-analyzing-the-query-summary.html">쿼리 요약 분석</a> 섹션을 참조하세요.</p><p>다음은 EVENT 테이블에 대한 GROUP BY 쿼리를 실행할 경우를 나타낸 EXPLAIN 출력 예입니다.</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select eventname, count(*) from event group by eventname;

                            QUERY PLAN
-------------------------------------------------------------------
XN HashAggregate  (cost=131.97..133.41 rows=576 width=17)
  -&gt;  XN Seq Scan on event  (cost=0.00..87.98 rows=8798 width=17)</code></pre><p>EXPLAIN은 다음과 같이 각 작업에 대한 지표를 반환합니다.</p><div class="variablelist">
             
             
             
         <dl>
               <dt><b><span class="term">비용</span></b></dt>
               <dd>
                  <p>계획 내 작업을 비교하는데 유용한 상대 값입니다. 비용은 2개의 마침표로 구분된 소수 값 2개로 구성됩니다. 예를 들면 <code class="code">cost=131.97..133.41</code>과 같습니다. 여기에서 첫 번째 값인 131.97은 위 작업의 첫 번째 행을 반환하는 상대적 비용을 나타냅니다. 그리고, 두 번째 값인 133.41은 위 작업을 완료하는 상대적 비용을 나타냅니다. 쿼리 계획 비용은 아래에서 위 방향으로 계획을 읽어가면서 누적됩니다. 따라서 위 예에서 HashAggregate 비용(131.97..133.41)은 아래 있는 Seq Scan 비용(0.00..87.98)이 포함된 것입니다.</p>
               </dd>
            
               <dt><b><span class="term">행</span></b></dt>
               <dd>
                  <p>반환될 것으로 예상되는 행의 수입니다. 위 예에서 스캔을 통해 반환된 것으로 예상되는 행의 수는 8,798개입니다. HashAggregate 연산자 자체에서는 576개의 행이 반환될 것으로 예상됩니다(결과 집합에서 중복 이벤트 이름은 무시했을 때).</p>
                  <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>참고</h6></div><div class="awsdocs-note-text"><p>예상되는 행의 수는 ANALYZE 명령으로 생성된 유효 통계를 기준으로 합니다. 최근에 ANALYZE를 실행하지 않았다면 예상되는 행의 수는 신뢰성이 떨어집니다.</p></div></div>
               </dd>
            
               <dt><b><span class="term">너비</span></b></dt>
               <dd>
                  <p>평균 행의 예상 폭(바이트)입니다. 위 예에서 평균 행은 폭이 17바이트가 될 것으로 보입니다.</p>
               </dd>
            </dl></div><h2 id="EXPLAIN-operators">EXPLAIN 연산자</h2>
            
            <p>이번 섹션에서는 EXPLAIN 출력 시 가장 자주 표시되는 연산자에 대해서 간략히 설명합니다. 전체 연산자 목록은 SQL 명령 섹션에서 <a href="./r_EXPLAIN.html">EXPLAIN</a> 섹션을 참조하세요.</p>
            <h3 id="scan-operator">순차적 스캔 연산자</h3>
               
               <p>순차적 스캔 연산자(Seq Scan)는 테이블 스캔을 나타냅니다. Seq Scan이 처음부터 끝까지 테이블의 열을 각각 순차적으로 스캔하고 WHERE 절에서 각 행의 쿼리 제약 조건을 평가합니다.</p>
             
            <h3 id="join-operators">조인 연산자</h3>
               
               <p>Amazon Redshift는 조인되는 테이블의 물리적 설계, 조인에 필요한 데이터의 위치, 쿼리 자체의 특정 요건을 기반으로 여러 가지 조인 연산자를 선택합니다.</p>
               <div class="itemizedlist">
                   
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">중첩 루프</span></p>
                     <p>중첩 루프는 가장 덜 최적화된 조인으로서 주로 크로스 조인(데카르트 곱)과 일부 부등식 조인에 사용됩니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Hash Join 및 Hash</span></p>
                     <p>일반적으로 중첩 루프 조인보다 빠른 해시 조인 및 해시는 내부 조인과 왼쪽 및 오른쪽 외부 조인에 사용됩니다. 이 연산자들은 조인 열이 둘 다 분산 키 <em>및</em> 정렬 키가 아닌 테이블을 조인할 때 사용됩니다. 해시 연산자는 조인의 이너 테이블에 대한 해시 테이블을 생성합니다. 해시 조인 연산자는 아우터 테이블을 읽고, 조인 열을 해시하고, 이너 해시 테이블과 일치하는 항목을 검색합니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">병합 조인</span></p>
                     <p>일반적으로 가장 빠른 조인인 병합 조인은 내부 조인과 외부 조인에 사용되지만 전체 조인에는 사용되지 않습니다. 이 연산자는 조인 열이 둘 다 분산 키 <em>및</em> 정렬 키인 테이블을 조인할 때, 그리고 조인 테이블에서 정렬되지 않은 비율이 20% 미만일 때 사용됩니다. 정렬된 테이블 2개를 순서대로 읽고 나서 일치하는 행을 찾습니다. 정렬되지 않은 행의 비율을 보려면 <a href="./r_SVV_TABLE_INFO.html">SVV_TABLE_INFO</a> 시스템 테이블에 대한 쿼리를 실행하세요.</p>
                  </li><li class="listitem"> 
                     <p><span class="topcom">공간 조인</span></p>
                     <p>일반적으로 공간 데이터의 근접성을 기반으로 한 고속 조인으로, <code class="code">GEOMETRY</code> 및 <code class="code">GEOGRAPHY</code> 데이터 유형에 사용됩니다.</p>
                  </li></ul></div>
             
            <h3 id="aggregate-operators">집계 연산자</h3>
               
               <p>쿼리 계획은 집계 함수 및 GROUP BY 작업과 관련된 쿼리에서 다음과 같은 연산자를 사용합니다.</p>
               <div class="itemizedlist">
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">집계</span></p>
                     <p>AVG, SUM 같은 스칼라 집계 함수에 사용되는 연산자입니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">HashAggregate</span></p>
                     <p>정렬 없이 분류된 집계 함수에 사용되는 연산자입니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">GroupAggregate</span></p>
                     <p>정렬과 함께 분류된 집계 함수에 사용되는 연산자입니다.</p>
                  </li></ul></div>
             
            <h3 id="sort-operators">정렬 연산자</h3>
               
               <p>쿼리 계획은 쿼리가 결과 집합을 정렬하거나 병합해야 할 때 다음과 같은 연산자를 사용합니다.</p>
               <div class="itemizedlist">
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">정렬</span></p>
                     <p>ORDER BY 절을 비롯해 UNION 쿼리 및 조인, SELECT DISTINCT 쿼리, 창 함수에서 필요한 정렬 등 기타 정렬 작업을 평가합니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Merge</span></p>
                     <p>병렬 작업을 통해 얻은 중간 정렬 결과에 따라 최종 정렬 결과를 산출합니다.</p>
                  </li></ul></div>
             
            <h3 id="UNION-INTERSECT-and-EXCEPT-operators">UNION, INTERSECT 및 EXCEPT 연산자</h3>
               
               <p>쿼리 계획은 UNION, INTERSECT 및 EXCEPT를 사용하는 집합 작업과 관련된 쿼리에서 다음과 같은 연산자를 사용합니다.</p>
               <div class="itemizedlist">
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">Subquery</span></p>
                     <p>UNION 쿼리를 실행하는 데 사용됩니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Hash Intersect Distinct </span></p>
                     <p> 쿼리를 실행하는 데 사용됩니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">SetOp Except</span></p>
                     <p>EXCEPT(또는 MINUS) 쿼리를 실행하는 데 사용됩니다.</p>
                  </li></ul></div>
             
            <h3 id="other-operators">기타 연산자</h3>
               
               <p>그 밖에다 다음과 같은 연산자가 일반 쿼리의 EXPLAIN 출력에 자주 사용됩니다.</p>
               <div class="itemizedlist">
                   
                   
                   
                   
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">고유</span></p>
                     <p>SELECT DISTINCT 쿼리 및 UNION 쿼리에 대한 중복을 제거합니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">제한</span></p>
                     <p>LIMIT 절을 처리합니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Window</span></p>
                     <p>창 함수를 실행합니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">결과</span></p>
                     <p>어떤 테이블 액세스에도 관련되지 않는 스칼라 함수를 실행합니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Subplan</span></p>
                     <p>특정 하위 쿼리에 사용됩니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">네트워크</span></p>
                     <p>추가 처리를 위해 중간 결과를 리더 노드로 전송합니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Materialize</span></p>
                     <p>중첩 루프 조인과 일부 병합 조인에 대한 입력 행을 저장합니다.</p>
                  </li></ul></div>
             
         <h2 id="joins-in-EXPLAIN">EXPLAIN의 조인 유형</h2>
            
            <p>쿼리 옵티마이저는 쿼리 구조 및 기본 테이블에 따라 다른 조인 유형을 사용하여 테이블 데이터를 가져옵니다. 그러면 EXPLAIN 출력이 조인 유형과 사용된 테이블, 그리고 테이블 데이터의 클러스터 분산 방식을 참조하여 쿼리 처리 방법을 설명합니다.</p>

            <h3 id="join-types">조인 유형 예</h3>
               
               <p>다음 예들은 쿼리 옵티마이저가 사용할 수 있는 여러 가지 조인 유형을 보여주고 있습니다. 쿼리 계획에서 사용되는 조인 유형은 관련 테이블의 물리적 설계에 따라 다릅니다.</p>
               <h4 id="hash-join-two-tables">예: 두 테이블의 해시 조인</h4>
                  
                  <p>다음은 CATID 열을 기준으로 EVENT와 CATEGORY를 조인하는 쿼리입니다. CATID는 CATEGORY에서는 분산 및 정렬 키이지만 EVENT에서는 그렇지 않습니다. 이때는 해시 조인이 EVENT를 외부 테이블로, 그리고 CATEGORY를 내부 테이블로 실행됩니다. CATEGORY가 작은 테이블이기 때문에 플래너는 쿼리를 처리하면서 DS_BCAST_INNER를 사용하여 CATEGORY 테이블의 복사본을 컴퓨팅 노드로 브로드캐스팅합니다. 이 예에서는 조인 비용이 계획의 누적 비용 대부분을 차지합니다.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select * from category, event where category.catid=event.catid;

                               QUERY PLAN
-------------------------------------------------------------------------
 XN Hash Join DS_BCAST_INNER  (cost=0.14..6600286.07 rows=8798 width=84)
   Hash Cond: ("outer".catid = "inner".catid)
   -&gt;  XN Seq Scan on event  (cost=0.00..87.98 rows=8798 width=35)
   -&gt;  XN Hash  (cost=0.11..0.11 rows=11 width=49)
         -&gt;  XN Seq Scan on category  (cost=0.00..0.11 rows=11 width=49)</code></pre>
                  <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>참고</h6></div><div class="awsdocs-note-text"><p>EXPLAIN 출력에서 정렬되어 있는 연산자 들여쓰기는 각 작업들이 서로 종속되지 않고 병렬 방식으로 시작될 수 있다는 것을 의미하기도 합니다. 위 예에서는 EVENT 테이블에 대한 스캔과 해시 작업이 정렬되어 있지만 EVENT 스캔을 시작하려면 해시 작업이 완전히 끝날 때까지 기다려야 합니다.</p></div></div>
                
               <h4 id="merge-join-two-tables">예: 두 테이블의 병합 조인</h4>
                  
                  <p>다음 쿼리 역시 SELECT *를 사용하지만 LISTID 열을 기준으로 SALES와 LISTING을 조인합니다. 이때 LISTID는 두 테이블 모두에 분산 및 정렬 키로 설정된 열입니다. 병합 조인이 선택되고, 데이터 재분산은 필요 없습니다(DS_DIST_NONE).</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select * from sales, listing where sales.listid = listing.listid;
QUERY PLAN
-----------------------------------------------------------------------------
XN Merge Join DS_DIST_NONE  (cost=0.00..6285.93 rows=172456 width=97)
  Merge Cond: ("outer".listid = "inner".listid)
  -&gt;  XN Seq Scan on listing  (cost=0.00..1924.97 rows=192497 width=44)
  -&gt;  XN Seq Scan on sales  (cost=0.00..1724.56 rows=172456 width=53)</code></pre>
                  <p>다음은 동일한 쿼리 내에서 다른 유형의 조인을 설명하는 예입니다. 위 예에서 보이듯이 SALES와 LISTING이 병합 조인되지만, 세 번째 테이블인 EVENT는 병합 조인 결과와 해시 조인되어야 합니다. 그 결과, 여기에서도 해시 조인에 따른 브로드캐스팅 비용이 발생합니다.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select * from sales, listing, event
where sales.listid = listing.listid and sales.eventid = event.eventid;
                                  QUERY PLAN
----------------------------------------------------------------------------
XN Hash Join DS_BCAST_INNER  (cost=109.98..3871130276.17 rows=172456 width=132)
  Hash Cond: ("outer".eventid = "inner".eventid)
  -&gt;  XN Merge Join DS_DIST_NONE  (cost=0.00..6285.93 rows=172456 width=97)
        Merge Cond: ("outer".listid = "inner".listid)
        -&gt;  XN Seq Scan on listing  (cost=0.00..1924.97 rows=192497 width=44)
        -&gt;  XN Seq Scan on sales  (cost=0.00..1724.56 rows=172456 width=53)
  -&gt;  XN Hash  (cost=87.98..87.98 rows=8798 width=35)
        -&gt;  XN Seq Scan on event  (cost=0.00..87.98 rows=8798 width=35)</code></pre>
                
               <h4 id="join-aggregate-and-sort-example">예: 조인, 집계 및 정렬</h4>
                  
                  <p>다음은 SALES 및 EVENT 테이블에 대한 해시 조인과, 그 뒤를 이어 분류된 SUM 함수와 ORDER BY 절을 설명하기 위한 집계 및 정렬 작업이 실행되는 쿼리입니다. 초기 Sort 연산자는 컴퓨팅 노드에서 병렬로 실행됩니다. 그런 다음 Network 연산자가 결과를 리더 노드에게 보내고 이어서 Merge 연산자가 최종 정렬 결과를 리더 노드에 산출합니다.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select eventname, sum(pricepaid) from sales, event 
where sales.eventid=event.eventid group by eventname
order by 2 desc;
                                           QUERY PLAN
---------------------------------------------------------------------------------
 XN Merge  (cost=1002815366604.92..1002815366606.36 rows=576 width=27)
  Merge Key: sum(sales.pricepaid)
  -&gt;  XN Network  (cost=1002815366604.92..1002815366606.36 rows=576 width=27)
        Send to leader
        -&gt;  XN Sort  (cost=1002815366604.92..1002815366606.36 rows=576 width=27)
              Sort Key: sum(sales.pricepaid)
              -&gt;  XN HashAggregate  (cost=2815366577.07..2815366578.51 rows=576 width=27)
                    -&gt;  XN Hash Join DS_BCAST_INNER  (cost=109.98..2815365714.80 rows=172456 width=27)
                          Hash Cond: ("outer".eventid = "inner".eventid)
                          -&gt;  XN Seq Scan on sales  (cost=0.00..1724.56 rows=172456 width=14)
                          -&gt;  XN Hash  (cost=87.98..87.98 rows=8798 width=21)
                                -&gt;  XN Seq Scan on event  (cost=0.00..87.98 rows=8798 width=21)</code></pre>
                
             
            <h3 id="data-redistribution">데이터 재분산</h3>
               
               <p>조인에 대한 EXPLAIN 출력은 조인을 용이하게 하기 위해 데이터의 클러스터 이동 방식에 대한 메서드를 지정합니다. 이 데이터 이동은 브로드캐스팅 또는 재분산으로 수행될 수 있습니다. 브로드캐스팅에서는 한쪽 조인의 데이터 값이 각 컴퓨팅 노드에서 나머지 모든 컴퓨팅 노드로 복사되어 모든 컴퓨팅 노드에 대한 데이터 복사가 완료됩니다. 재분산에서는 데이터 값이 현재 조각에서 새로운 조각(다른 노드의 조각일 가능성이 높음)으로 전송됩니다. 조인 열 중 하나가 분산 키인 경우에는 조인에 참여하는 나머지 테이블의 분산 키와 일치하도록 데이터가 재분산됩니다. 두 테이블 모두 조인 열 중 하나에 분산 키가 없는 경우에는 두 테이블 모두 분산되거나, 혹은 내부 테이블이 모든 노드로 브로드캐스팅됩니다.</p>
               <p>EXPLAIN 출력 또한 내부 테이블과 외부 테이블을 참조합니다. 내부 테이블이 먼저 스캔되어 쿼리 계획 하단 가까운 곳에 표시됩니다. 내부 테이블은 일치하는 조건을 탐색하는 대상 테이블입니다. 보통은 메모리에 저장되며, 일반적으로 해시 처리를 위한 원본 테이블인 동시에 가능하다면 조인하는 두 테이블 중 더 작은 용량의 테이블이기도 합니다. 외부 테이블은 내부 테이블을 대상으로 일치하는 행의 원본입니다. 일반적으로 디스크에서 읽어옵니다. 쿼리 옵티마이저는 최근 실행한 ANALYZE 명령의 데이터베이스 통계를 기준으로 내부 테이블과 외부 테이블을 선택합니다. 쿼리의 FROM 절에서 테이블 순서로는 내부 테이블과 외부 테이블을 구분할 수 없습니다.</p>
               <p>쿼리를 용이하게 하기 위해 데이터의 이동 방식은 쿼리 계획에서 다음 속성을 사용하여 구분합니다.</p>
               <div class="itemizedlist">
                   
                   
                   
                   
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">DS_BCAST_INNER</span></p>
                     <p>전체 내부 테이블의 복사본이 모든 컴퓨팅 노드로 브로드캐스팅됩니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_ALL_NONE</span></p>
                     <p>이미 내부 테이블이 DISTSTYLE ALL을 사용하여 모든 노드에 분산되었기 때문에 재분산이 필요 없습니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_NONE</span></p>
                     <p>두 테이블 모두 재분산되지 않습니다. 해당 조각이 노드 간 데이터 이동 없이 조인되기 때문에 공동 배치되는 조인도 가능합니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_INNER</span></p>
                     <p>내부 테이블이 재분산됩니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_OUTER</span></p>
                     <p>외부 테이블이 재분산됩니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_ALL_INNER</span></p>
                     <p>외부 테이블이 DISTSTYLE ALL을 사용하기 때문에 내부 테이블 전체가 단일 조각으로 재분산됩니다.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_BOTH</span></p>
                     <p>두 테이블 모두 재분산됩니다.</p>
                  </li></ul></div>
             
         <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="주의" /> <strong>javascript가 브라우저에서 비활성화되거나 사용이 불가합니다.</strong></p><p>AWS 설명서를 사용하려면 Javascript가 활성화되어야 합니다. 지침을 보려면 브라우저의 도움말 페이지를 참조하십시오.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">문서 규칙</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./c-query-planning.html">쿼리 계획 및 실행 워크플로우</div><div id="next" class="next-link" accesskey="n" href="./reviewing-query-plan-steps.html">쿼리 계획 단계 검토</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">이 페이지의 내용이 도움이 되었습니까? - 예</div><div class="content"><p>칭찬해 주셔서 감사합니다!</p><p>잠깐 시간을 내어 좋았던 부분을 알려 주시면 더 열심히 만들어 보겠습니다.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="feedback-tell-us" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-the-query-plan.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">이 페이지의 내용이 도움이 되었습니까? - 아니요</div><div class="content"><p>이 페이지에 작업이 필요하다는 점을 알려 주셔서 감사합니다. 실망시켜 드려 죄송합니다.</p><p>잠깐 시간을 내어 설명서를 향상시킬 수 있는 방법에 대해 말씀해 주십시오.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="feedback-tell-us" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-the-query-plan.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>