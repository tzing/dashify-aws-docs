<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="ko-KR"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>오류 트래핑 - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="stored-procedure-trapping-errors" /><meta name="default_state" content="stored-procedure-trapping-errors" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-trapping-errors.html" /><meta name="description" content="Amazon Redshift에서 저장 프로시저의 오류를 트래핑합니다." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="데이터베이스 개발자 안내서" /><meta name="abstract" content="페타바이트 규모의 엔터프라이즈급 완전관리형 데이터 웨어하우징 서비스인 Amazon Redshift로 데이터 웨어하우스를 생성하고 관리합니다." /><meta name="guide-locale" content="ko_kr" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-trapping-errors.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/stored-procedure-trapping-errors.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="데이터베이스 개발자 안내서" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="데이터베이스 개발자 안내서" /><meta id="panorama-serviceConsolePage" value="오류 트래핑" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>오류 트래핑 - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#stored-procedure-trapping-errors" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-trapping-errors.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-trapping-errors.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-trapping-errors.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,cluster,데이터 웨어하우스,샘플 데이터,데이터베이스,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "데이터베이스 개발자 안내서",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Amazon Redshift에서 저장 프로시저 생성",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-overview.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Amazon Redshift의 저장 프로시저 개요",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-create.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "오류 트래핑",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-create.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#stored-procedure-trapping-errors" target="_blank" rel="noopener noreferrer" title="pdf-tooltip"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">aws-documentation</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">데이터베이스 개발자 안내서</a></div><div id="page-toc-src"><a href="#stored-procedure-trapping-errors-examples">예</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="stored-procedure-trapping-errors">오류 트래핑</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p>저장 프로시저의 쿼리 또는 명령에 오류가 발생하면 후속 쿼리가 실행되지 않고 트랜잭션이 롤백됩니다. 그러나 EXCEPTION 블록을 사용하여 오류를 처리할 수 있습니다.</p><div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>참고</h6></div><div class="awsdocs-note-text"><p>기본 동작은 저장 프로시저에 추가 오류 생성 조건이 없는 경우에도 오류로 인해 후속 쿼리가 실행되지 않는 것입니다.</p></div></div><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[ &lt;&lt;label&gt;&gt; ]
[ DECLARE
  declarations ]
BEGIN
  statements
EXCEPTION
  WHEN OTHERS THEN
    statements
END;   
</code></pre><p>예외가 발생하고 예외 처리 블록을 추가하면 RAISE 문과 대부분의 다른 PL/pgSQL 문을 작성할 수 있습니다. 예를 들어 사용자 정의 메시지로 예외를 발생시키거나 기록을 로깅 테이블에 삽입할 수 있습니다.</p><p>예외 처리 블록에 들어갈 때 현재 트랜잭션이 롤백되고 블록의 명령문을 실행하기 위해 새 트랜잭션이 생성됩니다. 블록의 문이 오류 없이 실행되면 트랜잭션이 커밋되고 예외가 다시 발생합니다. 마지막으로 저장 프로시저가 종료됩니다.</p><p>예외 블록에서 지원되는 유일한 조건은 쿼리 취소를 제외한 모든 오류 유형과 일치하는 OTHERS입니다. 또한 예외 처리 블록에서 오류가 발생하면 외부 예외 처리 블록에서 이를 catch할 수 있습니다.</p><p>NONATOMIC 프로시저 내에서 오류가 발생하여 예외 블록에서 처리되는 경우 오류가 다시 발생하지 않습니다. 예외 처리 블록에서 포착한 예외를 발생시키려면 PL/pgSQL 문 <code class="code">RAISE</code>를 참조하세요. 이 문은 예외 처리 블록에서만 유효합니다. 자세한 내용은 <a href="./c_PLpgSQL-statements.html#r_PLpgSQL-messages-errors">RAISE</a> 섹션을 참조하세요.</p><p><b>저장 프로시저에서 오류가 나타난 후 발생하는 상황을 CONTINUE 핸들러를 사용하여 제어</b></p><p> <code class="code">CONTINUE</code> 핸들러는 NONATOMIC 저장 프로시저 내의 실행 흐름을 제어하는 일종의 예외 핸들러입니다. 핸들러를 사용하면 기존 문 블록을 종료하지 않고도 예외를 파악하고 처리할 수 있습니다. 일반적으로 저장 프로시저에서 오류가 발생하면 흐름이 중단되고 오류가 호출자에게 반환됩니다. 하지만 일부 사용 사례에서는 오류 상태가 흐름이 중단될 만큼 심각하지 않을 수도 있습니다. 별도의 트랜잭션에서 선택한 오류 처리 로직을 사용하여 오류를 적절하게 처리한 다음 오류 다음에 오는 문을 계속 실행하는 것이 좋습니다. 다음은 구문을 보여줍니다.</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[ DECLARE
  declarations ]
BEGIN
  statements
EXCEPTION
  [ CONTINUE_HANDLER | EXIT_HANDLER ] WHEN OTHERS THEN
    handler_statements
END;   
</code></pre><p>다양한 유형의 오류에 대한 정보를 수집하는 데 도움이 되는 몇 가지 시스템 테이블이 있습니다. 자세한 내용은 <a href="./r_STL_LOAD_ERRORS.html">STL_LOAD_ERRORS</a>, <a href="./r_STL_ERROR.html">STL_ERROR</a>, <a href="./r_SYS_STREAM_SCAN_ERRORS.html">SYS_STREAM_SCAN_ERRORS</a> 단원을 참조하세요. 오류 해결에 사용할 수 있는 추가 시스템 테이블도 있습니다. 이에 대한 자세한 정보는 <a href="./cm_chap_system-tables.html">시스템 테이블 및 뷰 참조</a>에서 찾아볼 수 있습니다.</p>
        <h2 id="stored-procedure-trapping-errors-examples">예</h2>
     <p>다음 예는 예외 처리 블록에서 문을 작성하는 방법을 보여줍니다. 저장 프로시저는 기본 트랜잭션 관리 동작을 사용합니다.</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">CREATE TABLE employee (firstname varchar, lastname varchar);
INSERT INTO employee VALUES ('Tomas','Smith');
CREATE TABLE employee_error_log (message varchar);

CREATE OR REPLACE PROCEDURE update_employee_sp() AS
$$
BEGIN
    UPDATE employee SET firstname = 'Adam' WHERE lastname = 'Smith';
    EXECUTE 'select invalid';
EXCEPTION WHEN OTHERS THEN
    RAISE INFO 'An exception occurred.';
    INSERT INTO employee_error_log VALUES ('Error message: ' || SQLERRM);
END;
$$ 
LANGUAGE plpgsql;

CALL update_employee_sp();

INFO:  An exception occurred.
ERROR:  column "invalid" does not exist
CONTEXT:  SQL statement "select invalid"
PL/pgSQL function "update_employee_sp" line 3 at execute statement</code></pre>
     <p>이 예에서 <code class="code">update_employee_sp</code>를 호출하면 <em>예외 발생(An exception occurred.)</em>이라는 정보 메시지가 나타나고 로깅 테이블의 <code class="code">employee_error_log</code> 로그에 오류 메시지가 삽입됩니다. 저장 프로시저가 종료되기 전에 원래 예외가 다시 발생합니다. 다음 쿼리는 예제를 실행한 결과로 생성된 레코드를 보여줍니다.</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT * from employee;

firstname | lastname 
-----------+----------
 Tomas     | Smith

SELECT * from employee_error_log;

          message                     
------------------------------------------------
 Error message: column "invalid" does not exist</code></pre>   
        <p>형식 관련 도움말 및 추가 수준 목록 등 RAISE에 대한 자세한 내용은 <a href="./c_PLpgSQL-statements.html">지원되는 PL/pgSQL 문</a> 섹션을 참조하세요.</p>
     <p>다음 예는 예외 처리 블록에서 문을 작성하는 방법을 보여줍니다. 저장 프로시저는 NONATOMIC 트랜잭션 관리 동작을 사용합니다. 이 예제에서는 프로시저 호출이 완료된 후 호출자에게 다시 오류가 발생하지 않습니다. 다음 문의 오류로 인해 UPDATE 문이 롤백되지 않습니다. 정보 메시지가 표시되고 오류 메시지가 로깅 테이블에 삽입됩니다.</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE TABLE employee (firstname varchar, lastname varchar); 
INSERT INTO employee VALUES ('Tomas','Smith'); 
CREATE TABLE employee_error_log (message varchar);

-- Create the SP in NONATOMIC mode
CREATE OR REPLACE PROCEDURE update_employee_sp_2() NONATOMIC AS
$$
BEGIN
    UPDATE employee SET firstname = 'Adam' WHERE lastname = 'Smith';
    EXECUTE 'select invalid';
EXCEPTION WHEN OTHERS THEN
    RAISE INFO 'An exception occurred.';
    INSERT INTO employee_error_log VALUES ('Error message: ' || SQLERRM);
END;
$$ 
LANGUAGE plpgsql;

CALL update_employee_sp_2();
INFO:  An exception occurred.
CALL

SELECT * from employee;

 firstname | lastname 
-----------+----------
 Adam      | Smith
(1 row)

SELECT * from employee_error_log;

                    message                     
------------------------------------------------
 Error message: column "invalid" does not exist
(1 row)
</code></pre><p>이 예에서는 2개의 하위 블록으로 프로시저를 만드는 방법을 보여줍니다. 저장 프로시저가 호출되면 첫 번째 하위 블록의 오류가 해당 예외 처리 블록에서 처리됩니다. 첫 번째 하위 블록이 완료된 후 프로시저는 두 번째 하위 블록을 계속 실행합니다. 결과를 보면 프로시저 호출이 완료될 때 오류가 발생하지 않음을 알 수 있습니다. employee 테이블에 대한 UPDATE 및 INSERT 작업이 커밋됩니다. 두 예외 블록의 오류 메시지가 로깅 테이블에 삽입됩니다.</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE TABLE employee (firstname varchar, lastname varchar); 
INSERT INTO employee VALUES ('Tomas','Smith'); 
CREATE TABLE employee_error_log (message varchar);

CREATE OR REPLACE PROCEDURE update_employee_sp_3() NONATOMIC AS
$$
BEGIN
    BEGIN
        UPDATE employee SET firstname = 'Adam' WHERE lastname = 'Smith';
        EXECUTE 'select invalid1';
    EXCEPTION WHEN OTHERS THEN
        RAISE INFO 'An exception occurred in the first block.';
        INSERT INTO employee_error_log VALUES ('Error message: ' || SQLERRM);
    END;
    BEGIN
        INSERT INTO employee VALUES ('Edie','Robertson');
        EXECUTE 'select invalid2';
    EXCEPTION WHEN OTHERS THEN
        RAISE INFO 'An exception occurred in the second block.';
        INSERT INTO employee_error_log VALUES ('Error message: ' || SQLERRM);
    END;
END;
$$ 
LANGUAGE plpgsql;

CALL update_employee_sp_3();
INFO:  An exception occurred in the first block.
INFO:  An exception occurred in the second block.
CALL

SELECT * from employee;

 firstname | lastname  
-----------+-----------
 Adam      | Smith
 Edie      | Robertson
(2 rows)

SELECT * from employee_error_log;

                     message                     
-------------------------------------------------
 Error message: column "invalid1" does not exist
 Error message: column "invalid2" does not exist
(2 rows)
</code></pre><p>다음 예시는 CONTINUE 예외 핸들러를 사용하는 방법을 보여줍니다. 이 샘플은 두 개의 테이블을 만들어 저장 프로시저에서 사용합니다. CONTINUE 핸들러는 NONATOMIC 트랜잭션 관리 동작을 사용하여 저장 프로시저의 실행 흐름을 제어합니다.</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">CREATE TABLE tbl_1 (a int);
CREATE TABLE tbl_error_logging(info varchar, err_state varchar, err_msg varchar);

CREATE OR REPLACE PROCEDURE sp_exc_handling_1() NONATOMIC AS
$$
BEGIN
    INSERT INTO tbl_1 VALUES (1);
    -- Expect an error for the insert statement following, because of the invalid value
    INSERT INTO tbl_1 VALUES ("val");
    INSERT INTO tbl_1 VALUES (2);
EXCEPTION CONTINUE_HANDLER WHEN OTHERS THEN
    INSERT INTO tbl_error_logging VALUES ('Encountered error', SQLSTATE, SQLERRM);
END;
$$ LANGUAGE plpgsql;</code></pre><p>저장 프로시저를 호출합니다.</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">CALL sp_exc_handling_1();</code></pre><p>흐름은 다음과 같이 진행됩니다.</p><div class="orderedlist">
         
         
     <ol><li><p>호환되지 않는 데이터 유형을 열에 삽입하려고 하면 오류가 발생합니다. 제어가 EXCEPTION 블록으로 전달됩니다. 예외 처리 블록이 입력될 때 현재 트랜잭션이 롤백되고 문을 실행하기 위해 새 암시적 트랜잭션이 생성됩니다.</p></li><li><p>CONTINUE_HANDLER의 문이 오류 없이 실행되면 제어가 문 바로 뒤에 있는 문으로 전달되어 예외가 발생합니다. CONTINUE_HANDLER의 문에서 새 예외가 발생하는 경우 EXCEPTION 블록 내에서 예외 핸들러를 사용하여 해당 예외를 처리할 수 있습니다.</p></li></ol></div><p>샘플 저장 프로시저를 호출한 후 테이블에 다음 레코드가 포함됩니다.</p><div class="itemizedlist">
         
         
     <ul class="itemizedlist"><li class="listitem"><p><code class="code">SELECT * FROM tbl_1;</code>을 실행하면 두 개의 레코드가 반환됩니다. 여기에는 <code class="code">1</code> 및 <code class="code">2</code> 값이 포함됩니다.</p></li><li class="listitem"><p><code class="code">SELECT * FROM tbl_error_logging;</code>을 실행하면 <em>오류 발생</em>, <em>42703</em>, <em>'val' 열이 tbl_1에 존재하지 않음</em>이라는 값이 있는 레코드 하나가 반환됩니다.</p></li></ul></div><p>다음 추가 오류 처리 예시에서는 EXIT 핸들러와 CONTINUE 핸들러를 모두 사용합니다. 그러면 데이터 테이블과 로깅 테이블이라는 두 개의 테이블이 생성됩니다. 또한 오류 처리를 보여주는 저장 프로시저가 생성됩니다.</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">CREATE TABLE tbl_1 (a int);
CREATE TABLE tbl_error_logging(info varchar, err_state varchar, err_msg varchar);

CREATE OR REPLACE PROCEDURE sp_exc_handling_2() NONATOMIC AS
$$
BEGIN
    INSERT INTO tbl_1 VALUES (1);
    BEGIN
        INSERT INTO tbl_1 VALUES (100);
        -- Expect an error for the insert statement following, because of the invalid value
        INSERT INTO tbl_1 VALUES ("val");
        INSERT INTO tbl_1 VALUES (101);
    EXCEPTION EXIT_HANDLER WHEN OTHERS THEN
        INSERT INTO tbl_error_logging VALUES ('Encountered error', SQLSTATE, SQLERRM);
    END;
    INSERT INTO tbl_1 VALUES (2);
    -- Expect an error for the insert statement following, because of the invalid value
    INSERT INTO tbl_1 VALUES ("val");
    INSERT INTO tbl_1 VALUES (3);
EXCEPTION CONTINUE_HANDLER WHEN OTHERS THEN
    INSERT INTO tbl_error_logging VALUES ('Encountered error', SQLSTATE, SQLERRM);
END;
$$ LANGUAGE plpgsql;</code></pre><p>저장 프로시저를 만든 후 다음을 사용하여 호출합니다.</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">CALL sp_exc_handling_2();</code></pre><p>BEGIN과 END라는 내부 세트로 괄호가 묶인 내부 예외 블록에서 오류가 발생하면 EXIT 핸들러가 오류를 처리합니다. 외부 블록에서 발생하는 모든 오류는 CONTINUE 핸들러에서 처리합니다.</p><p>샘플 저장 프로시저를 호출한 후 테이블에 다음 레코드가 포함됩니다.</p><div class="itemizedlist">
         
         
     <ul class="itemizedlist"><li class="listitem"><p><code class="code">SELECT * FROM tbl_1;</code>을 실행하면 값이 1, 2, 3, 100인 레코드 네 개가 반환됩니다.</p></li><li class="listitem"><p><code class="code">SELECT * FROM tbl_error_logging;</code>을 실행하면 두 개의 레코드가 반환됩니다. 값은 <em>오류 발생</em>, <em>42703</em>, <em>'val' 열이 tbl_1에 존재하지 않음</em>입니다.</p></li></ul></div><p><b>tbl_error_logging</b> 테이블이 존재하지 않는 경우 예외가 발생합니다.</p><p>다음 예시는 FOR 루프와 함께 CONTINUE 예외 핸들러를 사용하는 방법을 보여줍니다. 이 샘플은 세 개의 테이블을 만들어 저장 프로시저 내의 FOR 루프에서 사용합니다. FOR 루프는 결과 세트 변형입니다. 즉, 쿼리 결과를 반복합니다.</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">CREATE TABLE tbl_1 (a int);
INSERT INTO tbl_1 VALUES (1), (2), (3);
CREATE TABLE tbl_2 (a int);
CREATE TABLE tbl_error_logging(info varchar, err_state varchar, err_msg varchar);

CREATE OR REPLACE PROCEDURE sp_exc_handling_loop() NONATOMIC AS
$$
DECLARE
 rec RECORD;
BEGIN
    FOR rec IN SELECT a FROM tbl_1
    LOOP
        IF rec.a = 2 THEN
            -- Expect an error for the insert statement following, because of the invalid value
            INSERT INTO tbl_2 VALUES("val");
        ELSE
            INSERT INTO tbl_2 VALUES (rec.a);
        END IF;
    END LOOP;
EXCEPTION CONTINUE_HANDLER WHEN OTHERS THEN
    INSERT INTO tbl_error_logging VALUES ('Encountered error', SQLSTATE, SQLERRM);
END;
$$ LANGUAGE plpgsql;</code></pre><p>저장 프로시저를 호출합니다.</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">CALL sp_exc_handling_loop();</code></pre><p>샘플 저장 프로시저를 호출한 후 테이블에 다음 레코드가 포함됩니다.</p><div class="itemizedlist">
         
         
     <ul class="itemizedlist"><li class="listitem"><p> <code class="code">SELECT * FROM tbl_2;</code>을 실행하면 두 개의 레코드가 반환됩니다. 여기에는 1 및 3 값이 포함됩니다.</p></li><li class="listitem"><p><code class="code">SELECT * FROM tbl_error_logging;</code>을 실행하면 <em>오류 발생</em>, <em>42703</em>, <em>'val' 열이 tbl_2에 존재하지 않음</em>이라는 값이 있는 레코드 하나가 반환됩니다.</p></li></ul></div><p>CONTINUE 핸들러와 관련된 사용 참고 사항:</p><div class="itemizedlist">
         
 
         
     <ul class="itemizedlist"><li class="listitem"><p>CONTINUE_HANDLER 및 EXIT_HANDLER 키워드는 NONATOMIC 저장 프로시저에서만 사용할 수 있습니다.</p></li><li class="listitem"><p>CONTINUE_HANDLER 및 EXIT_HANDLER 키워드는 선택 사항입니다. EXIT_HANDLER가 기본값입니다.</p></li></ul></div><awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="주의" /> <strong>javascript가 브라우저에서 비활성화되거나 사용이 불가합니다.</strong></p><p>AWS 설명서를 사용하려면 Javascript가 활성화되어야 합니다. 지침을 보려면 브라우저의 도움말 페이지를 참조하십시오.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">문서 규칙</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./stored-procedure-transaction-management.html">트랜잭션 관리</div><div id="next" class="next-link" accesskey="n" href="./c_PLpgSQL-logging.html">저장 프로시저 로깅</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">이 페이지의 내용이 도움이 되었습니까? - 예</div><div class="content"><p>칭찬해 주셔서 감사합니다!</p><p>잠깐 시간을 내어 좋았던 부분을 알려 주시면 더 열심히 만들어 보겠습니다.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="feedback-tell-us" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-trapping-errors.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">이 페이지의 내용이 도움이 되었습니까? - 아니요</div><div class="content"><p>이 페이지에 작업이 필요하다는 점을 알려 주셔서 감사합니다. 실망시켜 드려 죄송합니다.</p><p>잠깐 시간을 내어 설명서를 향상시킬 수 있는 방법에 대해 말씀해 주십시오.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="feedback-tell-us" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-trapping-errors.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>