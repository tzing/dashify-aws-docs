<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="ko-KR"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Amazon Redshift Advisor 권장 사항 - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="advisor-recommendations" /><meta name="default_state" content="advisor-recommendations" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/advisor-recommendations.html" /><meta name="description" content="Amazon Redshift Advisor는 성능을 향상시키고 운영 비용을 절감하기 위해 Amazon Redshift 클러스터를 최적화하는 방법에 대한 권장 사항을 제공합니다. 위의 설명과 같이 콘솔에서 각 권장 사항에 대한 설명을 찾아볼 수 있습니다. 다음 단원에서 이러한 권장 사항에 대한 추가 세부 정보를 찾아볼 수 있습니다." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="데이터베이스 개발자 안내서" /><meta name="abstract" content="페타바이트 규모의 엔터프라이즈급 완전관리형 데이터 웨어하우징 서비스인 Amazon Redshift로 데이터 웨어하우스를 생성하고 관리합니다." /><meta name="guide-locale" content="ko_kr" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/advisor-recommendations.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/advisor-recommendations.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/advisor-recommendations.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/advisor-recommendations.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/advisor-recommendations.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/advisor-recommendations.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/advisor-recommendations.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/advisor-recommendations.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/advisor-recommendations.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/advisor-recommendations.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/advisor-recommendations.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/advisor-recommendations.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/advisor-recommendations.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/advisor-recommendations.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/advisor-recommendations.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/advisor-recommendations.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/advisor-recommendations.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/advisor-recommendations.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/advisor-recommendations.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/advisor-recommendations.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/advisor-recommendations.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/advisor-recommendations.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="데이터베이스 개발자 안내서" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="데이터베이스 개발자 안내서" /><meta id="panorama-serviceConsolePage" value="Amazon Redshift Advisor 권장 사항" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Amazon Redshift Advisor 권장 사항 - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#advisor-recommendations" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/advisor-recommendations.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/advisor-recommendations.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/advisor-recommendations.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,cluster,데이터 웨어하우스,샘플 데이터,데이터베이스,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "데이터베이스 개발자 안내서",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Amazon Redshift 모범 사례",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/best-practices.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Amazon Redshift Advisor의 권장 사항 작업",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/advisor.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "Amazon Redshift Advisor 권장 사항",
        "item" : "https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/advisor.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#advisor-recommendations" target="_blank" rel="noopener noreferrer" title="pdf-tooltip"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">aws-documentation</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">데이터베이스 개발자 안내서</a></div><div id="page-toc-src"><a href="#cluster-compress-s3-recommendation">COPY를 통해 로드되는 Amazon S3 파일 객체 압축</a><a href="#isolate-active-dbs-recommendation">여러 활성 데이터베이스 격리</a><a href="#reallocate-wlm-recommendation">워크로드 관리(WLM) 메모리 다시 할당</a><a href="#skip-compression-analysis-recommendation">COPY 중 압축 분석 건너뛰기</a><a href="#split-s3-objects-recommendation">COPY로 로드되는 Amazon S3 객체 분할</a><a href="#update-table-statistics-recommendation">테이블 통계 업데이트</a><a href="#enable-sqa-recommendation">단기 쿼리 가속화 활성화</a><a href="#alter-diststyle-distkey-recommendation">테이블의 분산 키 변경</a><a href="#alter-sortkey-recommendation">테이블의 정렬 키 변경</a><a href="#alter-compression-encoding-recommendation">열의 압축 인코딩 변경</a><a href="#data-type-recommendation">데이터 형식 권장 사항</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="advisor-recommendations">Amazon Redshift Advisor 권장 사항</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p>Amazon Redshift Advisor는 성능을 향상시키고 운영 비용을 절감하기 위해 Amazon Redshift 클러스터를 최적화하는 방법에 대한 권장 사항을 제공합니다. 위의 설명과 같이 콘솔에서 각 권장 사항에 대한 설명을 찾아볼 수 있습니다. 다음 단원에서 이러한 권장 사항에 대한 추가 세부 정보를 찾아볼 수 있습니다.</p><div class="highlights" id="inline-topiclist"><h6>주제</h6><ul><li><a href="#cluster-compress-s3-recommendation">COPY를 통해 로드되는 Amazon S3 파일 객체 압축</a></li><li><a href="#isolate-active-dbs-recommendation">여러 활성 데이터베이스 격리</a></li><li><a href="#reallocate-wlm-recommendation">워크로드 관리(WLM) 메모리 다시 할당</a></li><li><a href="#skip-compression-analysis-recommendation">COPY 중 압축 분석 건너뛰기</a></li><li><a href="#split-s3-objects-recommendation">COPY로 로드되는 Amazon S3 객체 분할</a></li><li><a href="#update-table-statistics-recommendation">테이블 통계 업데이트</a></li><li><a href="#enable-sqa-recommendation">단기 쿼리 가속화 활성화</a></li><li><a href="#alter-diststyle-distkey-recommendation">테이블의 분산 키 변경</a></li><li><a href="#alter-sortkey-recommendation">테이블의 정렬 키 변경</a></li><li><a href="#alter-compression-encoding-recommendation">열의 압축 인코딩 변경</a></li><li><a href="#data-type-recommendation">데이터 형식 권장 사항</a></li></ul></div>
            <h2 id="cluster-compress-s3-recommendation">COPY를 통해 로드되는 Amazon S3 파일 객체 압축</h2>
            <p>COPY 명령은 Amazon Redshift의 대량 병렬 처리(MPP) 아키텍처를 이용하여 병렬로 데이터를 읽고 로드합니다. Amazon S3, DynamoDB 테이블 및 하나 이상의 원격 호스트의 텍스트 출력에서 파일을 읽을 수 있습니다.</p>
            <p>많은 양의 데이터를 로드할 때는 COPY 명령을 사용하여 S3에서 압축된 데이터 파일을 로드하는 것이 좋습니다. 큰 데이터 세트를 압축하면 Amazon S3에 파일을 업로드하는 시간이 단축됩니다. 또한 COPY가 파일을 읽으면서 압축을 해제해 로드 프로세스를 단축할 수 있습니다.</p>
            <p><b>분석</b></p>
            <p>압축되지 않은 큰 데이터 세트를 로드하는 COPY 명령을 장기 실행하면 성능을 대폭 향상할 기회가 있습니다. Advisor 분석은 압축되지 않은 큰 데이터 세트를 로드하는 COPY 명령을 식별합니다. 이러한 경우 Advisor는 Amazon S3에서 소스 파일에 압축을 구현하라는 권장 사항을 생성합니다.</p>


            <p><b>권장 사항</b></p>
            <p>상당한 양의 데이터를 로드하거나 상당한 기간 동안 실행하는 각 COPY가 Amazon S3에서 압축되지 않은 데이터 객체를 수집하도록 합니다. 수퍼유저 권한으로 다음 SQL 명령을 실행하면 Amazon S3에서 압축되지 않은 큰 데이터 세트를 로드하는 COPY 명령을 식별할 수 있습니다.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">
SELECT
    wq.userid, query, exec_start_time AS starttime, COUNT(*) num_files,
    ROUND(MAX(wq.total_exec_time/1000000.0),2) execution_secs,
    ROUND(SUM(transfer_size)/(1024.0*1024.0),2) total_mb,
    SUBSTRING(querytxt,1,60) copy_sql
FROM stl_s3client s
JOIN stl_query q USING (query)
JOIN stl_wlm_query wq USING (query)
WHERE s.userid&gt;1 AND http_method = 'GET'
    AND POSITION('COPY ANALYZE' IN querytxt) = 0
    AND aborted = 0 AND final_state='Completed'
GROUP BY 1, 2, 3, 7
HAVING SUM(transfer_size) = SUM(data_size) 
AND SUM(transfer_size)/(1024*1024) &gt;= 5
ORDER BY 6 DESC, 5 DESC;         
          </code></pre>
            <p>스테이징된 데이터가 로드한 후에도 Amazon S3에 그대로 남아 있는 경우(데이터 레이크 아키텍처에서 일반적으로 발생함) 이 데이터를 압축된 형식으로 저장하면 스토리지 비용을 줄일 수 있습니다.</p>
            <p><b>구현 팁</b></p>

            <div class="itemizedlist">
                
                
            <ul class="itemizedlist"><li class="listitem">
                  <p>이상적인 객체 크기는 압축 후 1–128MB입니다.</p>
               </li><li class="listitem">
                  <p>gzip, lzop 또는 bzip2 형식을 사용하여 파일을 압축할 수 있습니다.</p>
               </li></ul></div>

          
            <h2 id="isolate-active-dbs-recommendation">여러 활성 데이터베이스 격리</h2>
            <p>모범 사례로, Amazon Redshift의 데이터베이스를 서로 격리하는 것이 좋습니다. 쿼리는 특정 데이터베이스에서 실행되며 클러스터에 있는 다른 데이터베이스의 데이터에 액세스할 수 없습니다. 하지만 클러스터의 모든 데이터베이스에서 실행하는 쿼리는 동일한 기본 클러스터 스토리지 공간을 공유하고 리소스를 컴퓨팅합니다. 단일 클러스터에 여러 활성 데이터베이스가 포함되는 경우 각 워크로드는 일반적으로 서로 관련되지 않습니다.</p>
            <p><b>분석</b></p>
            <p>Advisor 분석은 클러스터에 있는 모든 데이터베이스를 검토하여 동시에 실행되는 활성 워크로드를 확인합니다. 동시에 실행되는 활성 워크로드가 있는 경우 Advisor는 데이터베이스를 별도의 Amazon Redshift 클러스터로 마이그레이션하는 것이 좋다는 권장 사항을 생성합니다.</p>

            <p><b>권장 사항</b></p>
            <p>활성으로 쿼리되는 각 데이터베이스를 별도의 전용 클러스터로 이동하는 것이 좋습니다. 별도의 클러스터를 사용하면 리소스 경합을 줄이고 쿼리 성능을 향상할 수 있습니다. 그렇게 하면 각 워크로드의 스토리지, 비용 및 성능 필요에 맞게 각 클러스터의 크기를 설정할 수 있기 때문입니다. 또한 관련되지 않은 워크로드는 흔히 다른 워크로드 관리 구성에서 이점을 얻을 수 있습니다.</p>
            <p>데이터베이스가 활성으로 사용되는지 확인하려면 수퍼유저 권한으로 다음 SQL 명령을 실행할 수 있습니다.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">
SELECT database,
  COUNT(*) as num_queries,
  AVG(DATEDIFF(sec,starttime,endtime)) avg_duration,
  MIN(starttime) as oldest_ts,
  MAX(endtime) as latest_ts
FROM stl_query
WHERE userid &gt; 1
GROUP BY database;            
         </code></pre>
            <p><b>구현 팁</b></p>
            <div class="itemizedlist">
                
                
            <ul class="itemizedlist"><li class="listitem">
                  <p>사용자는 각 데이터베이스에 특정하게 연결해야 하고 쿼리는 단일 데이터베이스에만 액세스할 수 있기 때문에 데이터베이스를 별도의 클러스터로 이동해도 사용자에게는 미치는 영향은 최소한입니다.</p>
               </li><li class="listitem">
                  <p>데이터베이스를 이동하는 한 가지 옵션은 다음 단계를 수행하는 것입니다.</p>
                  <div class="orderedlist">
                      
                      
                      
                  <ol><li>
                        <p>현재 클러스터의 스냅샷을 동일한 크기의 클러스터로 임시로 복원합니다.</p>
                     </li><li>
                        <p>이동할 대상 데이터베이스를 제외한 모든 데이터베이스를 새 클러스터에서 삭제합니다.</p>
                     </li><li>
                        <p>데이터베이스의 워크로드에 적합한 노드 유형 및 개수로 클러스터를 크기 조정합니다.</p>
                     </li></ol></div>

               </li></ul></div>
          
            <h2 id="reallocate-wlm-recommendation">워크로드 관리(WLM) 메모리 다시 할당</h2>
            <p>Amazon Redshift는 사용자 쿼리를 <a href="./cm-c-defining-query-queues.html">수동 WLM 구현</a>로 라우팅하여 처리합니다. 이러한 쿼리의 대기열 라우팅 방식을 정의하는 것이 바로 워크로드 관리(WLM)입니다. Amazon Redshift는 클러스터의 사용 가능한 메모리 중 일부를 각 대기열에 할당합니다. 이렇게 할당된 대기열의 메모리는 다시 쿼리 슬롯으로 분할됩니다.</p>
            <p>워크로드에 필요한 것보다 더 많은 슬롯으로 대기열이 구성되면 이러한 사용되지 않은 슬롯에 할당된 메모리는 과소 사용 상태가 됩니다. 구성된 슬롯을 피크 워크로드 요구 사항에 맞게 줄이면 과소 사용 상태의 메모리가 활성 슬롯에 다시 배포되므로 쿼리 성능을 향상할 수 있습니다.</p>
            <p><b>분석</b></p>
            <p>Advisor 문석은 워크로드 동시성 요구 사항을 검토하여 사용되지 않는 슬롯이 있는 쿼리 대기열을 식별합니다. 다음을 발견하면 Advisor는 대기열의 슬롯 수를 줄이기 위한 권장 사항을 생성합니다.</p>
            <div class="itemizedlist">
                
                
            <ul class="itemizedlist"><li class="listitem">
                  <p>분석하는 동안 완전히 비활성인 슬롯이 있는 대기열</p>
               </li><li class="listitem">
                  <p>분석하는 동안 최소 2개의 비활성 슬롯이 포함된 4개 이상의 슬롯이 있는 대기열</p>
               </li></ul></div>

            <p><b>권장 사항</b></p>
            <p>구성된 슬롯을 피크 워크로드 요구 사항에 맞게 줄이면 과소 사용 상태의 메모리가 활성 슬롯에 다시 배포됩니다. 슬롯이 완전히 사용된 적이 없는 대기열의 경우 구성된 슬롯 개수를 줄이는 것이 좋습니다. 이러한 대기열을 식별하려면 수퍼유저 권한으로 다음 SQL 명령을 실행하여 각 대기열의 피크 시간별 슬롯 요구 사항을 비교할 수 있습니다.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">
WITH
 generate_dt_series AS (select sysdate - (n * interval '5 second') as dt from (select row_number() over () as n from stl_scan limit 17280)),
 apex AS (
     SELECT iq.dt, iq.service_class, iq.num_query_tasks, count(iq.slot_count) as service_class_queries, sum(iq.slot_count) as service_class_slots
     FROM
         (select gds.dt, wq.service_class, wscc.num_query_tasks, wq.slot_count
         FROM stl_wlm_query wq
         JOIN stv_wlm_service_class_config wscc ON (wscc.service_class = wq.service_class AND wscc.service_class &gt; 5)
         JOIN generate_dt_series gds ON (wq.service_class_start_time &lt;= gds.dt AND wq.service_class_end_time &gt; gds.dt)
         WHERE wq.userid &gt; 1 AND wq.service_class &gt; 5) iq
     GROUP BY iq.dt, iq.service_class, iq.num_query_tasks),
     maxes as (SELECT apex.service_class, trunc(apex.dt) as d, date_part(h,apex.dt) as dt_h, max(service_class_slots) max_service_class_slots
                     from apex group by apex.service_class, apex.dt, date_part(h,apex.dt))
SELECT apex.service_class - 5 AS queue, apex.service_class, apex.num_query_tasks AS max_wlm_concurrency, maxes.d AS day, maxes.dt_h || ':00 - ' || maxes.dt_h || ':59' as hour, MAX(apex.service_class_slots) as max_service_class_slots
FROM apex
JOIN maxes ON (apex.service_class = maxes.service_class AND apex.service_class_slots = maxes.max_service_class_slots)
GROUP BY  apex.service_class, apex.num_query_tasks, maxes.d, maxes.dt_h
ORDER BY apex.service_class, maxes.d, maxes.dt_h;            
         </code></pre>
            <p><code class="code">max_service_class_slots</code> 열은 해당 시간 동안 쿼리 대기열에 있는 최대 WLM 쿼리 슬롯 수를 나타냅니다. 사용률이 낮은 대기열이 있는 경우 <em>Amazon Redshift 관리 가이드</em>에 설명된 대로 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/managing-parameter-groups-console.html#parameter-group-modify">파라미터 그룹을 수정</a>하여 슬롯 감소 최적화를 구현합니다.</p>
            <p><b>구현 팁</b></p>
            <div class="itemizedlist">
                
                
            <ul class="itemizedlist"><li class="listitem">
                  <p>워크로드의 볼륨이 매우 가변적인 경우 분석에서 피크 사용률 기간이 포착되었는지 확인합니다. 그렇지 않은 경우 이전의 SQL을 반복적으로 실행하여 피크 동시성 요구 사항을 모니터링합니다.</p>
               </li><li class="listitem">
                  <p>위의 SQL 코드에서 쿼리 결과를 해석하는 방법에 대한 자세한 내용은 GitHub의 <a href="https://github.com/awslabs/amazon-redshift-utils/blob/master/src/AdminScripts/wlm_apex_hourly.sql" rel="noopener noreferrer" target="_blank"><span> wlm_apex_hourly.sql 스크립트 </span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a> 를 참조하십시오.</p>
               </li></ul></div>

          
            <h2 id="skip-compression-analysis-recommendation">COPY 중 압축 분석 건너뛰기</h2>
            <p>COPY 명령으로 선언된 압축 인코딩을 사용하여 데이터를 빈 테이블로 로드하면 Amazon Redshift는 스토리지 압축을 적용합니다. 이 최적화를 사용하면 최종 사용자가 로드하더라도 클러스터의 데이터가 효율적으로 저장됩니다. 압축을 적용하기 위해 필요한 분석에는 상당한 시간이 소요될 수 있습니다.</p>

            <p><b>분석</b></p>
            <p>Advisor 분석은 자동 압축 분석에서 지연된 COPY 작업을 확인합니다. 이 분석은 로드되는 동안 데이터를 샘플링하여 압축 인코딩을 결정합니다. 이 샘플링은 <a href="./r_ANALYZE_COMPRESSION.html">ANALYZE COMPRESSION</a> 명령이 수행하는 것과 비슷합니다.</p>
            <p>야간 추출, 변환, 로드(ETL) 배치와 같이 데이터를 구조적 프로세스의 일부로 로드하는 경우 압축을 미리 정의할 수 있습니다. 또한 테이블 정의를 최적화하여 부정적인 영향 없이 이 단계를 영구적으로 건너뛸 수도 있습니다.</p>
            <p><b>권장 사항</b></p>
            <p>압축 분석 단계를 건너뛰어서 COPY 응답성을 향상하려면 다음 두 가지 옵션 중 하나를 구현합니다.</p>
            <div class="itemizedlist">
                
                
            <ul class="itemizedlist"><li class="listitem">
                  <p>COPY 명령을 사용하여 로드하는 테이블을 생성할 때 열 <code class="code">ENCODE</code> 파라미터를 사용합니다.</p>
               </li><li class="listitem">
                  <p>COPY 명령에서 <code class="code">COMPUPDATE OFF</code> 파라미터를 제공하여 압축을 완전히 해제합니다.</p>
               </li></ul></div>
            <p>가장 좋은 솔루션은 일반적으로 테이블 생성 중에 열 인코딩을 사용하는 것입니다. 이 접근 방식을 사용하면 압축된 데이터를 디스크에 저장하는 장점을 그대로 유지할 수 있기 때문입니다. ANALYZE COMPRESSION 명령을 사용하여 압축 인코딩을 제안할 수 있지만, 이러한 인코딩을 적용하려면 테이블을 다시 생성해야 합니다. 이 프로세스를 자동화하려면 GitHub에 있는 AWS<a href="https://github.com/awslabs/amazon-redshift-utils/tree/master/src/ColumnEncodingUtility" rel="noopener noreferrer" target="_blank"><span>ColumnEncodingUtility</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>를 사용합니다.</p>
            <p>자동 압축 분석을 트리거한 최신 COPY 작업을 식별하려면 다음 SQL 명령을 실행합니다.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">
  WITH xids AS (
    SELECT xid FROM stl_query WHERE userid&gt;1 AND aborted=0 
    AND querytxt = 'analyze compression phase 1' GROUP BY xid
    INTERSECT SELECT xid FROM stl_commit_stats WHERE node=-1)
SELECT a.userid, a.query, a.xid, a.starttime, b.complyze_sec, 
    a.copy_sec, a.copy_sql
FROM (SELECT q.userid, q.query, q.xid, date_trunc('s',q.starttime) 
    starttime, substring(querytxt,1,100) as copy_sql, 
    ROUND(datediff(ms,starttime,endtime)::numeric / 1000.0, 2) copy_sec
    FROM stl_query q JOIN xids USING (xid)
    WHERE (querytxt ilike 'copy %from%' OR querytxt ilike '% copy %from%') 
    AND querytxt not like 'COPY ANALYZE %') a
LEFT JOIN (SELECT xid, 
    ROUND(sum(datediff(ms,starttime,endtime))::numeric / 1000.0,2) complyze_sec 
    FROM stl_query q JOIN xids USING (xid)
    WHERE (querytxt like 'COPY ANALYZE %' 
    OR querytxt like 'analyze compression phase %') 
    GROUP BY xid ) b ON a.xid = b.xid
WHERE b.complyze_sec IS NOT NULL ORDER BY a.copy_sql, a.starttime;
         </code></pre>
            <p><b>구현 팁</b></p>
            <div class="itemizedlist">
                
                
            <ul class="itemizedlist"><li class="listitem">
                  <p>ETL 프로세스 중에 생성된 상당한 크기의 모든 테이블(예: 스테이징 테이블 및 임시 테이블)이 첫 번째 정렬 키를 제외한 모든 열에 대해 압축 인코딩을 선언하는지 확인합니다.</p>
               </li><li class="listitem">
                  <p>이전의 SQL 명령으로 식별되는 각 COPY 명령에 대해 로드되는 테이블의 예상 수명 크기를 추정합니다. 테이블이 매우 작은 크기로 유지될 것을 확신하는 경우 <code class="code">COMPUPDATE OFF</code> 파라미터를 사용하여 압축을 완전히 해제합니다. 그렇지 않으면 COPY 명령을 사용하여 로드하기 전에 명시적 압축을 사용하여 테이블을 생성합니다.</p>
               </li></ul></div>
          
            <h2 id="split-s3-objects-recommendation">COPY로 로드되는 Amazon S3 객체 분할</h2>
            <p>COPY 명령은 Amazon Redshift의 대량 병렬 처리(MPP) 아키텍처를 활용하여 Amazon S3 파일의 데이터를 읽고로드합니다. COPY 명령은 여러 파일에서 데이터를 병렬 방식으로 로드하여 클러스터의 노드에게 워크로드를 분할합니다. 최적의 처리량을 달성하려면 데이터를 여러 파일로 분리하여 병렬 처리를 이용하는 것이 좋습니다.</p>
            <p><b>분석</b></p>
            <p>Advisor 분석은 Amazon S3에서 스테이징된 작은 수의 파일에 포함된 큰 데이터 세트를 로드하는 COPY 명령을 식별합니다. 적은 수의 파일에서 큰 데이터 세트를 로드하는 COPY 명령을 장기 실행하면 성능을 대폭 향상할 기회가 있습니다. Advisor가 이러한 COPY 명령에 상당한 시간이 걸리는 것으로 확인하면 Amazon S3에서 데이터를 추가 파일로 분할하여 병렬 처리를 증가시키기 위한 권장 사항을 생성합니다.</p>
            <p><b>권장 사항</b></p>
            <p>이 경우 나열된 우선 순위에 따라 다음 작업을 수행하는 것이 좋습니다.</p>
            <div class="orderedlist">
                
                
                
            <ol><li>
                  <p>클러스터 노드 수보다 적은 파일을 로드하는 COPY 명령을 최적화합니다.</p>
               </li><li>
                  <p>클러스터 조각 수보다 적은 파일을 로드하는 COPY 명령을 최적화합니다.</p>
               </li><li>
                  <p>파일 수가 클러스터 조각 수의 배수가 아닌 COPY 명령을 최적화합니다.</p>
               </li></ol></div>
            <p>특정 COPY 명령은 상당한 양의 데이터를 로드하거나 상당 기간 동안 실행됩니다. 이러한 명령의 경우 클러스터 내 조각 개수의 배수와 같은 수의 여러 데이터 객체를 Amazon S3에서 로드하는 것이 좋습니다. 각 COPY 명령이 로드한 S3 객체 수를 확인하려면 수퍼유저 권한으로 다음 SQL 코드를 실행합니다.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">
SELECT
    query, COUNT(*) num_files,
    ROUND(MAX(wq.total_exec_time/1000000.0),2) execution_secs,
    ROUND(SUM(transfer_size)/(1024.0*1024.0),2) total_mb,
    SUBSTRING(querytxt,1,60) copy_sql
FROM stl_s3client s
JOIN stl_query q USING (query)
JOIN stl_wlm_query wq USING (query)
WHERE s.userid&gt;1 AND http_method = 'GET'
    AND POSITION('COPY ANALYZE' IN querytxt) = 0
    AND aborted = 0 AND final_state='Completed'
GROUP BY query, querytxt
HAVING (SUM(transfer_size)/(1024*1024))/COUNT(*) &gt;= 2
ORDER BY CASE
WHEN COUNT(*) &lt; (SELECT max(node)+1 FROM stv_slices) THEN 1
WHEN COUNT(*) &lt; (SELECT COUNT(*) FROM stv_slices WHERE node=0) THEN 2
ELSE 2+((COUNT(*) % (SELECT COUNT(*) FROM stv_slices))/(SELECT COUNT(*)::DECIMAL FROM stv_slices))
END, (SUM(transfer_size)/(1024.0*1024.0))/COUNT(*) DESC;   
            
         </code></pre>
            <p><b>구현 팁</b></p>
            <div class="itemizedlist">
                
                
                
            <ul class="itemizedlist"><li class="listitem">
                  <p>노드에 있는 조각 수는 클러스터의 노드 크기에 따라 다릅니다. 다양한 노드 유형의 슬라이스 수에 대한 자세한 내용은 <em>Amazon Redshift 관리 가이드</em>의 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes">Amazon Redshift의 노드 및 클러스터</a> 섹션을 참조하세요.</p>
               </li><li class="listitem">
                  <p>집합에 공통 접두사 또는 접두사 키를 지정하거나 매니페스트 파일에서 파일을 명시적으로 나열하여 여러 파일을 로드할 수 있습니다. 파일 로드에 대한 자세한 내용은 <a href="./t_splitting-data-files.html">압축 및 비압축 파일에서 데이터 로드</a> 섹션을 참조하세요.</p>
               </li><li class="listitem">
                  <p>Amazon Redshift는 워크로드를 분리할 때 파일 크기를 고려하지 않습니다. 이때는 압축 후 파일 크기가 1MB~1GB로 거의 같아질 수 있도록 로딩 데이터 파일을 분할합니다.</p>
               </li></ul></div>
          
            <h2 id="update-table-statistics-recommendation">테이블 통계 업데이트</h2>
            <p>Amazon Redshift는 비용 기반 쿼리 옵티마이저를 사용하여 쿼리에 최적의 실행 계획을 선택합니다. 예상 비용은 ANALYZE 명령을 사용하여 수집된 테이블 통계를 기반으로 합니다. 통계가 오래되었거나 누락된 경우 데이터베이스는 매우 복잡한 쿼리의 쿼리 실행에 덜 효율적인 계획을 선택할 수 있습니다. 통계를 최신 상태로 유지하면 최대한 빠른 시간 내에 복잡한 쿼리를 실행하는 데 도움이 됩니다.</p>
            <p><b>분석</b></p>
            <p>Advisor 분석은 통계가 오래되거나 누락된 테이블을 추적합니다. 이 기능은 복잡한 쿼리와 연결된 테이블 액세스 메타데이터를 검토합니다. 복잡한 패턴으로 자주 액세스되는 테이블에 통계가 누락된 경우 Advisor는 ANALYZE를 실행하기 위한 <b>중요</b> 권장 사항을 생성합니다. 복잡한 패턴으로 자주 액세스되는 테이블에 오래된 통계가 있는 경우 Advisor는 ANALYZE를 실행하기 위한 <b>제안</b> 권장 사항을 생성합니다.</p>

            <p><b>권장 사항</b></p>
            <p>테이블 콘텐츠가 대폭 변경될 때마다 ANALYZE를 사용하여 통계를 업데이트합니다. COPY 또는 INSERT 명령을 통해 상당한 수의 새로운 데이터 행이 기존 테이블에 로드될 때마다 ANALYZE를 실행하는 것이 좋습니다. 또한 UPDATE 또는 DELETE 명령을 통해 상당한 수의 행이 수정될 때마다 ANALYZE를 실행하는 것이 좋습니다. 어떤 테이블에 누락되거나 오래된 통계가 있는지 확인하려면 수퍼유저 권한으로 다음 SQL 명령을 실행합니다. 결과는 가장 큰 테이블부터 가장 작은 테이블까지의 순서로 정렬됩니다.</p>
            <p>어떤 테이블에 누락되거나 오래된 통계가 있는지 확인하려면 수퍼유저 권한으로 다음 SQL 명령을 실행합니다. 결과는 가장 큰 테이블부터 가장 작은 테이블까지의 순서로 정렬됩니다.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">
SELECT
   ti.schema||'.'||ti."table" tablename,
   ti.size table_size_mb,
   ti.stats_off statistics_accuracy
 FROM svv_table_info ti
 WHERE ti.stats_off &gt; 5.00
 ORDER BY ti.size DESC;          
         </code></pre>
            <p><b>구현 팁</b></p>
            
                  <p>기본적으로 ANALYZE 임계값은 10퍼센트로 설정됩니다. 이와 같은 기본값은 마지막 ANALYZE 실행 후 테이블에서 변경된 행이 전체 행의 10% 미만인 경우 ANALYZE 명령이 주어진 테이블을 건너뜀을 의미합니다. 결과적으로 ETL 프로세스의 끝에 ANALYZE 명령을 실행하도록 선택할 수 있습니다. 이 방법을 사용한다는 것은 ANALYZE가 종종 생략되고 ANALYZE가 필요할 때 실행된다는 것을 의미합니다.</p>
              
                  <p>ANALYZE 통계는 조인 시 사용되는 열(예: <code class="code">JOIN tbl_a ON col_b</code>) 또는 조건자로 사용되는 열(예: <code class="code">WHERE col_b = 'xyz'</code>)에 가장 많은 영향을 미칩니다. 기본적으로 ANALYZE는 지정된 테이블에 있는 모든 열에 대한 통계를 수집합니다. 필요한 경우 가장 많은 영향을 미치는 열에 대해서만 ANALYZE를 실행하여 ANALYZE를 실행하는 데 필요한 시간을 줄일 수 있습니다. 다음 SQL 명령을 실행하여 조건자로 사용되는 열을 식별할 수 있습니다. 또한 Amazon Redshift에서 <code class="code">ANALYZE PREDICATE COLUMNS</code>를 지정하여 분석할 열을 선택할 수 있습니다.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">WITH predicate_column_info as (
SELECT ns.nspname AS schema_name, c.relname AS table_name, a.attnum as col_num,  a.attname as col_name,
        CASE
            WHEN 10002 = s.stakind1 THEN array_to_string(stavalues1, '||') 
            WHEN 10002 = s.stakind2 THEN array_to_string(stavalues2, '||')
            WHEN 10002 = s.stakind3 THEN array_to_string(stavalues3, '||')
            WHEN 10002 = s.stakind4 THEN array_to_string(stavalues4, '||')
            ELSE NULL::varchar
        END AS pred_ts
   FROM pg_statistic s
   JOIN pg_class c ON c.oid = s.starelid
   JOIN pg_namespace ns ON c.relnamespace = ns.oid
   JOIN pg_attribute a ON c.oid = a.attrelid AND a.attnum = s.staattnum)
SELECT schema_name, table_name, col_num, col_name,
       pred_ts NOT LIKE '2000-01-01%' AS is_predicate,
       CASE WHEN pred_ts NOT LIKE '2000-01-01%' THEN (split_part(pred_ts, '||',1))::timestamp ELSE NULL::timestamp END as first_predicate_use,
       CASE WHEN pred_ts NOT LIKE '%||2000-01-01%' THEN (split_part(pred_ts, '||',2))::timestamp ELSE NULL::timestamp END as last_analyze
FROM predicate_column_info;</code></pre>
            <p>자세한 내용은 <a href="./t_Analyzing_tables.html">테이블 분석</a> 섹션을 참조하세요.</p>
          
            <h2 id="enable-sqa-recommendation">단기 쿼리 가속화 활성화</h2>
            <p>단기 쿼리 가속화(SQA)는 선택한 단기 실행 쿼리를 장기 실행 쿼리보다 우선적으로 적용합니다. SQA 쿼리가 대기열에서 장기 쿼리 뒤에서 대기해야 하지 않도록 SQA는 전용 공간에서 단기 실행 쿼리를 실행합니다. SQA는 단기 실행되고 사용자 정의 대기열에 있는 쿼리에만 우선순위를 부여합니다. SQA가 있으면 단기 실행 쿼리가 더 빠르게 실행하기 시작하며 사용자가 더 빨리 결과를 확인합니다.</p>
            <p>SQA를 켜면 단기 쿼리 실행에 전용되는 WLM(Workload Management) 대기열을 축소하거나 제거할 수 있습니다. 또한 장기 실행 쿼리가 단기 실행 쿼리와 대기열의 슬롯에 대해 경합할 필요가 없으므로, 더 적은 쿼리 슬롯을 사용하도록 WLM 대기열을 구성할 수 있습니다. 더 적은 동시성을 사용하면 대부분의 워크로드에 대해 쿼리 처리량이 증가되고 전체 시스템 성능이 향상됩니다. 자세한 내용은 <a href="./wlm-short-query-acceleration.html">단기 쿼리 가속화 작업</a> 섹션을 참조하세요.</p>
            <p><b>분석</b></p>
            <p>Advisor가 워크로드 패턴을 확인하고 최근 쿼리 개수를 보고합니다. 이때, SQA 적격 쿼리에 대한 지연 시간 및 일일 대기열 시간이 줄어듭니다.</p>
            <p><b>권장 사항</b></p>
            <p>SQA를 켜 WLM 구성을 수정합니다. Amazon Redshift는 기계 학습 알고리즘을 사용하여 각 적격 쿼리를 분석합니다. SQA가 쿼리 패턴에서 학습하면 예측이 향상됩니다. 자세한 내용은 <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/workload-mgmt-config.html">워크로드 관리 구성</a>을 참조하십시오.</p>
            <p>SQA를 켜면 WLM이 단기 쿼리에 대한 최대 실행 시간을 ‘동적(dynamic)’으로 기본 설정합니다. SQA 최대 실행 시간에 대해서는 동적 설정을 유지하는 것이 좋습니다.</p>
            <p><b>구현 팁</b></p>
            <p>SQA가 켜져 있는지 확인하려면 다음 쿼리를 실행합니다. 쿼리가 행을 반환한다면 SQA가 켜진 상태입니다.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">select * from stv_wlm_service_class_config 
where service_class = 14;</code></pre>
            <p>자세한 내용은 <a href="./wlm-short-query-acceleration.html#wlm-monitoring-sqa">SQA 모니터링</a> 섹션을 참조하세요.</p>
          
            <h2 id="alter-diststyle-distkey-recommendation">테이블의 분산 키 변경</h2>
            <p>Amazon Redshift는 테이블 배포 스타일에 따라 클라스터에 테이블 행을 분산합니다. KEY 분산이 있는 테이블에는 분산 키(DISTKEY)로서 열이 필요합니다. 테이블 행은 DISTKEY 열 값에 따라 클러스터의 노드 조각에 할당됩니다.</p>
            <p>적절한 DISTKEY는 각 노드 조각에 비슷한 행 수를 배치하고 조인 조건에서 자주 참조됩니다. 테이블이 DISTKEY 열에 조인될 때 최적화된 조인이 발생하여 쿼리 성능이 향상됩니다.</p>
            
            <p><b>분석</b></p>
            <p>Advisor는 클라우저의 워크로드를 분석하여 키 분산 스타일에서 큰 이점을 얻을 수 있는 테이블에 가장 적절한 분산 키를 식별합니다.</p>
            
            <p><b>권장 사항</b></p>
            <p>Advisor는 분석을 기반으로 테이블의 DISTSTYLE 및 DISTKEY를 변경하는 <a href="./r_ALTER_TABLE.html">ALTER TABLE</a> 문을 제공합니다. 상당한 성능 이점을 실현하려면 권장 그룹 내의 모든 SQL 문을 구현해야 합니다.</p>
            <p>ALTER TABLE로 큰 테이블을 다시 분산하면 클러스터 리소스가 사용되고 다양한 시간에 임시 테이블 잠금이 필요합니다. 다른 클러스터 워크로드가 적은 경우 각 권장 그룹을 구현합니다. 테이블 배포 속성의 최적화에 대한 자세한 내용은 <a href="https://aws.amazon.com/blogs/big-data/amazon-redshift-engineerings-advanced-table-design-playbook-distribution-styles-and-distribution-keys/" rel="noopener noreferrer" target="_blank"><span>Amazon Redshift Engineering의 고급 테이블 설계 플레이북: 배포 스타일 및 배포 키</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>에서 확인할 수 있습니다.</p>        
            <p>ALTER DISTSYLE 및 DISTKEY에 대한 자세한 내용은 <a href="./r_ALTER_TABLE.html">ALTER TABLE</a> 섹션을 참조하세요.</p>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>참고</h6></div><div class="awsdocs-note-text"><p>권장 사항이 표시되지 않는다고 해서 현재 배포 스타일이 가장 적합하다는 의미는 아닙니다. 데이터가 충분하지 않거나 재배포할 경우의 예상되는 이점이 적은 경우에는 Advisor에서 권장 사항을 제공하지 않습니다.</p><p>Advisor 권장 사항은 특정 테이블에 적용되며 반드시 동일한 이름의 열이 포함된 테이블에만 적용되지는 않습니다. 열 이름을 공유하는 테이블은 테이블 내부의 데이터가 동일하지 않으면 해당 열에 대해 다른 특성을 가질 수 있습니다.</p><p>ETL 작업으로 생성되거나 삭제된 스테이징 테이블에 대한 권장 사항이 표시되면, Advisor 권장 분산 키를 사용하도록 ETL 프로세스를 수정하십시오.</p></div></div>

          
            <h2 id="alter-sortkey-recommendation">테이블의 정렬 키 변경</h2>
            <p>Amazon Redshift는 테이블 <a href="./t_Sorting_data.html">정렬 키</a>에 따라 테이블 행을 정렬합니다. 테이블 행의 정렬은 정렬 키 열 값을 기준으로 합니다.</p>
            <p>적절한 정렬 키로 테이블을 정렬하면 디스크에서 요청하는 테이블 블록 읽기 수가 감소되므로 쿼리, 특히 범위 제한 술어를 사용하는 쿼리의 성능을 가속화할 수 있습니다.</p>
            
            <p><b>분석</b></p>
            <p>Advisor는 며칠 동안 클러스터의 워크로드를 분석하여 테이블에 적합한 정렬 키를 식별합니다.</p>
            
            <p><b>권장 사항</b></p>
            <p> Advisor는 분석을 기반으로 테이블의 정렬 키를 변경하는 2개의 ALTER TABLE 문 그룹을 제공합니다.</p>
            <div class="itemizedlist">
                
                
            <ul class="itemizedlist"><li class="listitem"><p>현재 COMPOUND 정렬 키를 추가하기 위한 정렬 키가 없는 테이블을 변경하는 문입니다.</p></li><li class="listitem"><p>정렬 키를 INTERLEAVED에서 COMPOUND 또는 정렬 키 없음으로 변경하는 문입니다.</p>
                  <p>복합 정렬 키를 사용하면 유지 관리 오버헤드가 크게 줄어듭니다. 복합 정렬 키가 있는 테이블에는 인터리브 정렬에 필요하고 비용이 많이 드는 VACUUM REINDEX 작업이 필요하지 않습니다. 실제로, 대다수의 Amazon Redshift 워크로드에는 인터리브 정렬 키보다 복합 정렬 키가 훨씬 효율적입니다. 그러나 테이블이 작은 경우 정렬 키 스토리지 오버헤드를 피하기 위해 정렬 키가 없는 것이 더 효율적입니다.</p></li></ul></div>
            
            <p>ALTER TABLE을 사용하여 큰 테이블을 정렬할 경우 클러스터 리소스가 사용되고 테이블 잠금이 여러 번 필요합니다. 클러스터의 워크로드가 보통인 경우 각 권장 사항을 구현합니다. 테이블 정렬 키 구성 최적화에 대한 자세한 내용은 <a href="https://aws.amazon.com/blogs/big-data/amazon-redshift-engineerings-advanced-table-design-playbook-compound-and-interleaved-sort-keys/" rel="noopener noreferrer" target="_blank"><span>Amazon Redshift Engineering's Advanced Table Design Playbook: Compound and Interleaved Sort Keys</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>를 참조하세요.</p>        
            <p>ALTER SORTKEY에 대한 자세한 내용은 <a href="./r_ALTER_TABLE.html">ALTER TABLE</a> 섹션을 참조하세요.</p>
            
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>참고</h6></div><div class="awsdocs-note-text"><p>테이블에 대한 권장 사항이 표시되지 않는다고 해서 현재 구성이 가장 적합하다는 의미는 아닙니다. 데이터가 충분하지 않거나 정렬할 경우 예상되는 이점이 적은 경우에는 Advisor에서 권장 사항을 제공하지 않습니다.</p><p>Advisor 권장 사항은 특정 테이블에 적용되며 동일한 이름과 데이터 형식의 열이 포함된 테이블에 반드시 적용할 필요는 없습니다. 열 이름을 공유하는 테이블은 테이블의 데이터와 워크로드에 따라 다른 권장 사항을 가질 수 있습니다.</p></div></div>
            
          
            <h2 id="alter-compression-encoding-recommendation">열의 압축 인코딩 변경</h2>
            <p>압축은 열 수준에서 저장되는 데이터의 크기를 줄일 수 있는 작업입니다. 압축은 Amazon Redshift에서 디스크 I/O 양을 줄여 스토리지 공간을 절약하고 쿼리 성능을 개선하는 데 사용됩니다. 데이터 형식과 쿼리 패턴을 기반으로 각 열에 대해 최적의 압축 인코딩을 권장합니다. 최적의 압축을 통해 쿼리를 보다 효율적으로 실행할 수 있으며 데이터베이스는 최소한의 스토리지 공간을 차지할 수 있습니다.</p>
            
            <p><b>분석</b></p>
            <p>Advisor는 클러스터의 워크로드 및 데이터베이스 스키마를 지속적으로 분석하여 각 테이블 열에 대한 최적의 압축 인코딩을 식별합니다.</p>
            
            <p><b>권장 사항</b></p>
            <p>Advisor는 분석을 기반으로 특정 열의 압축 인코딩을 변경하는 ALTER TABLE 문을 제공합니다.</p>
            <p><a href="./r_ALTER_TABLE.html">ALTER TABLE</a>로 열 압축 인코딩을 변경하면 클러스터 리소스가 소모되고 여러 번 테이블 잠금이 필요합니다. 클러스터 워크로드가 적은 경우 권장 사항을 구현하는 것이 가장 좋습니다.</p>
            <p>참고로 <a href="./r_ALTER_TABLE_examples_basic.html">ALTER TABLE 예</a>은 열의 인코딩을 변경하는 여러 문을 보여줍니다.</p>        
            
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>참고</h6></div><div class="awsdocs-note-text"><p>데이터가 충분하지 않거나 인코딩을 변경할 경우 예상되는 이점이 적은 경우에는 Advisor에서 권장 사항을 제공하지 않습니다.</p></div></div>
            
          
            <h2 id="data-type-recommendation">데이터 형식 권장 사항</h2>
            <p>Amazon Redshift에는 다양한 사용 사례를 위한 SQL 데이터 형식 라이브러리가 있습니다. <code class="code">INT</code>와 같은 정수 형식, <code class="code">VARCHAR</code>과 같이 문자를 저장하는 형식 등을 예로 들 수 있습니다. Redshift는 빠른 액세스와 뛰어난 쿼리 성능을 제공하기 위해 최적화된 방식으로 형식을 저장합니다. 또한 Redshift는 형식을 지정하거나 쿼리 결과에 대한 계산을 수행하는 데 사용할 수 있는 특정 형식을 위한 함수를 제공합니다.</p>
            
            <p><b>분석</b></p>
            <p>Advisor는 클러스터의 워크로드 및 데이터베이스 스키마를 지속적으로 분석하여 데이터 형식 변경으로 이점을 얻을 수 있는 열을 식별합니다.</p>
            
            <p><b>권장 사항</b></p>
            
            <p> Advisor는 제안된 데이터 형식의 새 열을 추가하는 <code class="code">ALTER TABLE</code> 문을 제공합니다. 함께 제공되는 <code class="code">UPDATE</code> 문은 기존 열에서 새 열로 데이터를 복사합니다. 새 열을 생성하고 데이터를 로드한 후 쿼리 및 수집 스크립트를 변경하여 새 열에 액세스합니다. 그런 다음 <a href="./c_SQL_functions.html">SQL 함수 참조</a>에서 찾을 수 있는 새로운 데이터 형식에 특화된 기능 및 함수를 활용합니다.</p>
            <p> 기존 데이터를 새 열에 복사하는 데 시간이 걸릴 수 있습니다. 클러스터의 워크로드가 적은 경우 각 Advisor 권장 사항을 구현하는 것이 좋습니다. <a href="./c_Supported_data_types.html">데이터 타입</a>에서 사용 가능한 데이터 형식 목록을 참조합니다.</p>
            <p> 데이터가 충분하지 않거나 데이터 형식 변경으로 예상되는 이점이 적은 경우에는 Advisor에서 권장 사항을 제공하지 않습니다.</p>        
            
         <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="주의" /> <strong>javascript가 브라우저에서 비활성화되거나 사용이 불가합니다.</strong></p><p>AWS 설명서를 사용하려면 Javascript가 활성화되어야 합니다. 지침을 보려면 브라우저의 도움말 페이지를 참조하십시오.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">문서 규칙</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./access-advisor.html">액세스 고문</div><div id="next" class="next-link" accesskey="n" href="./tutorials-redshift.html">자습서</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">이 페이지의 내용이 도움이 되었습니까? - 예</div><div class="content"><p>칭찬해 주셔서 감사합니다!</p><p>잠깐 시간을 내어 좋았던 부분을 알려 주시면 더 열심히 만들어 보겠습니다.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="feedback-tell-us" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/advisor-recommendations.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">이 페이지의 내용이 도움이 되었습니까? - 아니요</div><div class="content"><p>이 페이지에 작업이 필요하다는 점을 알려 주셔서 감사합니다. 실망시켜 드려 죄송합니다.</p><p>잠깐 시간을 내어 설명서를 향상시킬 수 있는 방법에 대해 말씀해 주십시오.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="feedback-tell-us" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/advisor-recommendations.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>