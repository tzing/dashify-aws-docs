<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Supported PL/pgSQL statements - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="c_PLpgSQL-statements" /><meta name="default_state" content="c_PLpgSQL-statements" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="description" content="Work with the PL/pgSQL statements supported by Amazon Redshift." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="Database Developer Guide" /><meta name="abstract" content="Create and manage a data warehouse with Amazon Redshift, an enterprise-level, petabyte scale, fully managed data warehousing service." /><meta name="guide-locale" content="en_us" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="Database Developer Guide" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="Database Developer Guide" /><meta id="panorama-serviceConsolePage" value="Supported PL/pgSQL statements" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Supported PL/pgSQL statements - Amazon Redshift</title><meta name="pdf" content="/pdfs/redshift/latest/dg/redshift-dg.pdf#c_PLpgSQL-statements" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,cluster,data warehouse,developer,sample data,database,database developer,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Database Developer Guide",
        "item" : "https://docs.aws.amazon.com/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Creating stored procedures in Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/latest/dg/stored-procedure-overview.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "PL/pgSQL language reference",
        "item" : "https://docs.aws.amazon.com/redshift/latest/dg/c_pl_pgSQL_reference.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "Supported PL/pgSQL statements",
        "item" : "https://docs.aws.amazon.com/redshift/latest/dg/c_pl_pgSQL_reference.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="/pdfs/redshift/latest/dg/redshift-dg.pdf#c_PLpgSQL-statements" target="_blank" rel="noopener noreferrer" title="Open PDF"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Documentation</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">Database Developer Guide</a></div><div id="page-toc-src"><a href="#r_PLpgSQL-assignment">Assignment</a><a href="#r_PLpgSQL-select-into">SELECT INTO</a><a href="#r_PLpgSQL-no-op">No-op</a><a href="#r_PLpgSQL-dynamic-sql">Dynamic SQL</a><a href="#r_PLpgSQL-return">Return</a><a href="#r_PLpgSQL-conditionals-if">Conditionals: IF </a><a href="#r_PLpgSQL-conditionals-case">Conditionals: CASE</a><a href="#r_PLpgSQL-loops">Loops</a><a href="#r_PLpgSQL-cursors">Cursors</a><a href="#r_PLpgSQL-messages-errors">RAISE</a><a href="#r_PLpgSQL-transaction-control">Transaction control</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="c_PLpgSQL-statements">Supported PL/pgSQL statements</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p> PL/pgSQL statements augment SQL commands with procedural constructs, including
      looping and conditional expressions, to control logical flow. Most SQL commands can be used,
      including data manipulation language (DML) such as COPY, UNLOAD, and INSERT, and data
      definition language (DDL) such as CREATE TABLE. For a list of comprehensive SQL commands, see
        <a href="./c_SQL_commands.html">SQL commands</a>. In addition, the following
      PL/pgSQL statements are supported by Amazon Redshift. </p><div class="highlights" id="inline-topiclist"><h6>Topics</h6><ul><li><a href="#r_PLpgSQL-assignment">Assignment</a></li><li><a href="#r_PLpgSQL-select-into">SELECT INTO</a></li><li><a href="#r_PLpgSQL-no-op">No-op</a></li><li><a href="#r_PLpgSQL-dynamic-sql">Dynamic SQL</a></li><li><a href="#r_PLpgSQL-return">Return</a></li><li><a href="#r_PLpgSQL-conditionals-if">Conditionals: IF</a></li><li><a href="#r_PLpgSQL-conditionals-case">Conditionals: CASE</a></li><li><a href="#r_PLpgSQL-loops">Loops</a></li><li><a href="#r_PLpgSQL-cursors">Cursors</a></li><li><a href="#r_PLpgSQL-messages-errors">RAISE</a></li><li><a href="#r_PLpgSQL-transaction-control">Transaction control</a></li></ul></div>
            <h2 id="r_PLpgSQL-assignment">Assignment</h2>  
            
            <p>The assignment statement assigns a value to a variable. The expression must return
        a single value.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">identifier := expression;</code></pre>
            
            <p>Using the nonstandard <code class="code">=</code> for assignment, instead of <code class="code">:=</code>,
        is also accepted.</p>
            
           <p>If the data type of the expression doesn't match the variable's data type or the variable has a size or precision, the result value
            is implicitly converted.</p>
      <p>The following shows examples.</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">customer_number := 20;
tip := subtotal * 0.15;</code></pre>
            
          
            <h2 id="r_PLpgSQL-select-into">SELECT INTO</h2> 
            
           
            <p>The SELECT INTO statement assigns the result of multiple columns (but only one
        row) into a record variable or list of scalar variables.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">SELECT INTO <code class="replaceable">target</code> <code class="replaceable">select_expressions</code> FROM ...;</code></pre>  
            
            
            <p>In the preceding syntax, <code class="replaceable">target</code> can be a record variable or a
        comma-separated list of simple variables and record fields. The
          <code class="replaceable">select_expressions</code> list and the remainder of the command are the same as
        in regular SQL.</p>
            <p>If a variable list is used as <code class="replaceable">target</code>, the selected
        values must exactly match the structure of the target, or a runtime error occurs. When a
        record variable is the target, it automatically configures itself to the row type of the
        query result columns.</p>
            <p>The INTO clause can appear almost anywhere in the SELECT statement. It usually
        appears just after the SELECT clause, or just before FROM clause. That is, it appears just
        before or just after the <code class="replaceable">select_expressions</code> list.</p>
            <p>If the query returns zero rows, NULL values are assigned to
          <code class="replaceable">target</code>. If the query returns multiple rows, the first row is
        assigned to <code class="replaceable">target</code> and the rest are discarded. Unless the
        statement contains an ORDER BY, the first row is not deterministic.</p>
            <p>To determine whether the assignment returned at least one row, use the special FOUND variable.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">SELECT INTO customer_rec * FROM cust WHERE custname = lname;
IF NOT FOUND THEN
  RAISE EXCEPTION 'employee % not found', lname;
END IF;
</code></pre>
            
            <p>To test whether a record result is null, you can use the IS NULL conditional.
        There is no way to determine whether any additional rows might have been discarded. The
        following example handles the case where no rows have been returned.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE select_into_null(return_webpage OUT varchar(256))
AS $$
DECLARE
  customer_rec RECORD;
BEGIN
  SELECT INTO customer_rec * FROM users WHERE user_id=3;
  IF customer_rec.webpage IS NULL THEN
    -- user entered no webpage, return "http://"
    return_webpage = 'http://';
  END IF;
END;
$$ LANGUAGE plpgsql;         
</code></pre>
            
          
            <h2 id="r_PLpgSQL-no-op">No-op</h2>  
           
            <p>The no-op statement (<code class="code">NULL;</code>) is a placeholder statement that does
        nothing. A no-op statement can indicate that one branch of an IF-THEN-ELSE chain is
        empty.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">NULL;</code></pre> 
 
 
            
          
            <h2 id="r_PLpgSQL-dynamic-sql">Dynamic SQL</h2>  
            
            <p>To generate dynamic commands that can involve different tables or different data
        types each time they are run from a PL/pgSQL stored procedure, use the <code class="code">EXECUTE</code>
        statement.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">EXECUTE <code class="replaceable">command-string</code> [ INTO target ];</code></pre> 
            
            <p>In the preceding, <code class="replaceable">command-string</code> is an expression
        yielding a string (of type text) that contains the command to be run. This
          <code class="replaceable">command-string</code> value is sent to the SQL engine. No substitution
        of PL/pgSQL variables is done on the command string. The values of variables must be
        inserted in the command string as it is constructed.</p>
           
           <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>You can't use COMMIT and ROLLBACK statements from within dynamic SQL. For information about
          using COMMIT and ROLLBACK statements within a stored procedure, see <a href="./stored-procedure-transaction-management.html">Managing transactions</a>. </p></div></div> 
            
            <p>When working with dynamic commands, you often have to handle escaping of single
        quotation marks. We recommend enclosing fixed text in quotation marks in your function body
        using dollar quoting. Dynamic values to insert into a constructed query require special
        handling because they might themselves contain quotation marks. The following example
        assumes dollar quoting for the function as a whole, so the quotation marks don't need
        to be doubled.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">EXECUTE 'UPDATE tbl SET '
  || quote_ident(colname)
  || ' = '
  || quote_literal(newvalue)
  || ' WHERE key = '
  || quote_literal(keyvalue);               
</code></pre>
            
            <p>The preceding example shows the functions <code class="code">quote_ident(text)</code> and
          <code class="code">quote_literal(text)</code>. This example passes variables that contain column and
        table identifiers to the <code class="code">quote_ident</code> function. It also passes variables that
        contain literal strings in the constructed command to the <code class="code">quote_literal</code>
        function. Both functions take the appropriate steps to return the input text enclosed in
        double or single quotation marks respectively, with any embedded special characters properly
        escaped.</p>
            <p>Dollar quoting is only useful for quoting fixed text. Don't write the
        preceding example in the following format.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">EXECUTE 'UPDATE tbl SET '
  || quote_ident(colname)
  || ' = $$'
  || newvalue
  || '$$ WHERE key = '
  || quote_literal(keyvalue);               
</code></pre>
            
            <p>You don't do this because the example breaks if the contents of
          <code class="code">newvalue</code> happen to contain $$. The same problem applies to any other
        dollar-quoting delimiter that you might choose. To safely quote text that is not known in
        advance, use the <code class="code">quote_literal</code> function.</p>
            
          
            <h2 id="r_PLpgSQL-return">Return</h2>   
            
            <p>The RETURN statement returns back to the caller from a stored procedure.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">RETURN;</code></pre>
            
            <p>The following shows an example.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE return_example(a int)
AS $$  
BEGIN
  FOR b in 1..10 LOOP
    IF b &lt; a THEN
      RAISE INFO 'b = %', b;
    ELSE
      RETURN;
    END IF;
  END LOOP;
END;
$$ LANGUAGE plpgsql;               
</code></pre>
            
          
            <h2 id="r_PLpgSQL-conditionals-if">Conditionals: IF</h2>  
           
           
            
            <p>The IF conditional statement can take the following forms in the PL/pgSQL language
        that Amazon Redshift uses:</p>
            
            
            <div class="itemizedlist">
                
               
               
               
                  

                
            
            <ul class="itemizedlist"><li class="listitem"><p>IF ... THEN</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
END IF;
</code></pre>
                  
            <p>The following shows an example.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF v_user_id &lt;&gt; 0 THEN
  UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;               
</code></pre>
            
            </li><li class="listitem"><p>IF ... THEN ... ELSE</p>
 <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
ELSE
  statements
END IF;
</code></pre>
                  
               <p>The following shows an example.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF parentid IS NULL OR parentid = ''
THEN
  return_name = fullname;
  RETURN;
ELSE
  return_name = hp_true_filename(parentid) || '/' || fullname;
  RETURN;
END IF;           
</code></pre>
                  
               </li><li class="listitem"><p>IF ... THEN ... ELSIF ... THEN ... ELSE </p>
                  <p>The key word ELSIF can also be spelled ELSEIF.</p>                  
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
[ ELSIF boolean-expression THEN
  statements
[ ELSIF boolean-expression THEN
  statements
    ...] ]
[ ELSE
  statements ]
END IF;
</code></pre>                  
               

               
               <p>The following shows an example.</p>
               
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF number = 0 THEN
  result := 'zero';
ELSIF number &gt; 0 THEN
  result := 'positive';
ELSIF number &lt; 0 THEN
  result := 'negative';
ELSE
  -- the only other possibility is that number is null
  result := 'NULL';
END IF;                  
</code></pre>
               </li></ul></div>
            
           
            
          
            <h2 id="r_PLpgSQL-conditionals-case">Conditionals: CASE</h2>  
           <p>The CASE conditional statement can take the following forms in the PL/pgSQL language
             that Amazon Redshift uses:</p>
            <div class="itemizedlist">
                
                 

            <ul class="itemizedlist"><li class="listitem"><p>Simple CASE </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CASE <code class="replaceable">search-expression</code>
WHEN <code class="replaceable">expression</code> [, <code class="replaceable">expression</code> [ ... ]] THEN
  <code class="replaceable">statements</code>
[ WHEN <code class="replaceable">expression</code> [, <code class="replaceable">expression</code> [ ... ]] THEN
  <code class="replaceable">statements</code>
  ... ]
[ ELSE
  <code class="replaceable">statements</code> ]
END CASE;
</code></pre>
                  
                  <p>A simple CASE statement provides conditional execution based on equality of
            operands.</p>
                  
                  <p>The <code class="replaceable">search-expression</code> value is evaluated one time
            and successively compared to each <code class="replaceable">expression</code> in the WHEN
            clauses. If a match is found, then the corresponding
              <code class="replaceable">statements</code> run, and then control passes to the next
                    statement after END CASE. Subsequent WHEN expressions aren't evaluated. If no match is
            found, the ELSE <code class="replaceable">statements</code> run. However, if ELSE isn't
            present, then a CASE_NOT_FOUND exception is raised.</p>
                  
               <p>The following shows an example.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CASE x
WHEN 1, 2 THEN
  msg := 'one or two';
ELSE
  msg := 'other value than one or two';
END CASE;                  
</code></pre>
                  
               </li><li class="listitem"><p>Searched CASE </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CASE
WHEN <code class="replaceable">boolean-expression</code> THEN
  statements
[ WHEN <code class="replaceable">boolean-expression</code> THEN
  statements
  ... ]
[ ELSE
  statements ]
END CASE;
</code></pre>
                  
                  <p>The searched form of CASE provides conditional execution based on truth of Boolean expressions. </p>
                  
                  <p>Each WHEN clause's <code class="replaceable">boolean-expression</code> is
            evaluated in turn, until one is found that yields true. Then the corresponding
            statements run, and then control passes to the next statement after END CASE. Subsequent
            WHEN <code class="replaceable">expressions</code> aren't evaluated. If no true result is
            found, the ELSE <code class="replaceable">statements</code> are run. However, if ELSE
            isn't present, then a CASE_NOT_FOUND exception is raised.</p>
                  
                  <p>The following shows an example.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CASE
WHEN x BETWEEN 0 AND 10 THEN
  msg := 'value is between zero and ten';
WHEN x BETWEEN 11 AND 20 THEN
  msg := 'value is between eleven and twenty';
END CASE;                                
</code></pre>
                  
               </li></ul></div>                      
            
          
            <h2 id="r_PLpgSQL-loops">Loops</h2>  
            
           <p>Loop statements can take the following forms in the PL/pgSQL language that Amazon Redshift
        uses:</p>
            <div class="itemizedlist">
                
               
                 
               
                 
               
                
               
                 
               
                 
               
               
               
                                  
               
               
            <ul class="itemizedlist"><li class="listitem"><p>Simple loop </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
LOOP
  statements
END LOOP [ label ];
</code></pre>
                  
                  <p>A simple loop defines an unconditional loop that is repeated indefinitely
            until terminated by an EXIT or RETURN statement. The optional label can be used by EXIT
            and CONTINUE statements within nested loops to specify which loop the EXIT and CONTINUE
            statements refer to.</p>
                  
               <p>The following shows an example.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE simple_loop()
LANGUAGE plpgsql
AS $$
BEGIN
  &lt;&lt;simple_while&gt;&gt;
  LOOP
    RAISE INFO 'I am raised once';  
    EXIT simple_while;
    RAISE INFO 'I am not raised';
  END LOOP;
  RAISE INFO 'I am raised once as well';
END;
$$;                
</code></pre>

               </li><li class="listitem"><p>Exit loop</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">EXIT [ <code class="replaceable">label</code> ] [ WHEN <code class="replaceable">expression</code> ];
</code></pre> 
                 <p>If <code class="replaceable">label</code> isn't present, the innermost loop is
            terminated and the statement following the END LOOP runs next. If
              <code class="replaceable">label</code> is present, it must be the label of the current or
            some outer level of nested loop or block. Then, the named loop or block is terminated
            and control continues with the statement after the loop or block corresponding
            END.</p>
                  <p>If WHEN is specified, the loop exit occurs only if <code class="replaceable">expression</code> is true. Otherwise, control passes to the statement after EXIT.</p>
                  <p>You can use EXIT with all types of loops; it isn't limited to use with
            unconditional loops.</p>
                  <p>When used with a BEGIN block, EXIT passes control to the next statement
            after the end of the block. A label must be used for this purpose. An unlabeled EXIT is
            never considered to match a BEGIN block.</p>
                  <p>The following shows an example.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE simple_loop_when(x int)
LANGUAGE plpgsql
AS $$
DECLARE i INTEGER := 0;
BEGIN
  &lt;&lt;simple_loop_when&gt;&gt;
  LOOP
    RAISE INFO 'i %', i;
    i := i + 1;
    EXIT simple_loop_when WHEN (i &gt;= x);
  END LOOP;
END;
$$;                     
</code></pre>
               </li><li class="listitem"><p>Continue loop </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CONTINUE [ <code class="replaceable">label</code> ] [ WHEN <code class="replaceable">expression</code> ];
</code></pre> 
                  <p>If <code class="replaceable">label</code> is not given, the execution jumps to the
            next iteration of the innermost loop. That is, all statements remaining in the loop body
            are skipped. Control then returns to the loop control expression (if any) to determine
            whether another loop iteration is needed. If <code class="replaceable">label</code> is
            present, it specifies the label of the loop whose execution is continued.</p>
                  <p>If WHEN is specified, the next iteration of the loop is begun only if <code class="replaceable">expression</code> is true. Otherwise, control passes to the statement after CONTINUE.</p>
                  <p>You can use CONTINUE with all types of loops; it isn't limited to use
            with unconditional loops.</p>
                  
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CONTINUE mylabel;
</code></pre> 
                  
               </li><li class="listitem"><p>WHILE loop </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
WHILE expression LOOP
  statements
END LOOP [ label ];
</code></pre> 
                  
               <p>The WHILE statement repeats a sequence of statements so long as the <code class="replaceable">boolean-expression</code> evaluates to true. The expression is checked just before each entry to the loop body.</p> 
               <p>The following shows an example.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
  -- some computations here
END LOOP;

WHILE NOT done LOOP
  -- some computations here
END LOOP;                  
</code></pre>
               </li><li class="listitem"><p>FOR loop (integer variant) </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR name IN [ REVERSE ] expression .. expression LOOP
  statements
END LOOP [ label ];
</code></pre> 
                  
                  <p>The FOR loop (integer variant) creates a loop that iterates over a range of
            integer values. The variable name is automatically defined as type integer and exists
            only inside the loop. Any existing definition of the variable name is ignored within the
            loop. The two expressions giving the lower and upper bound of the range are evaluated
            one time when entering the loop. 
            If you specify REVERSE, then the step value is subtracted, rather than added, after each
            iteration.</p> 
                  
                  <p>If the lower bound is greater than the upper bound (or less than, in the
            REVERSE case), the loop body doesn't run. No error is raised.</p>
                  
                  <p>If a label is attached to the FOR loop, then you can reference the integer
            loop variable with a qualified name, using that label.</p>
                  
               <p>The following shows an example.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">FOR i IN 1..10 LOOP
  -- i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop
END LOOP;

FOR i IN REVERSE 10..1 LOOP
  -- i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop
END LOOP;                
</code></pre>  

               </li><li class="listitem"><p>FOR loop (result set variant) </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR <code class="replaceable">target</code> IN query LOOP
  statements
END LOOP [ label ];
</code></pre>
                  <p>The <code class="replaceable">target</code> is a record variable or
            comma-separated list of scalar variables. The target is successively assigned each row
            resulting from the query, and the loop body is run for each row.</p> 
                  
                  <p>The FOR loop (result set variant) enables a stored procedure to iterate through the results of a query and manipulate that data
                     accordingly.</p>
                  <p>The following shows an example.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE PROCEDURE cs_refresh_reports() AS $$
DECLARE
  reports RECORD;
BEGIN
  FOR reports IN SELECT * FROM cs_reports ORDER BY sort_key LOOP
    -- Now "reports" has one record from cs_reports
    EXECUTE 'TRUNCATE TABLE ' || quote_ident(reports.report_name);
    EXECUTE 'INSERT INTO ' || quote_ident(reports.report_name) || ' ' || reports.report_query;
  END LOOP;
  RETURN;
END;
$$ LANGUAGE plpgsql;                   
</code></pre>
               </li><li class="listitem"><p>FOR loop with dynamic SQL</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR record_or_row IN EXECUTE text_expression LOOP 
  statements
END LOOP;
</code></pre>
                  
                  <p>A FOR loop with dynamic SQL enables a stored procedure to iterate through the results of a dynamic query and
                     manipulate that data accordingly.</p>  
                  
               <p>The following shows an example.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE for_loop_dynamic_sql(x int)
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  query text;
BEGIN
  query := 'SELECT * FROM tbl_dynamic_sql LIMIT ' || x;
  FOR rec IN EXECUTE query
  LOOP
    RAISE INFO 'a %', rec.a;
  END LOOP;
END;
$$;</code></pre>
               </li></ul></div>                      
            
          
            <h2 id="r_PLpgSQL-cursors">Cursors</h2>  
            
            <p>Rather than running a whole query at once, you can set up a cursor. A <em>cursor </em>encapsulates a query and reads the query result a few rows
        at a time. One reason for doing this is to avoid memory overrun when the result contains a
        large number of rows. Another reason is to return a reference to a cursor that a stored
        procedure has created, which allows the caller to read the rows. This approach provides an
        efficient way to return large row sets from stored procedures.</p>
           
           <p>To use cursors in a NONATOMIC stored procedure, place the cursor loop between START TRANSACTION...COMMIT.</p>

            
            
            
            

               <p>To set up a cursor, first you declare a cursor variable. All access to cursors
        in PL/pgSQL goes through cursor variables, which are always of the special data type
          <code class="code">refcursor</code>. A <code class="code">refcursor</code> data type simply holds a reference to a
        cursor. </p>
      <p>You can create a cursor variable by declaring it as a variable of type
          <code class="code">refcursor</code>. Or, you can use the cursor declaration syntax following.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">name CURSOR [ ( <code class="replaceable">arguments</code> ) ] FOR <code class="replaceable">query</code> ;
</code></pre> 
                  <p>In the preceding, <code class="replaceable">arguments</code> (if specified) is a
        comma-separated list of <code class="replaceable">name datatype</code> pairs that each define
        names to be replaced by parameter values in <code class="replaceable">query</code>. The actual
        values to substitute for these names are specified later, when the cursor is opened.</p>
                  <p>The following shows examples.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">DECLARE
  curs1 refcursor;
  curs2 CURSOR FOR SELECT * FROM tenk1;
  curs3 CURSOR (key integer) IS SELECT * FROM tenk1 WHERE unique1 = key;                     
</code></pre>
                  <p>All three of these variables have the data type <code class="code">refcursor</code>, but
        the first can be used with any query. In contrast, the second has a fully specified query
        already bound to it, and the last has a parameterized query bound to it. The
          <code class="code">key</code> value is replaced by an integer parameter value when the
        cursor is opened. The variable <code class="code">curs1</code> is said to be <em>unbound </em>because it is not bound to any particular query.</p>
               
              <p>Before you can use a cursor to retrieve rows, it must be opened. PL/pgSQL has
        three forms of the OPEN statement, of which two use unbound cursor variables and the third
        uses a bound cursor variable:</p>
           <div class="itemizedlist">
              
              
              
           <ul class="itemizedlist"><li class="listitem">
                          <p>Open for select: The cursor variable is opened and given the
            specified query to run. The cursor can't be open already. Also, it must have been
            declared as an unbound cursor (that is, as a simple <code class="code">refcursor</code> variable).
            The SELECT query is treated in the same way as other SELECT statements in PL/pgSQL. </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN cursor_name FOR SELECT ...;                     
</code></pre> 
                  <p>The following shows an example.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;    
</code></pre>
             </li><li class="listitem">
                  <p>Open for execute: The cursor variable is opened and given the specified
            query to run. The cursor can't be open already. Also, it must have been declared as
            an unbound cursor (that is, as a simple <code class="code">refcursor</code> variable). The query is
            specified as a string expression in the same way as in the EXECUTE command. This
            approach gives flexibility so the query can vary from one run to the next.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN cursor_name FOR EXECUTE query_string;
</code></pre>
                  <p>The following shows an example.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs1 FOR EXECUTE 'SELECT * FROM ' || quote_ident($1);</code></pre>                 
             </li><li class="listitem">
                  <p>Open a bound cursor: This form of OPEN is used to open a cursor variable
            whose query was bound to it when it was declared. The cursor can't be open already.
            A list of actual argument value expressions must appear if and only if the cursor was
            declared to take arguments. These values are substituted in the query. </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN bound_cursor_name [ ( argument_values ) ];
</code></pre>

                  <p>The following shows an example.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs2;
OPEN curs3(42);
</code></pre>                            
             </li></ul></div>
                  <p>After a cursor has been opened, you can work with it by using the statements
        described following. These statements don't have to occur in the same stored procedure
        that opened the cursor. You can return a <code class="code">refcursor</code> value out of a stored
        procedure and let the caller operate on the cursor. All portals are implicitly closed at
        transaction end. Thus, you can use a <code class="code">refcursor</code> value to reference an open
        cursor only until the end of the transaction.</p>
           <div class="itemizedlist">
              
              
           <ul class="itemizedlist"><li class="listitem">
                  <p>FETCH retrieves the next row from the cursor into a target. This target can
            be a row variable, a record variable, or a comma-separated list of simple variables,
            just as with SELECT INTO. As with SELECT INTO, you can check the special variable FOUND
            to see whether a row was obtained.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">FETCH cursor INTO target;
</code></pre> 
                  <p>The following shows an example.</p> 
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">FETCH curs1 INTO rowvar;</code></pre>               
             </li><li class="listitem">
                  <p>CLOSE closes the portal underlying an open cursor. You can use this
            statement to release resources earlier than end of the transaction. You can also use
            this statement to free the cursor variable to be opened again.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CLOSE cursor;
</code></pre>
                <p>The following shows an example.</p> 
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CLOSE curs1;</code></pre>               
             </li></ul></div>
             
          
            <h2 id="r_PLpgSQL-messages-errors">RAISE</h2>
           
           
           <p>Use the <code class="code">RAISE level</code> statement to report messages and raise errors.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE level 'format' [, variable [, ...]];</code></pre>
            <p>Possible levels are NOTICE, INFO, LOG, WARNING, and EXCEPTION. EXCEPTION raises an
        error, which normally cancels the current transaction. The other levels generate only
        messages of different priority levels. </p>
           <p>Inside the format string, % is replaced by the next optional argument's string
        representation. Write %% to emit a literal %. Currently, optional arguments must be simple
        variables, not expressions, and the format must be a simple string literal.</p>
            <p>In the following example, the value of <code class="code">v_job_id</code> replaces the % in the
        string.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;</code></pre>
            
           
            
           <p>Use the <code class="code">RAISE</code> statement to re-throw the exception caught by an exception handling block. 
             This statement is only valid in exception handling blocks of NONATOMIC mode stored procedures.</p>
           <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE;</code></pre>
          
          <h2 id="r_PLpgSQL-transaction-control">Transaction control</h2>
          <p>You can work with transaction control statements in the PL/pgSQL language that
        Amazon Redshift uses. For information about using the statements COMMIT, ROLLBACK, and TRUNCATE
        within a stored procedure, see <a href="./stored-procedure-transaction-management.html">Managing transactions</a>. </p>  
          
          <p>In NONATOMIC mode stored procedures, use <code class="code">START TRANSACTION</code> to start a transaction block.</p>
          <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">START TRANSACTION;</code></pre>
          <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>The PL/pgSQL statement START TRANSACTION is different from the SQL command START TRANSACTION in the following ways:</p><div class="itemizedlist">
               
               
            <ul class="itemizedlist"><li class="listitem"><p>Within stored procedures, START TRANSACTION is not synonymous with BEGIN.</p></li><li class="listitem"><p>The PL/pgSQL statement does not support optional isolation level and access permission keywords.</p></li></ul></div></div></div>

          
        <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Warning" /> <strong>Javascript is disabled or is unavailable in your browser.</strong></p><p>To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Document Conventions</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./c_PLpgSQL-structure.html">Structure of PL/pgSQL</div><div id="next" class="next-link" accesskey="n" href="./materialized-view-overview.html">Creating materialized views</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">Did this page help you? - Yes</div><div class="content"><p>Thanks for letting us know we're doing a good job!</p><p>If you've got a moment, please tell us what we did right so we can do more of it.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/c_PLpgSQL-statements.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">Did this page help you? - No</div><div class="content"><p>Thanks for letting us know this page needs work. We're sorry we let you down.</p><p>If you've got a moment, please tell us how we can make the documentation better.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/c_PLpgSQL-statements.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>