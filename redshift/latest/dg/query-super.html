<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Querying semistructured data - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="query-super" /><meta name="default_state" content="query-super" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/redshift/latest/dg/query-super.html" /><meta name="description" content="In Amazon Redshift, you can work with the PartiQL language for SQL-compatible access to semistructured data." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="Database Developer Guide" /><meta name="abstract" content="Create and manage a data warehouse with Amazon Redshift, an enterprise-level, petabyte scale, fully managed data warehousing service." /><meta name="guide-locale" content="en_us" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/redshift/latest/dg/query-super.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/query-super.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/query-super.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/query-super.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/query-super.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/query-super.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/query-super.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/query-super.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/query-super.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/query-super.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/query-super.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/query-super.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/query-super.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/query-super.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/query-super.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/query-super.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/query-super.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/query-super.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/query-super.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/query-super.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/query-super.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/query-super.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="Database Developer Guide" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="Database Developer Guide" /><meta id="panorama-serviceConsolePage" value="Querying semistructured data" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Querying semistructured data - Amazon Redshift</title><meta name="pdf" content="/pdfs/redshift/latest/dg/redshift-dg.pdf#query-super" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/query-super.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/query-super.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/query-super.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,cluster,data warehouse,developer,sample data,database,database developer,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Database Developer Guide",
        "item" : "https://docs.aws.amazon.com/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Ingesting and querying semistructured data in Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/latest/dg/super-overview.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Querying semistructured data",
        "item" : "https://docs.aws.amazon.com/redshift/latest/dg/super-overview.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="/pdfs/redshift/latest/dg/redshift-dg.pdf#query-super" target="_blank" rel="noopener noreferrer" title="Open PDF"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Documentation</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">Database Developer Guide</a></div><div id="page-toc-src"><a href="#navigation">Navigation</a><a href="#unnest">Unnesting queries</a><a href="#unpivoting">Object unpivoting</a><a href="#dynamic-typing-lax-processing">Dynamic typing</a><a href="#lax-semantics">Lax semantics</a><a href="#introspection">Types of introspection</a><a href="#order-by">Order by</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="query-super">Querying semistructured data</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p>Amazon Redshift uses the PartiQL language to offer SQL-compatible access to relational,
         semistructured, and nested data. </p><p>PartiQL operates with dynamic types. This approach enables intuitive filtering, joining,
         and aggregation on the combination of structured, semistructured, and nested datasets. The
         PartiQL syntax uses dotted notation and array subscript for path navigation when accessing
         nested data. It also enables the FROM clause items to iterate over arrays and use for
         unnest operations. Following, you can find descriptions of the different query patterns
         that combine the use of the SUPER data type with path and array navigation, unnesting,
         unpivoting, and joins. </p><p>
         For information on the tables used in the following example, see <a href="./r_SUPER_sample_dataset.html">SUPER sample dataset</a>.
      </p>
         <h2 id="navigation">Navigation</h2>
         <p>Amazon Redshift uses PartiQL to enable navigation into arrays and structures using the [...]
            bracket and dot notation respectively. Furthermore, you can mix navigation into
            structures using the dot notation and arrays using the bracket notation. For example,
            the following example assumes that the <code class="code">c_orders</code> SUPER data column is an
            array with a structure and an attribute is named <code class="code">o_orderkey</code>.</p>
         <p>To ingest data in the <code class="code">customer_orders_lineitem</code> table, run the following command.
            Replace the IAM role with your own credentials.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">COPY customer_orders_lineitem FROM 's3://redshift-downloads/semistructured/tpch-nested/data/json/customer_orders_lineitem'
REGION 'us-east-1' IAM_ROLE 'arn:aws:iam::xxxxxxxxxxxx:role/Redshift-S3'
FORMAT JSON 'auto';

SELECT c_orders[0].o_orderkey FROM customer_orders_lineitem;</code></pre>

         <p>Amazon Redshift also uses a table alias as a prefix to the notation. The following example
            is the same query as the previous example.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT cust.c_orders[0].o_orderkey FROM customer_orders_lineitem AS cust;</code></pre>
         
      <p>You can use the dot and bracket notations in all types of queries, such as filtering,
            join, and aggregation. You can use these notations in a query in which there are
            normally column references. The following example uses a SELECT statement that filters
            results.</p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT count(*) FROM customer_orders_lineitem WHERE c_orders[0]. o_orderkey IS NOT NULL;</code></pre>
         
         <p>The following example uses the bracket and dot navigation in both GROUP BY and ORDER
            BY clauses.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c_orders[0].o_orderdate,
       c_orders[0].o_orderstatus,
       count(*)
FROM customer_orders_lineitem
WHERE c_orders[0].o_orderkey IS NOT NULL
GROUP BY c_orders[0].o_orderstatus,
         c_orders[0].o_orderdate
ORDER BY c_orders[0].o_orderdate;</code></pre>
    
         <h2 id="unnest">Unnesting queries</h2>
         <p>To unnest queries, Amazon Redshift uses the PartiQL syntax to iterate over SUPER arrays. It
            does this by navigating the array using the FROM clause of a query. Using the previous
            example, the following example iterates over the attribute values for
               <code class="code">c_orders</code>.</p>
         
       <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.*, o FROM customer_orders_lineitem c, c.c_orders o;</code></pre>
         <p>The unnesting syntax is an extension of the FROM clause. In standard SQL, the FROM clause <code class="code">x (AS) y</code> means that <code class="code">y</code> iterates over each tuple in relation <code class="code">x</code>. In this case, <code class="code">x</code> refers to a relation and <code class="code">y</code> refers to an alias for relation <code class="code">x</code>. Similarly, the PartiQL syntax of unnesting using the FROM clause item <code class="code">x (AS) y</code> means that <code class="code">y</code> iterates over each (SUPER) value in (SUPER) array expression x. In this case, <code class="code">x</code> is a SUPER expression and <code class="code">y</code> is an alias for <code class="code">x</code>.</p>

         <p>The left operand can also use the dot and bracket notation for regular navigation. In
            the previous example, <code class="code">customer_orders_lineitem c</code> is the iteration over the
               <code class="code">customer_order_lineitem</code> base table and <code class="code">c.c_orders o</code> is the
            iteration over the <code class="code">c.c_orders</code> array. To iterate over the
               <code class="code">o_lineitems</code> attribute, which is an array within an array, you add
            multiple clauses.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.*, o, l FROM customer_orders_lineitem c, c.c_orders o, o.o_lineitems l;</code></pre>
         <p>Amazon Redshift also supports an array index when iterating over the array using the AT
            keyword. The clause <code class="code">x AS y AT z</code> iterates over array <code class="code">x</code> and
            generates the field <code class="code">z,</code> which is the array index. The following example
            shows how an array index works.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c_name,
       orders.o_orderkey AS orderkey,
       index AS orderkey_index
FROM customer_orders_lineitem c, c.c_orders AS orders AT index 
ORDER BY orderkey_index;

c_name             | orderkey | orderkey_index
-------------------+----------+----------------
Customer#000008251 | 3020007  |        0
Customer#000009452 | 4043971  |        0
  (2 rows)</code></pre>
         <p>The following example iterates over a scalar array.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">CREATE TABLE bar AS SELECT json_parse('<span>{</span>"scalar_array": [1, 2.3, 45000000]}') AS data;

SELECT index, element FROM bar AS b, b.data.scalar_array AS element AT index;

 index | element
-------+----------
     0 | 1
     1 | 2.3
     2 | 45000000
(3 rows)</code></pre>
         
         <p>The following example iterates over an array of multiple levels. The example uses
            multiple unnest clauses to iterate into the innermost arrays. The
               <code class="code">f.multi_level_array</code> AS array iterates over
               <code class="code">multi_level_array</code>. The array AS element is the iteration over the arrays
            within  <code class="code">multi_level_array</code>.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">CREATE TABLE foo AS SELECT json_parse('[[1.1, 1.2], [2.1, 2.2], [3.1, 3.2]]') AS multi_level_array;

SELECT array, element FROM foo AS f, f.multi_level_array AS array, array AS element;

   array   | element
-----------+---------
 [1.1,1.2] | 1.1
 [1.1,1.2] | 1.2
 [2.1,2.2] | 2.1
 [2.1,2.2] | 2.2
 [3.1,3.2] | 3.1
 [3.1,3.2] | 3.2
(6 rows)</code></pre>
         <p>For more information about the FROM clause, see <a href="./r_FROM_clause30.html">FROM clause</a>.</p>
       
         <h2 id="unpivoting">Object unpivoting</h2>
         <p>To perform object unpivoting, Amazon Redshift uses the PartiQL syntax to iterate over SUPER
            objects. It does this using the FROM clause of a query with the UNPIVOT keyword. The
            following query iterates over the <code class="code">c.c_orders[0]</code> object.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT attr as attribute_name, json_typeof(val) as value_type 
FROM customer_orders_lineitem c, UNPIVOT c.c_orders[0] AS val AT attr 
WHERE c_custkey = 9451;

 attribute_name  | value_type
-----------------+------------
 o_orderstatus   | string
 o_clerk         | string
 o_lineitems     | array
 o_orderdate     | string
 o_shippriority  | number
 o_totalprice    | number
 o_orderkey      | number
 o_comment       | string
 o_orderpriority | string
(9 rows)</code></pre>
         <p>As with unnesting, the unpivoting syntax is also an extension of the FROM clause. The
            difference is that the unpivoting syntax uses the UNPIVOT keyword to indicate that
            it's iterating over an object instead of an array. It uses the AS
               <code class="code">value_alias</code> for iteration over all the values inside an object and uses
            the AT <code class="code">attribute_alias</code> for iterating over all the attributes.</p>
           <p>Amazon Redshift also supports using object unpivoting and array unnesting in a single FROM
            clause as follows.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT attr as attribute_name, val as object_value
FROM customer_orders_lineitem c, c.c_orders AS o, UNPIVOT o AS val AT attr 
WHERE c_custkey = 9451;</code></pre>
         <p>When you use object unpivoting, Amazon Redshift doesn't support correlated unpivoting.
            Specifically, suppose that you have a case where there are multiple examples of
            unpivoting in different query levels and the inner unpivoting references the outer one.
            Amazon Redshift doesn't support this type of multiple unpivoting.</p>
         <p>For more information about the FROM clause, see <a href="./r_FROM_clause30.html">FROM clause</a>. For examples that show how to query structured data, with PIVOT and UNPIVOT, 
            see <a href="./r_FROM_clause-pivot-unpivot-examples.html">PIVOT and UNPIVOT examples</a>.</p>
       
      <h2 id="dynamic-typing-lax-processing">Dynamic typing</h2>
      <p>Dynamic typing doesn't require explicit casting of data that is extracted from the
            dot and bracket paths. Amazon Redshift uses dynamic typing to process schemaless SUPER data
            without the need to declare the data types before you use them in your query. Dynamic
            typing uses the results of navigating into SUPER data columns without having to
            explicitly cast them into Amazon Redshift types. Dynamic typing is most useful in joins and GROUP
            BY clauses. The following example uses a SELECT statement that requires no explicit
            casting of the dot and bracket expressions to the usual Amazon Redshift types. For information about type compatibility and conversion, see <a href="./c_Supported_data_types.html#r_Type_conversion">Type compatibility and conversion</a>.</p>
      
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c_orders[0].o_orderkey
FROM customer_orders_lineitem
WHERE c_orders[0].o_orderstatus = 'P';</code></pre>
      <p>The equality sign in this query evaluates to <code class="code">true</code> when c_orders[0].o_orderstatus is the string ‘P’. In all other cases, the equality sign evaluates to <code class="code">false</code>, including the cases where the arguments of the equality are different types.</p>

      
      
       
         <h3 id="dynamic-typing-lax-processing-dynamic-and-static">Dynamic and static typing</h3>

      <p>Without using dynamic typing, you can't determine whether c_orders[0].o_orderstatus
            is a string, an integer, or a structure. You can only determine that
            c_orders[0].o_orderstatus is a SUPER data type, which can be an Amazon Redshift scalar, an array,
            or a structure. The static type of c_orders[0].o_orderstatus is a SUPER data type.
            Conventionally, a type is implicitly a static type in SQL.</p>
         
         <p>Amazon Redshift uses dynamic typing to the processing of schemaless data. When the query
            evaluates the data, c_orders[0].o_orderstatus turns out to be a specific type. For
            example, evaluating c_orders[0].o_orderstatus on the first record
            of customer_orders_lineitem may result into an integer. Evaluating on the second record
            may result into a string. These are the dynamic types of the expression.</p>
         
        <p>When using an SQL operator or function with dot and bracket expressions that have
            dynamic types, Amazon Redshift produces results similar to using standard SQL operator or
            function with the respective static types. In this example, when the dynamic type of the
            path expression is a string, the comparison with the string ‘P’ is meaningful. Whenever
            the dynamic type of c_orders[0].o_orderstatus is any other data type except being a
            string, the equality returns false. Other functions return null when mistyped arguments
            are used.</p>
      <p>The following example writes the previous query with static typing:</p>
      
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c_custkey
FROM customer_orders_lineitem
WHERE CASE WHEN JSON_TYPEOF(c_orders[0].o_orderstatus) = 'string'
           THEN c_orders[0].o_orderstatus::VARCHAR = 'P'
           ELSE FALSE END;</code></pre>
      <p>Note the following distinction between equality predicates and comparison predicates. In
            the previous example, if you replace the equality predicate with a less-than-or-equal
            predicate, the semantics produce null instead of false.</p>
      
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c_orders[0]. o_orderkey
FROM customer_orders_lineitem
WHERE c_orders[0].o_orderstatus &lt;= 'P';</code></pre>
      <p>In this example, if c_orders[0].o_orderstatus is a string, Amazon Redshift returns true if it
            is alphabetically equal to or smaller than ‘P’. Amazon Redshift returns false if it is
            alphabetically larger than 'P'. However, if c_orders[0].o_orderstatus is not a string,
            Amazon Redshift returns null since Amazon Redshift can't compare values of different types, as shown
            in the following query:</p>
      
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c_custkey
FROM customer_orders_lineitem
WHERE CASE WHEN JSON_TYPEOF(c_orders[0].o_orderstatus) = 'string'
           THEN c_orders[0].o_orderstatus::VARCHAR &lt;= 'P'
           ELSE NULL END;</code></pre>
      <p>Dynamic typing doesn't exclude from comparisons of types that are minimally comparable. For example, you can convert both CHAR and VARCHAR Amazon Redshift scalar types to SUPER. They are comparable as strings, including ignoring trailing white-space characters similar to Amazon Redshift CHAR and VARCHAR types. Similarly, integers, decimals, and floating-point values are comparable as SUPER values. Specifically for decimal columns, each value can also have a different scale. Amazon Redshift still considers them as dynamic types.</p>
      <p>Amazon Redshift also supports equality on objects and arrays that are evaluated as deep equal,
               such as evaluating deep into objects or arrays and comparing all attributes. Use deep
               equal with caution, because the process of performing deep equal can be
               time-consuming.</p>
       
      
       
         <h3 id="dynamic-typing-lax-processing-joins">Using dynamic typing for
                  joins</h3>
      <p>For joins, dynamic typing automatically matches values with different dynamic types
            without performing a long CASE WHEN analysis to find out what data types may appear. For
            example, assume that your organization changed the format that it was using for part
            keys over time.</p>
         <p>The initial integer part keys issued are replaced by string part keys, such as ‘A55’, and later replaced again by array part keys, such as [‘X’, 10] combining a string and a number. Amazon Redshift doesn't have to perform a lengthy case analysis about part keys and can use joins as shown in the following example.</p>
      
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.c_name
    ,l.l_extendedprice
    ,l.l_discount
FROM customer_orders_lineitem c
    ,c.c_orders o
    ,o.o_lineitems l
    ,supplier_partsupp s
    ,s.s_partsupps ps
WHERE l.l_partkey = ps.ps_partkey
AND c.c_nationkey = s.s_nationkey
ORDER BY c.c_name;</code></pre>
      
      <p>The following example shows how complex and inefficient the same query can be without using dynamic typing:</p>
      
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.c_name
    ,l.l_extendedprice
    ,l.l_discount
FROM customer_orders_lineitem c
    ,c.c_orders o
    ,o.o_lineitems l
    ,supplier_partsupp s
    ,s.s_partsupps ps
WHERE CASE WHEN IS_INTEGER(l.l_partkey) AND IS_INTEGER(ps.ps_partkey)
           THEN l.l_partkey::integer = ps.ps_partkey::integer
           WHEN IS_VARCHAR(l.l_partkey) AND IS_VARCHAR(ps.ps_partkey)
           THEN l.l_partkey::varchar = ps.ps_partkey::varchar
           WHEN IS_ARRAY(l.l_partkey) AND IS_ARRAY(ps.ps_partkey)
                AND IS_VARCHAR(l.l_partkey[0]) AND IS_VARCHAR(ps.ps_partkey[0])
                AND IS_INTEGER(l.l_partkey[1]) AND IS_INTEGER(ps.ps_partkey[1])
           THEN l.l_partkey[0]::varchar = ps.ps_partkey[0]::varchar
                AND l.l_partkey[1]::integer = ps.ps_partkey[1]::integer
           ELSE FALSE END
AND c.c_nationkey = s.s_nationkey
ORDER BY c.c_name;</code></pre>
             
      
       
         <h2 id="lax-semantics">Lax semantics</h2>
      <p>By default, navigation operations on SUPER values return null instead of returning an
            error out when the navigation is invalid. Object navigation is invalid if the SUPER
            value is not an object or if the SUPER value is an object but doesn't contain the
            attribute name used in the query. For example, the following query accesses an invalid
            attribute name in the SUPER data column cdata:</p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.c_orders.something FROM customer_orders_lineitem c;</code></pre>
      <p>Array navigation returns null if the SUPER value is not an array or the array index is
            out of bounds. The following query returns null because c_orders[1][1] is out of bounds. </p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.c_orders[1][1] FROM customer_orders_lineitem c;</code></pre>
      <p>Lax semantics is especially useful when using dynamic typing to cast a SUPER value.
            Casting a SUPER value to the wrong type returns null instead of an error if the cast is
            invalid. For example, the following query returns null because it can't cast the
            string value 'Good' of the object attribute o_orderstatus to INTEGER. Amazon Redshift returns
            an error for a VARCHAR to INTEGER cast but not for a SUPER cast.</p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.c_orders.o_orderstatus::integer FROM customer_orders_lineitem c;</code></pre>
       
         <h2 id="introspection">Types of introspection</h2>
      <p>SUPER data columns support inspection functions that return the dynamic type and other
            type information about the SUPER value. The most common example is the JSON_TYPEOF
            scalar function that returns a VARCHAR with values boolean, number, string, object,
            array, or null, depending on the dynamic type of the SUPER value. Amazon Redshift supports the
            following boolean functions for SUPER data columns:</p>
      <div class="itemizedlist">
          
          
          
          
          
          
          
          
                
            
          
          
          
      <ul class="itemizedlist"><li class="listitem"><p>DECIMAL_PRECISION</p></li><li class="listitem"><p>DECIMAL_SCALE</p></li><li class="listitem"><p>IS_ARRAY</p></li><li class="listitem"><p>IS_BIGINT</p></li><li class="listitem"><p>IS_CHAR</p></li><li class="listitem"><p>IS_DECIMAL</p></li><li class="listitem"><p>IS_FLOAT</p></li><li class="listitem"><p>IS_INTEGER</p></li><li class="listitem"><p>IS_OBJECT</p></li><li class="listitem"><p>IS_SCALAR</p></li><li class="listitem"><p>IS_SMALLINT</p></li><li class="listitem"><p>IS_VARCHAR</p></li><li class="listitem"><p>JSON_TYPEOF</p></li></ul></div>
      <p>All these functions return false if the input value is null. IS_SCALAR, IS_OBJECT, and
            IS_ARRAY are mutually exclusive and cover all possible values except for null.</p>
       <p>To infer the types corresponding to the data, Amazon Redshift uses the JSON_TYPEOF function
            that returns the type of (the top level of) the SUPER value as shown in the following
            example:</p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT JSON_TYPEOF(r_nations) FROM region_nations;
 json_typeof
 -------------
 array
(1 row)</code></pre>
         
         
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT JSON_TYPEOF(r_nations[0].n_nationkey) FROM region_nations;
 json_typeof
 -------------
 number</code></pre>
      <p>Amazon Redshift sees this as a single long string, similar to inserting this value into a
            VARCHAR column instead of a SUPER. Since the column is SUPER, the single string is still
            a valid SUPER value and the difference is noted in JSON_TYPEOF:</p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT IS_VARCHAR(r_nations[0].n_name) FROM region_nations;
 is_varchar
-------------
 true
(1 row)</code></pre>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT r_nations[4].n_name FROM region_nations
WHERE CASE WHEN IS_INTEGER(r_nations[4].n_nationkey) 
           THEN r_nations[4].n_nationkey::INTEGER = 15 
           ELSE false END;</code></pre>
    
         <h2 id="order-by">Order by</h2>
         <p>Amazon Redshift doesn't define SUPER comparisons among values with different dynamic types. A SUPER value that is a string is neither smaller nor larger than a SUPER value that is a number. To use ORDER BY clauses with SUPER columns, Amazon Redshift defines a total ordering among different types to be observed when Amazon Redshift ranks SUPER values using ORDER BY clauses. The order among dynamic types is boolean, number, string, array, object. The following example shows the orders of different types:</p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">INSERT INTO region_nations VALUES 
(100,'name1','comment1','AWS'), 
(200,'name2','comment2',1),
(300,'name3','comment3',ARRAY(1, 'abc', null)),
(400,'name4','comment4',-2.5),
(500,'name5','comment5','Amazon');

SELECT r_nations FROM region_nations order by r_nations;

r_nations
----------------
 -2.5
 1
 "Amazon"
 "AWS"
 [1,"abc",null]
(5 rows)</code></pre>
         <p>For more information about the ORDER BY clause, see <a href="./r_ORDER_BY_clause.html">ORDER BY clause</a>.</p>
      <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Warning" /> <strong>Javascript is disabled or is unavailable in your browser.</strong></p><p>To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Document Conventions</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./unload-super-parquet.html">Unloading semistructured data in the Parquet format</div><div id="next" class="next-link" accesskey="n" href="./operators-functions.html">Operators and functions</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">Did this page help you? - Yes</div><div class="content"><p>Thanks for letting us know we're doing a good job!</p><p>If you've got a moment, please tell us what we did right so we can do more of it.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/query-super.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">Did this page help you? - No</div><div class="content"><p>Thanks for letting us know this page needs work. We're sorry we let you down.</p><p>If you've got a moment, please tell us how we can make the documentation better.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/query-super.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>