<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Query plan - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="c-the-query-plan" /><meta name="default_state" content="c-the-query-plan" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/redshift/latest/dg/c-the-query-plan.html" /><meta name="description" content="Describes how to interpret a query plan." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="Database Developer Guide" /><meta name="abstract" content="Create and manage a data warehouse with Amazon Redshift, an enterprise-level, petabyte scale, fully managed data warehousing service." /><meta name="guide-locale" content="en_us" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/redshift/latest/dg/c-the-query-plan.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c-the-query-plan.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c-the-query-plan.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c-the-query-plan.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c-the-query-plan.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c-the-query-plan.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c-the-query-plan.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c-the-query-plan.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c-the-query-plan.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-the-query-plan.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-the-query-plan.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c-the-query-plan.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c-the-query-plan.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c-the-query-plan.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c-the-query-plan.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-the-query-plan.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-the-query-plan.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c-the-query-plan.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c-the-query-plan.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/c-the-query-plan.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/c-the-query-plan.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c-the-query-plan.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="Database Developer Guide" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="Database Developer Guide" /><meta id="panorama-serviceConsolePage" value="Query plan" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Query plan - Amazon Redshift</title><meta name="pdf" content="/pdfs/redshift/latest/dg/redshift-dg.pdf#c-the-query-plan" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/c-the-query-plan.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/c-the-query-plan.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/c-the-query-plan.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,cluster,data warehouse,developer,sample data,database,database developer,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Database Developer Guide",
        "item" : "https://docs.aws.amazon.com/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Tuning query performance",
        "item" : "https://docs.aws.amazon.com/redshift/latest/dg/c-optimizing-query-performance.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Query processing",
        "item" : "https://docs.aws.amazon.com/redshift/latest/dg/c-query-processing.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "Query plan",
        "item" : "https://docs.aws.amazon.com/redshift/latest/dg/c-query-processing.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="/pdfs/redshift/latest/dg/redshift-dg.pdf#c-the-query-plan" target="_blank" rel="noopener noreferrer" title="Open PDF"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Documentation</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">Database Developer Guide</a></div><div id="page-toc-src"><a href="#EXPLAIN-operators">EXPLAIN operators</a><a href="#joins-in-EXPLAIN">Joins in EXPLAIN</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="c-the-query-plan">Query plan</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p>You can use the query plan to get information on the individual operations required
            to run a query. Before you work with a query plan, we recommend that you first
            understand how Amazon Redshift handles processing queries and creating query plans. For more
            information, see <a href="./c-query-planning.html">Query planning and execution workflow</a>.</p><p>To create a query plan, run the <a href="./r_EXPLAIN.html">EXPLAIN</a>
            command followed by the actual query text. The query plan gives you the following
            information:</p><div class="itemizedlist">
             
             
             
             
             
         <ul class="itemizedlist"><li class="listitem">
               <p>What operations the execution engine performs, reading the results from bottom
                  to top.</p>
            </li><li class="listitem">
               <p>What type of step each operation performs.</p>
            </li><li class="listitem">
               <p>Which tables and columns are used in each operation.</p>
            </li><li class="listitem">
               <p>How much data is processed in each operation, in terms of number of rows and
                  data width in bytes.</p>
            </li><li class="listitem">
               <p>The relative cost of the operation. <em>Cost</em> is a measure that
                  compares the relative execution times of the steps within a plan. Cost does not
                  provide any precise information about actual execution times or memory
                  consumption, nor does it provide a meaningful comparison between execution plans.
                  It does give you an indication of which operations in a query are consuming the
                  most resources.</p>
            </li></ul></div><p>The EXPLAIN command doesn't actually run the query. It only shows the plan that
            Amazon Redshift runs if the query is run under current operating conditions. If you change the
            schema or data for a table and run <a href="./r_ANALYZE.html">ANALYZE</a>
            again to update the statistical metadata, the query plan might be different.</p><p>The query plan output by EXPLAIN is a simplified, high-level view of query execution.
            It doesn't illustrate the details of parallel query processing. To see detailed
            information, run the query itself, and then get query summary information from the
            SVL_QUERY_SUMMARY or SVL_QUERY_REPORT view. For more information about using these
            views, see <a href="./c-analyzing-the-query-summary.html">Analyzing the query summary</a>.</p><p>The following example shows the EXPLAIN output for a simple GROUP BY query on the
            EVENT table:</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select eventname, count(*) from event group by eventname;

                            QUERY PLAN
-------------------------------------------------------------------
XN HashAggregate  (cost=131.97..133.41 rows=576 width=17)
  -&gt;  XN Seq Scan on event  (cost=0.00..87.98 rows=8798 width=17)</code></pre><p>EXPLAIN returns the following metrics for each operation:</p><div class="variablelist">
             
             
             
         <dl>
               <dt><b><span class="term">Cost</span></b></dt>
               <dd>
                  <p>A relative value that is useful for comparing operations within a plan. Cost
                     consists of two decimal values separated by two periods, for example
                        <code class="code">cost=131.97..133.41</code>. The first value, in this case 131.97,
                     provides the relative cost of returning the first row for this operation. The
                     second value, in this case 133.41, provides the relative cost of completing the
                     operation. The costs in the query plan are cumulative as you read up the plan,
                     so the HashAggregate cost in this example (131.97..133.41) includes the cost of
                     the Seq Scan below it (0.00..87.98).</p>
               </dd>
            
               <dt><b><span class="term">Rows</span></b></dt>
               <dd>
                  <p>The estimated number of rows to return. In this example, the scan is
                     expected to return 8798 rows. The HashAggregate operator on its own is expected
                     to return 576 rows (after duplicate event names are discarded from the result
                     set).</p>
                  <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>The rows estimate is based on the available statistics generated by the
                        ANALYZE command. If ANALYZE has not been run recently, the estimate is less
                        reliable.</p></div></div>
               </dd>
            
               <dt><b><span class="term">Width</span></b></dt>
               <dd>
                  <p>The estimated width of the average row, in bytes. In this example, the
                     average row is expected to be 17 bytes wide.</p>
               </dd>
            </dl></div><h2 id="EXPLAIN-operators">EXPLAIN operators</h2>
            
            <p>This section briefly describes the operators that you see most often in the
               EXPLAIN output. For a complete list of operators, see <a href="./r_EXPLAIN.html">EXPLAIN</a> in the SQL Commands section.</p>
            <h3 id="scan-operator">Sequential scan operator</h3>
               
               <p>The sequential scan operator (Seq Scan) indicates a table scan. Seq Scan scans
                  each column in the table sequentially from beginning to end and evaluates query
                  constraints (in the WHERE clause) for every row.</p>
             
            <h3 id="join-operators">Join operators</h3>
               
               <p>Amazon Redshift selects join operators based on the physical design of the tables
                  being joined, the location of the data required for the join, and the specific
                  requirements of the query itself.</p>
               <div class="itemizedlist">
                   
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">Nested Loop</span></p>
                     <p>The least optimal join, a nested loop is used mainly for cross-joins
                        (Cartesian products) and some inequality joins.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Hash Join and Hash</span></p>
                     <p>Typically faster than a nested loop join, a hash join and hash are used
                        for inner joins and left and right outer joins. These operators are used
                        when joining tables where the join columns are not both distribution keys
                           <em>and</em> sort keys. The hash operator creates the hash
                        table for the inner table in the join; the hash join operator reads the
                        outer table, hashes the joining column, and finds matches in the inner hash
                        table.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Merge Join</span></p>
                     <p>Typically the fastest join, a merge join is used for inner joins and
                        outer joins. The merge join is not used for full joins. This operator is
                        used when joining tables where the join columns are both distribution keys
                           <em>and</em> sort keys, and when less than 20 percent of the
                        joining tables are unsorted. It reads two sorted tables in order and finds
                        the matching rows. To view the percent of unsorted rows, query the <a href="./r_SVV_TABLE_INFO.html">SVV_TABLE_INFO</a> system
                        table.</p>
                  </li><li class="listitem"> 
                     <p><span class="topcom">Spatial Join</span></p>
                     <p>Typically a fast join based on proximity of spatial data, used for <code class="code">GEOMETRY</code> and <code class="code">GEOGRAPHY</code> data types.</p>
                  </li></ul></div>
             
            <h3 id="aggregate-operators">Aggregate operators</h3>
               
               <p>The query plan uses the following operators in queries that involve aggregate
                  functions and GROUP BY operations.</p>
               <div class="itemizedlist">
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">Aggregate</span></p>
                     <p>Operator for scalar aggregate functions such as AVG and SUM.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">HashAggregate</span></p>
                     <p>Operator for unsorted grouped aggregate functions.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">GroupAggregate</span></p>
                     <p>Operator for sorted grouped aggregate functions.</p>
                  </li></ul></div>
             
            <h3 id="sort-operators">Sort operators</h3>
               
               <p>The query plan uses the following operators when queries have to sort or merge
                  result sets.</p>
               <div class="itemizedlist">
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">Sort</span></p>
                     <p>Evaluates the ORDER BY clause and other sort operations, such as sorts
                        required by UNION queries and joins, SELECT DISTINCT queries, and window
                        functions.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Merge</span></p>
                     <p>Produces final sorted results according to intermediate sorted results
                        that derive from parallel operations.</p>
                  </li></ul></div>
             
            <h3 id="UNION-INTERSECT-and-EXCEPT-operators">UNION, INTERSECT, and EXCEPT
                     operators</h3>
               
               <p>The query plan uses the following operators for queries that involve set
                  operations with UNION, INTERSECT, and EXCEPT.</p>
               <div class="itemizedlist">
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">Subquery</span></p>
                     <p>Used to run UNION queries.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Hash Intersect Distinct </span></p>
                     <p>Used to run INTERSECT  queries.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">SetOp Except</span></p>
                     <p>Used to run EXCEPT (or MINUS) queries.</p>
                  </li></ul></div>
             
            <h3 id="other-operators">Other operators</h3>
               
               <p>The following operators also appear frequently in EXPLAIN output for routine
                  queries.</p>
               <div class="itemizedlist">
                   
                   
                   
                   
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">Unique</span></p>
                     <p>Removes duplicates for SELECT DISTINCT queries and UNION queries.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Limit</span></p>
                     <p>Processes the LIMIT clause.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Window</span></p>
                     <p>Runs window functions.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Result</span></p>
                     <p>Runs scalar functions that do not involve any table access.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Subplan</span></p>
                     <p>Used for certain subqueries.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Network</span></p>
                     <p>Sends intermediate results to the leader node for further
                        processing.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Materialize</span></p>
                     <p>Saves rows for input to nested loop joins and some merge joins.</p>
                  </li></ul></div>
             
         <h2 id="joins-in-EXPLAIN">Joins in EXPLAIN</h2>
            
            <p>The query optimizer uses different join types to retrieve table data, depending on
               the structure of the query and the underlying tables. The EXPLAIN output references
               the join type, the tables used, and the way the table data is distributed across the
               cluster to describe how the query is processed.</p>

            <h3 id="join-types">Join type examples</h3>
               
               <p>The following examples show the different join types that the query optimizer
                  can use. The join type used in the query plan depends on the physical design of
                  the tables involved.</p>
               <h4 id="hash-join-two-tables">Example: Hash join two tables</h4>
                  
                  <p>The following query joins EVENT and CATEGORY on the CATID column. CATID is
                     the distribution and sort key for CATEGORY but not for EVENT. A hash join is
                     performed with EVENT as the outer table and CATEGORY as the inner table.
                     Because CATEGORY is the smaller table, the planner broadcasts a copy of it to
                     the compute nodes during query processing by using DS_BCAST_INNER. The join
                     cost in this example accounts for most of the cumulative cost of the
                     plan.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select * from category, event where category.catid=event.catid;

                               QUERY PLAN
-------------------------------------------------------------------------
 XN Hash Join DS_BCAST_INNER  (cost=0.14..6600286.07 rows=8798 width=84)
   Hash Cond: ("outer".catid = "inner".catid)
   -&gt;  XN Seq Scan on event  (cost=0.00..87.98 rows=8798 width=35)
   -&gt;  XN Hash  (cost=0.11..0.11 rows=11 width=49)
         -&gt;  XN Seq Scan on category  (cost=0.00..0.11 rows=11 width=49)</code></pre>
                  <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>Aligned indents for operators in the EXPLAIN output sometimes indicate
                        that those operations do not depend on each other and can start in parallel.
                        In the preceding example, although the scan on the EVENT table and the hash
                        operation are aligned, the EVENT scan must wait until the hash operation has
                        fully completed.</p></div></div>
                
               <h4 id="merge-join-two-tables">Example: Merge join two tables</h4>
                  
                  <p>The following query also uses SELECT *, but it joins SALES and LISTING on
                     the LISTID column, where LISTID has been set as both the distribution and sort
                     key for both tables. A merge join is chosen, and no redistribution of data is
                     required for the join (DS_DIST_NONE).</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select * from sales, listing where sales.listid = listing.listid;
QUERY PLAN
-----------------------------------------------------------------------------
XN Merge Join DS_DIST_NONE  (cost=0.00..6285.93 rows=172456 width=97)
  Merge Cond: ("outer".listid = "inner".listid)
  -&gt;  XN Seq Scan on listing  (cost=0.00..1924.97 rows=192497 width=44)
  -&gt;  XN Seq Scan on sales  (cost=0.00..1724.56 rows=172456 width=53)</code></pre>
                  <p>The following example demonstrates the different types of joins within the
                     same query. As in the previous example, SALES and LISTING are merge joined, but
                     the third table, EVENT, must be hash joined with the results of the merge join.
                     Again, the hash join incurs a broadcast cost.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select * from sales, listing, event
where sales.listid = listing.listid and sales.eventid = event.eventid;
                                  QUERY PLAN
----------------------------------------------------------------------------
XN Hash Join DS_BCAST_INNER  (cost=109.98..3871130276.17 rows=172456 width=132)
  Hash Cond: ("outer".eventid = "inner".eventid)
  -&gt;  XN Merge Join DS_DIST_NONE  (cost=0.00..6285.93 rows=172456 width=97)
        Merge Cond: ("outer".listid = "inner".listid)
        -&gt;  XN Seq Scan on listing  (cost=0.00..1924.97 rows=192497 width=44)
        -&gt;  XN Seq Scan on sales  (cost=0.00..1724.56 rows=172456 width=53)
  -&gt;  XN Hash  (cost=87.98..87.98 rows=8798 width=35)
        -&gt;  XN Seq Scan on event  (cost=0.00..87.98 rows=8798 width=35)</code></pre>
                
               <h4 id="join-aggregate-and-sort-example">Example: Join, aggregate, and sort</h4>
                  
                  <p>The following query runs a hash join of the SALES and EVENT tables,
                     followed by aggregation and sort operations to account for the grouped SUM
                     function and the ORDER BY clause. The initial sort operator runs in parallel on
                     the compute nodes. Then the Network operator sends the results to the leader
                     node, where the Merge operator produces the final sorted results.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select eventname, sum(pricepaid) from sales, event 
where sales.eventid=event.eventid group by eventname
order by 2 desc;
                                           QUERY PLAN
---------------------------------------------------------------------------------
 XN Merge  (cost=1002815366604.92..1002815366606.36 rows=576 width=27)
  Merge Key: sum(sales.pricepaid)
  -&gt;  XN Network  (cost=1002815366604.92..1002815366606.36 rows=576 width=27)
        Send to leader
        -&gt;  XN Sort  (cost=1002815366604.92..1002815366606.36 rows=576 width=27)
              Sort Key: sum(sales.pricepaid)
              -&gt;  XN HashAggregate  (cost=2815366577.07..2815366578.51 rows=576 width=27)
                    -&gt;  XN Hash Join DS_BCAST_INNER  (cost=109.98..2815365714.80 rows=172456 width=27)
                          Hash Cond: ("outer".eventid = "inner".eventid)
                          -&gt;  XN Seq Scan on sales  (cost=0.00..1724.56 rows=172456 width=14)
                          -&gt;  XN Hash  (cost=87.98..87.98 rows=8798 width=21)
                                -&gt;  XN Seq Scan on event  (cost=0.00..87.98 rows=8798 width=21)</code></pre>
                
             
            <h3 id="data-redistribution">Data redistribution</h3>
               
               <p>The EXPLAIN output for joins also specifies a method for how data is moved
                  around a cluster to facilitate the join. This data movement can be either a
                  broadcast or a redistribution. In a broadcast, the data values from one side of a
                  join are copied from each compute node to every other compute node, so that every
                  compute node ends up with a complete copy of the data. In a redistribution,
                  participating data values are sent from their current slice to a new slice
                  (possibly on a different node). Data is typically redistributed to match the
                  distribution key of the other table participating in the join if that distribution
                  key is one of the joining columns. If neither of the tables has distribution keys
                  on one of the joining columns, either both tables are distributed or the inner
                  table is broadcast to every node.</p>
               <p>The EXPLAIN output also references inner and outer tables. The inner table is
                  scanned first, and appears nearer the bottom of the query plan. The inner table is
                  the table that is probed for matches. It is usually held in memory, is usually the
                  source table for hashing, and if possible, is the smaller table of the two being
                  joined. The outer table is the source of rows to match against the inner table. It
                  is usually read from disk. The query optimizer chooses the inner and outer table
                  based on database statistics from the latest run of the ANALYZE command. The order
                  of tables in the FROM clause of a query doesn't determine which table is inner and
                  which is outer.</p>
               <p>Use the following attributes in query plans to identify how data is moved to
                  facilitate a query:</p>
               <div class="itemizedlist">
                   
                   
                   
                   
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">DS_BCAST_INNER</span></p>
                     <p>A copy of the entire inner table is broadcast to all compute
                        nodes.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_ALL_NONE</span></p>
                     <p>No redistribution is required, because the inner table has already been
                        distributed to every node using DISTSTYLE ALL.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_NONE</span></p>
                     <p>No tables are redistributed. Collocated joins are possible because
                        corresponding slices are joined without moving data between nodes.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_INNER</span></p>
                     <p>The inner table is redistributed.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_OUTER</span></p>
                     <p>The outer table is redistributed.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_ALL_INNER</span></p>
                     <p>The entire inner table is redistributed to a single slice because the
                        outer table uses DISTSTYLE ALL.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_BOTH</span></p>
                     <p>Both tables are redistributed.</p>
                  </li></ul></div>
             
         <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Warning" /> <strong>Javascript is disabled or is unavailable in your browser.</strong></p><p>To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Document Conventions</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./c-query-planning.html">Query planning and execution workflow</div><div id="next" class="next-link" accesskey="n" href="./reviewing-query-plan-steps.html">Reviewing query plan steps</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">Did this page help you? - Yes</div><div class="content"><p>Thanks for letting us know we're doing a good job!</p><p>If you've got a moment, please tell us what we did right so we can do more of it.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/c-the-query-plan.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">Did this page help you? - No</div><div class="content"><p>Thanks for letting us know this page needs work. We're sorry we let you down.</p><p>If you've got a moment, please tell us how we can make the documentation better.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/en_us/redshift/latest/dg/c-the-query-plan.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>