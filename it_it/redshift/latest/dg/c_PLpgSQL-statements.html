<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="it-IT"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Istruzioni PL/pgSQL supportate - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="c_PLpgSQL-statements" /><meta name="default_state" content="c_PLpgSQL-statements" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="description" content="Utilizzare le istruzioni PL/pgSQL supportate da Amazon Redshift." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="Guida per sviluppatori di database" /><meta name="abstract" content="Creare e gestire un data warehouse con Amazon Redshift, un servizio di data warehouse completamente gestito di livello aziendale e con capacità nell'ordine di più petabyte." /><meta name="guide-locale" content="it_it" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="Guida per sviluppatori di database" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="Guida per sviluppatori di database" /><meta id="panorama-serviceConsolePage" value="Istruzioni PL/pgSQL supportate" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Istruzioni PL/pgSQL supportate - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#c_PLpgSQL-statements" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,cluster,data warehouse,sviluppatore,dati campione,database,sviluppatore di database,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Guida per sviluppatori di database",
        "item" : "https://docs.aws.amazon.com/it_it/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Creazione di procedure archiviate in Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/it_it/redshift/latest/dg/stored-procedure-overview.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Riferimento al linguaggio PL/pgSQL",
        "item" : "https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_pl_pgSQL_reference.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "Istruzioni PL/pgSQL supportate",
        "item" : "https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_pl_pgSQL_reference.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#c_PLpgSQL-statements" target="_blank" rel="noopener noreferrer" title="Apri PDF"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Documentazione</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">Guida per sviluppatori di database</a></div><div id="page-toc-src"><a href="#r_PLpgSQL-assignment">Assegnazione</a><a href="#r_PLpgSQL-select-into">SELECT INTO</a><a href="#r_PLpgSQL-no-op">No-op</a><a href="#r_PLpgSQL-dynamic-sql">SQL dinamico</a><a href="#r_PLpgSQL-return">Return</a><a href="#r_PLpgSQL-conditionals-if">Condizionali: IF </a><a href="#r_PLpgSQL-conditionals-case">Condizionali: CASE</a><a href="#r_PLpgSQL-loops">Loop</a><a href="#r_PLpgSQL-cursors">Cursori</a><a href="#r_PLpgSQL-messages-errors">RAISE</a><a href="#r_PLpgSQL-transaction-control">Controllo della transazione</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><awsui-alert class="awsdocs-page-banner awsui-util-mb-l"><p>Le traduzioni sono generate tramite traduzione automatica. In caso di conflitto tra il contenuto di una traduzione e la versione originale in Inglese, quest'ultima prevarrà.</p></awsui-alert><h1 class="topictitle" id="c_PLpgSQL-statements">Istruzioni PL/pgSQL supportate</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p> Le istruzioni PL/pgSQL aumentano i comandi SQL con costrutti procedurali, includendo le espressioni di looping e condizionali, per controllare il flusso logico. È possibile utilizzare la maggior parte dei comandi SQL, compresi il linguaggio DML (Data Manipulation Language) come COPY, UNLOAD e INSERT, e il linguaggio DDL (Data Definition Language) come CREATE TABLE. Per un elenco di comandi SQL esaustivi, consultare <a href="./c_SQL_commands.html">Comandi SQL</a>. Inoltre, le seguenti istruzioni PL/pgSQL sono supportate da Amazon Redshift. </p><div class="highlights" id="inline-topiclist"><h6>Argomenti</h6><ul><li><a href="#r_PLpgSQL-assignment">Assegnazione</a></li><li><a href="#r_PLpgSQL-select-into">SELECT INTO</a></li><li><a href="#r_PLpgSQL-no-op">No-op</a></li><li><a href="#r_PLpgSQL-dynamic-sql">SQL dinamico</a></li><li><a href="#r_PLpgSQL-return">Return</a></li><li><a href="#r_PLpgSQL-conditionals-if">Condizionali: IF</a></li><li><a href="#r_PLpgSQL-conditionals-case">Condizionali: CASE</a></li><li><a href="#r_PLpgSQL-loops">Loop</a></li><li><a href="#r_PLpgSQL-cursors">Cursori</a></li><li><a href="#r_PLpgSQL-messages-errors">RAISE</a></li><li><a href="#r_PLpgSQL-transaction-control">Controllo della transazione</a></li></ul></div>
            <h2 id="r_PLpgSQL-assignment">Assegnazione</h2>  
            
            <p>L'istruzione di assegnazione assegna un valore a una variabile. L'espressione deve restituire un valore singolo.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">identifier := expression;</code></pre>
            
            <p>L'utilizzo di <code class="code">=</code> non standard per l'assegnazione, invece di <code class="code">:=</code> è anche accettabile.</p>
            
           <p>Se il tipo di dati dell'espressione non corrisponde al tipo di dati della variabile o la variabile ha una dimensione o precisione, il valore del risultato viene convertito implicitamente.</p>
      <p>Di seguito vengono riportati degli esempi.</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">customer_number := 20;
tip := subtotal * 0.15;</code></pre>
            
          
            <h2 id="r_PLpgSQL-select-into">SELECT INTO</h2> 
            
           
            <p>L'istruzione SELECT INTO assegna il risultato di colonne multiple (ma solo una riga) in una variabile di record o in un elenco di variabili scalari.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">SELECT INTO <code class="replaceable">target</code> <code class="replaceable">select_expressions</code> FROM ...;</code></pre>  
            
            
            <p>Nella sintassi precedente, <code class="replaceable">target</code> può essere una variabile di record o un elenco separato da virgole di variabili semplici e campi record. L'elenco <code class="replaceable">select_expressions</code> e il resto del comando coincidono come nel SQL regolare.</p>
            <p>Se un elenco di variabili viene utilizzato come <code class="replaceable">target</code>, i valori selezionati devono corrispondere esattamente alla struttura del target o si verifica un errore di runtime. Quando una variabile di record è il target, si configura automaticamente al tipo di riga delle colonne dei risultati delle query.</p>
            <p>La clausola INTO può apparire quasi ovunque nell'istruzione SELECT. Solitamente appare appena dopo la clausola SELECT o appena prima della clausola FROM. Ovvero, appare appena prima o appena dopo l'elenco <code class="replaceable">select_expressions</code>.</p>
            <p>Se la query restituisce zero righe, i valori NULL vengono assegnati al <code class="replaceable">target</code>. Se la query restituisce righe multiple, la prima riga viene assegnata al <code class="replaceable">target</code> e le altre vengono eliminate. A meno che l'istruzione contenga un ORDER BY, la prima riga non è deterministica.</p>
            <p>Per determinare se l'assegnazione ha restituito almeno una riga, utilizza la variabile speciale FOUND.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">SELECT INTO customer_rec * FROM cust WHERE custname = lname;
IF NOT FOUND THEN
  RAISE EXCEPTION 'employee % not found', lname;
END IF;
</code></pre>
            
            <p>Per testare se un risultato di un record è null, è possibile utilizzare il condizionale IS NULL. Non c'è modo di determinare se delle righe aggiuntive sono state eliminate. L'esempio seguente gestisce il caso nel quale nessuna riga è stata restituita.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE select_into_null(return_webpage OUT varchar(256))
AS $$
DECLARE
  customer_rec RECORD;
BEGIN
  SELECT INTO customer_rec * FROM users WHERE user_id=3;
  IF customer_rec.webpage IS NULL THEN
    -- user entered no webpage, return "http://"
    return_webpage = 'http://';
  END IF;
END;
$$ LANGUAGE plpgsql;         
</code></pre>
            
          
            <h2 id="r_PLpgSQL-no-op">No-op</h2>  
           
            <p>L'istruzione no-op (<code class="code">NULL;</code>) è un'istruzione segnaposto che non fa nulla. Un'istruzione no-op può indicare un ramo di una catena IF-THEN-ELSE è vuoto.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="">NULL;</code></pre> 
 
 
            
          
            <h2 id="r_PLpgSQL-dynamic-sql">SQL dinamico</h2>  
            
            <p>Per generare i comandi dinamici che possono includere diverse tabelle o diversi tipi di dati ogni volta che vengono eseguiti da una procedura archiviata PL/pgSQL, utilizza l'istruzione <code class="code">EXECUTE</code>.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">EXECUTE <code class="replaceable">command-string</code> [ INTO target ];</code></pre> 
            
            <p>Nell'esempio precedente, <code class="replaceable">command-string</code> è un'espressione che produce una stringa (di tipo testo) che contiene il comando da eseguire. Questo valore <code class="replaceable">command-string</code> viene inviato al motore SQL. Nessuna sostituzione delle variabili PL/pgSQL viene effettuata sulla stringa del comando. I valori delle variabili devono essere inseriti nella stringa comando com'è costruito.</p>
           
           <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Nota</h6></div><div class="awsdocs-note-text"><p>Non è possibile utilizzare le istruzioni COMMIT e ROLLBACK dall'interno di un SQL dinamico. Per informazioni su come utilizzare le istruzioni COMMIT e ROLLBACK all'interno di una procedura archiviata, consultare <a href="./stored-procedure-transaction-management.html">Gestione delle transazioni</a>. </p></div></div> 
            
            <p>Quando si lavora con i comandi dinamici, spesso è necessario necessario gestire l'escape di virgolette singole. Consigliamo di racchiudere il testo fisso in virgolette nel testo della funzione utilizzando il dollar quoting. I valori dinamici da inserire in una query costruita richiedono una gestione speciale perché loro stessi potrebbero contenere virgolette. L'esempio seguente utilizza il dollar quoting per tutta la funzione, quindi le virgolette non devono essere raddoppiate.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">EXECUTE 'UPDATE tbl SET '
  || quote_ident(colname)
  || ' = '
  || quote_literal(newvalue)
  || ' WHERE key = '
  || quote_literal(keyvalue);               
</code></pre>
            
            <p>L'esempio precedente mostra le funzioni <code class="code">quote_ident(text)</code> e <code class="code">quote_literal(text)</code>. Questo esempio passa variabili che contengono identificatori di colonna e tabella alla funzione <code class="code">quote_ident</code>. Passa anche variabili che contengono stringhe letterali nel comando costruito alla funzione <code class="code">quote_literal</code>. Entrambe le funzioni eseguono i passaggi appropriati per restituire il testo di input racchiuso tra virgolette doppie o singole rispettivamente, dove viene eseguito l'escape di qualsiasi carattere speciale incorporato.</p>
            <p>Il Dollar quoting è utile solo per l'utilizzo di virgolette in testo fisso. Non scrivere l'esempio precedente nel seguente formato.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">EXECUTE 'UPDATE tbl SET '
  || quote_ident(colname)
  || ' = $$'
  || newvalue
  || '$$ WHERE key = '
  || quote_literal(keyvalue);               
</code></pre>
            
            <p>Non esegui questa operazione perché l'esempio si interrompe se i contenuti di <code class="code">newvalue</code> contengono $$. Lo stesso problema si applica a qualsiasi delimitatore di Dollar quoting che scegli. Per utilizzare in maniera sicura le virgolette in testo che non conosci in anticipo, utilizza la funzione <code class="code">quote_literal</code>.</p>
            
          
            <h2 id="r_PLpgSQL-return">Return</h2>   
            
            <p>L'istruzione RETURN ritorna all'intermediario da una procedura archiviata.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="">RETURN;</code></pre>
            
            <p>Di seguito viene riportato un esempio.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE return_example(a int)
AS $$  
BEGIN
  FOR b in 1..10 LOOP
    IF b &lt; a THEN
      RAISE INFO 'b = %', b;
    ELSE
      RETURN;
    END IF;
  END LOOP;
END;
$$ LANGUAGE plpgsql;               
</code></pre>
            
          
            <h2 id="r_PLpgSQL-conditionals-if">Condizionali: IF</h2>  
           
           
            
            <p>L'istruzione condizionale IF può avere le seguenti forme nel linguaggio PL/pgSQL utilizzato da Amazon Redshift:</p>
            
            
            <div class="itemizedlist">
                
               
               
               
                  

                
            
            <ul class="itemizedlist"><li class="listitem"><p>IF ... THEN</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
END IF;
</code></pre>
                  
            <p>Di seguito viene riportato un esempio.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF v_user_id &lt;&gt; 0 THEN
  UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;               
</code></pre>
            
            </li><li class="listitem"><p>IF ... THEN ... ELSE</p>
 <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
ELSE
  statements
END IF;
</code></pre>
                  
               <p>Di seguito viene riportato un esempio.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF parentid IS NULL OR parentid = ''
THEN
  return_name = fullname;
  RETURN;
ELSE
  return_name = hp_true_filename(parentid) || '/' || fullname;
  RETURN;
END IF;           
</code></pre>
                  
               </li><li class="listitem"><p>IF ... THEN ... ELSIF ... THEN ... ELSE </p>
                  <p>La parola chiave ELSIF si può anche scrivere come ELSEIF.</p>                  
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
[ ELSIF boolean-expression THEN
  statements
[ ELSIF boolean-expression THEN
  statements
    ...] ]
[ ELSE
  statements ]
END IF;
</code></pre>                  
               

               
               <p>Di seguito viene riportato un esempio.</p>
               
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF number = 0 THEN
  result := 'zero';
ELSIF number &gt; 0 THEN
  result := 'positive';
ELSIF number &lt; 0 THEN
  result := 'negative';
ELSE
  -- the only other possibility is that number is null
  result := 'NULL';
END IF;                  
</code></pre>
               </li></ul></div>
            
           
            
          
            <h2 id="r_PLpgSQL-conditionals-case">Condizionali: CASE</h2>  
           <p>L'istruzione condizionale CASE può avere le seguenti forme nel linguaggio PL/pgSQL utilizzato da Amazon Redshift:</p>
            <div class="itemizedlist">
                
                 

            <ul class="itemizedlist"><li class="listitem"><p>CASE semplice </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CASE <code class="replaceable">search-expression</code>
WHEN <code class="replaceable">expression</code> [, <code class="replaceable">expression</code> [ ... ]] THEN
  <code class="replaceable">statements</code>
[ WHEN <code class="replaceable">expression</code> [, <code class="replaceable">expression</code> [ ... ]] THEN
  <code class="replaceable">statements</code>
  ... ]
[ ELSE
  <code class="replaceable">statements</code> ]
END CASE;
</code></pre>
                  
                  <p>Una semplice istruzione CASE fornisce l'esecuzione condizionale basata sull'eguaglianza degli operandi.</p>
                  
                  <p>Il valore <code class="replaceable">espressione di ricerca</code> viene valutato una volta e viene paragonato successivamente a ogni <code class="replaceable">espressione</code> nelle clausole WHEN. Se si trova una corrispondenza, vengono eseguite gli <code class="replaceable">statement</code> corrispondenti e il controllo passa all'istruzione successiva dopo END CASE. Le espressioni WHEN successive non vengono valutate. Se non viene trovata alcuna corrispondenza, vengono eseguite le <code class="replaceable">istruzioni</code> ELSE. Tuttavia, se ELSE non è presente, viene generata un'eccezione CASE_NOT_FOUND.</p>
                  
               <p>Di seguito viene riportato un esempio.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CASE x
WHEN 1, 2 THEN
  msg := 'one or two';
ELSE
  msg := 'other value than one or two';
END CASE;                  
</code></pre>
                  
               </li><li class="listitem"><p>CASE ricercata </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CASE
WHEN <code class="replaceable">boolean-expression</code> THEN
  statements
[ WHEN <code class="replaceable">boolean-expression</code> THEN
  statements
  ... ]
[ ELSE
  statements ]
END CASE;
</code></pre>
                  
                  <p>La forma ricercata di CASE fornisce un'esecuzione condizionale basata sulla verità delle espressioni booleane. </p>
                  
                  <p>Ogni <code class="replaceable">espressione booleana</code> della clausola WHEN viene valutata a turno, fino a che viene trovata una che genera true. In seguito le istruzioni corrispondenti vengono eseguite e il controllo passa all'istruzione successiva dopo END CASE. Le <code class="replaceable">espressioni</code> WHEN successive non vengono valutate. Se non viene trovato un risultato true , vengono eseguite le <code class="replaceable">istruzioni</code> ELSE. Tuttavia, se ELSE non è presente, viene generata un'eccezione CASE_NOT_FOUND.</p>
                  
                  <p>Di seguito viene riportato un esempio.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CASE
WHEN x BETWEEN 0 AND 10 THEN
  msg := 'value is between zero and ten';
WHEN x BETWEEN 11 AND 20 THEN
  msg := 'value is between eleven and twenty';
END CASE;                                
</code></pre>
                  
               </li></ul></div>                      
            
          
            <h2 id="r_PLpgSQL-loops">Loop</h2>  
            
           <p>Le istruzioni loop possono avere le seguenti forme nel linguaggio PL/pgSQL utilizzato da Amazon Redshift:</p>
            <div class="itemizedlist">
                
               
                 
               
                 
               
                
               
                 
               
                 
               
               
               
                                  
               
               
            <ul class="itemizedlist"><li class="listitem"><p>Loop semplice </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
LOOP
  statements
END LOOP [ label ];
</code></pre>
                  
                  <p>Un loop semplice definisce un loop non condizionale che viene ripetuto a tempo indeterminato fino a quando viene terminato da un'istruzione EXIT e RETURN. L'etichetta opzionale può essere utilizzata dalle istruzioni EXIT e CONTINUE nei loop nidificati per specificare a quale loop si riferiscono le instruzioni EXIT e CONTINUE.</p>
                  
               <p>Di seguito viene riportato un esempio.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE simple_loop()
LANGUAGE plpgsql
AS $$
BEGIN
  &lt;&lt;simple_while&gt;&gt;
  LOOP
    RAISE INFO 'I am raised once';  
    EXIT simple_while;
    RAISE INFO 'I am not raised';
  END LOOP;
  RAISE INFO 'I am raised once as well';
END;
$$;                
</code></pre>

               </li><li class="listitem"><p>Loop exit</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">EXIT [ <code class="replaceable">label</code> ] [ WHEN <code class="replaceable">expression</code> ];
</code></pre> 
                 <p>Se l'<code class="replaceable">etichetta</code> non è presente, il loop interno viene terminato e viene eseguita l'istruzione successiva a END LOOP. Se l'<code class="replaceable">etichetta</code> è presente, deve essere l'etichetta del livello corrente o del livello esterno del loop o blocco nidificato. In seguito, il loop o blocco denominato viene terminato e il controllo continua con l'istruzione dopo il loop o blocco corrispondente a END.</p>
                  <p>Se WHEN è specificata, l'uscita del loop avviene solo se l'<code class="replaceable">espressione</code> è true. Altrimenti, il controllo passa all'istruzione dopo EXIT.</p>
                  <p>È possibile utilizzare EXIT con tutti i tipi di loop, non è limitato all'utilizzo con loop non condizionali.</p>
                  <p>Quando viene utilizzato un blocco BEGIN, EXIT passa il controllo alla prossima istruzione dopo la fine del blocco. A questo scopo deve essere utilizzata un'etichetta. Un'istruzione EXIT non etichettata non viene mai considerata per un blocco BEGIN.</p>
                  <p>Di seguito viene riportato un esempio.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE simple_loop_when(x int)
LANGUAGE plpgsql
AS $$
DECLARE i INTEGER := 0;
BEGIN
  &lt;&lt;simple_loop_when&gt;&gt;
  LOOP
    RAISE INFO 'i %', i;
    i := i + 1;
    EXIT simple_loop_when WHEN (i &gt;= x);
  END LOOP;
END;
$$;                     
</code></pre>
               </li><li class="listitem"><p>Loop Continue </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CONTINUE [ <code class="replaceable">label</code> ] [ WHEN <code class="replaceable">expression</code> ];
</code></pre> 
                  <p>Se <code class="replaceable">label</code> non viene fornita, l'esecuzione passa alla successiva iterazione del loop più interno. Ovvero, tutte le istruzioni rimanenti nel testo del loop vengono ignorate. Il controllo in seguito ritorna all'espressione di controllo del loop (se presenti) per determinare se un'altra iterazione di un loop è necessaria. Se <code class="replaceable">label</code> è presente, specifica l'etichetta del loop la cui esecuzione viene continuata.</p>
                  <p>Se l'istruzione WHEN è specificata, l'iterazione successiva del loop inizia solo se <code class="replaceable">expression</code> è true. Altrimenti, il controllo passa all'istruzione dopo CONTINUE.</p>
                  <p>È possibile utilizzare CONTINUE con tutti i tipi di loop, non è limitato all'utilizzo con loop non condizionali.</p>
                  
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CONTINUE mylabel;
</code></pre> 
                  
               </li><li class="listitem"><p>Loop WHILE </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
WHILE expression LOOP
  statements
END LOOP [ label ];
</code></pre> 
                  
               <p>L'istruzione WHILE ripete una sequenza di istruzioni purché l'<code class="replaceable">boolean-expression</code> corrisponda a true. L'espressione viene controllata appena prima di ogni inserimento nel body del loop.</p> 
               <p>Di seguito viene riportato un esempio.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
  -- some computations here
END LOOP;

WHILE NOT done LOOP
  -- some computations here
END LOOP;                  
</code></pre>
               </li><li class="listitem"><p>Loop FOR (variante numero intero) </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR name IN [ REVERSE ] expression .. expression LOOP
  statements
END LOOP [ label ];
</code></pre> 
                  
                  <p>Il loop FOR (variante numero intero) crea un loop che esegue l'iterazione in una gamma di valori interi. Il nome variabile viene definito automaticamente come tipo intero ed esiste solo nel loop. Qualsiasi definizione esistente del nome della variabile viene ignorato nel loop. Le due espressioni che forniscono il limite inferiore e superiore della gamma vengono valutate una volta quando entrano nel loop. Se si specifica REVERSE, viene sottratto il valore di incremento, piuttosto che aggiunto, dopo ogni iterazione.</p> 
                  
                  <p>Se il limite inferiore è maggiore rispetto al limite superiore (o inferiore, nel caso REVERSE), il body del loop non viene eseguito. Non viene generato alcun errore.</p>
                  
                  <p>Se un'etichetta viene collegata al loop FOR, puoi fare riferimento alla variabile del loop intero con un nome qualificato, utilizzando quell'etichetta.</p>
                  
               <p>Di seguito viene riportato un esempio.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">FOR i IN 1..10 LOOP
  -- i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop
END LOOP;

FOR i IN REVERSE 10..1 LOOP
  -- i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop
END LOOP;                
</code></pre>  

               </li><li class="listitem"><p>Loop FOR (variante set di risultati) </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR <code class="replaceable">target</code> IN query LOOP
  statements
END LOOP [ label ];
</code></pre>
                  <p>Il <code class="replaceable">target</code> è una variabile di record o un elenco separato da virgola di variabili scalari. In seguito, al target viene assegnata ciascuna riga risultante dalla query e il body del loop viene eseguito per ogni riga.</p> 
                  
                  <p>Il loop FOR (variante set di risultati) permette a una procedura archiviata di effettuare l'iterazione attraverso i risultati di una query e manipolare i dati di conseguenza.</p>
                  <p>Di seguito viene riportato un esempio.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE PROCEDURE cs_refresh_reports() AS $$
DECLARE
  reports RECORD;
BEGIN
  FOR reports IN SELECT * FROM cs_reports ORDER BY sort_key LOOP
    -- Now "reports" has one record from cs_reports
    EXECUTE 'TRUNCATE TABLE ' || quote_ident(reports.report_name);
    EXECUTE 'INSERT INTO ' || quote_ident(reports.report_name) || ' ' || reports.report_query;
  END LOOP;
  RETURN;
END;
$$ LANGUAGE plpgsql;                   
</code></pre>
               </li><li class="listitem"><p>Loop FOR con SQL dinamico</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR record_or_row IN EXECUTE text_expression LOOP 
  statements
END LOOP;
</code></pre>
                  
                  <p>Un loop FOR con SQL dinamico permette a una procedura archiviata di effettuare l'iterazione attraverso i risultati di una query dinamica e manipolare i dati di conseguenza.</p>  
                  
               <p>Di seguito viene riportato un esempio.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE for_loop_dynamic_sql(x int)
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  query text;
BEGIN
  query := 'SELECT * FROM tbl_dynamic_sql LIMIT ' || x;
  FOR rec IN EXECUTE query
  LOOP
    RAISE INFO 'a %', rec.a;
  END LOOP;
END;
$$;</code></pre>
               </li></ul></div>                      
            
          
            <h2 id="r_PLpgSQL-cursors">Cursori</h2>  
            
            <p>Invece di eseguire una query intera in una volta, puoi impostare un cursore. Un <em>cursore </em>incapsula una query e legge il risultato della query un po' di righe alla volta. Un motivo è di evitare il superamento della memoria quando il risultato contiene un ampio numero di righe. Un altro motivo è restituire un riferimento a un cursore che una procedura archiviata ha creato, che permette all'intermediario di leggere le righe. Questo approccio fornisce un modo efficace di restituire set di righe di grandi dimensioni dalle procedure archiviate.</p>
           
           <p>Per utilizzare i cursori in una procedura archiviata NONATOMIC, posizionare il loop del cursore tra START TRANSACTION...COMMIT.</p>

            
            
            
            

               <p>Per impostare un cursore, è necessario prima dichiarare un variabile di cursore. Tutto l'accesso ai cursori in PL/pgSQL passa tramite le variabili di cursore, che sono sempre del tipo di dati speciali <code class="code">refcursor</code>. Un tipo di dati <code class="code">refcursor</code> semplicemente contiene un riferimento a un cursore. </p>
      <p>Puoi creare una variabile di cursore dichiarandola come tipo di variabile <code class="code">refcursor</code>. Oppure puoi utilizzare la seguente sintassi di dichiarazione del cursore.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">name CURSOR [ ( <code class="replaceable">arguments</code> ) ] FOR <code class="replaceable">query</code> ;
</code></pre> 
                  <p>Nell'esempio precedente, <code class="replaceable">arguments</code> (se specificato) è un elenco separato da virgole delle coppie <code class="replaceable">name datatype</code> dove ognuna definisce i nome da sostituite con i valori di parametro nella <code class="replaceable">query</code>. I valori effettivi che sostituiscono questi nomi vengono specificati più avanti, quando il cursore è aperto.</p>
                  <p>Di seguito vengono riportati degli esempi.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">DECLARE
  curs1 refcursor;
  curs2 CURSOR FOR SELECT * FROM tenk1;
  curs3 CURSOR (key integer) IS SELECT * FROM tenk1 WHERE unique1 = key;                     
</code></pre>
                  <p>Tutte e tre queste variabili hanno il tipo di dati <code class="code">refcursor</code>, ma la prima può essere utilizzata con qualsiasi query. Al contrario, il secondo ha una query pienamente specificata già associata e l'ultima ha una query parametrizzata associata. Il valore <code class="code">key</code> è sostituito da un valore di parametro intero quando il cursore è aperto. La variabile <code class="code">curs1</code> viene definita <em>non vincolata </em>perché non è vincolata ad alcuna query particolare.</p>
               
              <p>Prima di poter utilizzare un cursore per recuperare righe, deve essere aperto. PL/pgSQL ha tre forma di istruzione OPEN, delle quali due utilizzano variabili di cursore non vincolate e la terza utilizza una variabile di cursore vincolata:</p>
           <div class="itemizedlist">
              
              
              
           <ul class="itemizedlist"><li class="listitem">
                          <p>Open for select: la variabile del cursore viene aperta e riceve la query specificata da eseguire. Il cursore non può essere già aperto. Inoltre, deve essere stata dichiarata come cursore non vincolato (ovvero come variabile semplice <code class="code">refcursor</code>). La query SELECT viene trattata allo stesso modo delle altre istruzioni SELECT in PL/pgSQL. </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN cursor_name FOR SELECT ...;                     
</code></pre> 
                  <p>Di seguito viene riportato un esempio.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;    
</code></pre>
             </li><li class="listitem">
                  <p>Open for execute: la variabile del cursore viene aperta e riceve la query specificata da eseguire. Il cursore non può essere già aperto. Inoltre, deve essere stata dichiarata come cursore non vincolato (ovvero come variabile semplice <code class="code">refcursor</code>). La query è specificata come una espressione di stringa allo stesso modo del comando EXECUTE. Questo approccio fornisce flessibilità in modo che la query possa variare da un'esecuzione all'altra.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN cursor_name FOR EXECUTE query_string;
</code></pre>
                  <p>Di seguito viene riportato un esempio.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs1 FOR EXECUTE 'SELECT * FROM ' || quote_ident($1);</code></pre>                 
             </li><li class="listitem">
                  <p>Open a bound cursor: questa forma di OPEN viene utilizzata per aprire una variabile di cursore la quale query vi era associata al momento della dichiarazione. Il cursore non può essere già aperto. Un elenco di espressioni di valore dell'argomento deve apparire se e solo se il cursore può accettare argomenti. Questi valori vengono sostituiti nella query. </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN bound_cursor_name [ ( argument_values ) ];
</code></pre>

                  <p>Di seguito viene riportato un esempio.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs2;
OPEN curs3(42);
</code></pre>                            
             </li></ul></div>
                  <p>Dopo l'apertura di un cursore, puoi lavorarci utilizzando le istruzioni descritte di seguito. Queste istruzioni non devono aver luogo nella stessa procedura archiviata che ha aperto il cursore. Puoi restituire un valore <code class="code">refcursor</code> da una procedura archiviata e lasciare che l'intermediario lavori sul cursore. Tutti i portali sono chiusi implicitamente alla fine della transazione. In seguito, puoi utilizzare un valore <code class="code">refcursor</code> per far riferimento a un cursore aperto solo fino alla fine della transazione.</p>
           <div class="itemizedlist">
              
              
           <ul class="itemizedlist"><li class="listitem">
                  <p>FETCH recupera la riga successiva dal cursore in un target. Questo target può essere una variabile di riga, una variabile di record o un elenco separato da virgole di variabili semplici, come in SELECT INTO. Come con SELECT INTO; puoi controllare la variabile speciale FOUND per vedere se è stata ottenuta una riga.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">FETCH cursor INTO target;
</code></pre> 
                  <p>Di seguito viene riportato un esempio.</p> 
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">FETCH curs1 INTO rowvar;</code></pre>               
             </li><li class="listitem">
                  <p>CLOSE chiude il portale sotto un cursore aperto. È possibile utilizzare questa istruzione per rilasciare le risorse prima della fine della transazione. Puoi anche utilizzare questa istruzione per permettere alla variabile del cursore di essere nuovamente aperta.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CLOSE cursor;
</code></pre>
                <p>Di seguito viene riportato un esempio.</p> 
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CLOSE curs1;</code></pre>               
             </li></ul></div>
             
          
            <h2 id="r_PLpgSQL-messages-errors">RAISE</h2>
           
           
           <p>Utilizza l'istruzione <code class="code">RAISE level</code> per segnalare messaggi e generare errori.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE level 'format' [, variable [, ...]];</code></pre>
            <p>I livelli possibili sono NOTICE, INFO, LOG, WARNING e EXCEPTION. EXCEPTION genera un errore, che normalmente annulla la transazione corrente. Gli altri livelli generano solo messaggi di diversi livelli di priorità. </p>
           <p>Nella stringa formato, % viene sostituito dalla rappresentazione di stringa dell'argomento successivo opzionale. Scrivi %% per emetter un % letterale. Al momento, gli argomenti opzionali devono essere semplici variabili, non espressioni, e il formato deve essere un valore letterale di stringa semplice.</p>
            <p>Nell'esempio seguente, il valore di <code class="code">v_job_id</code> sostituisce % nella stringa.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;</code></pre>
            
           
            
           <p>Utilizza l'istruzione <code class="code">RAISE</code> per generare nuovamente l'eccezione rilevata da un blocco di gestione delle eccezioni. Questa istruzione è valida solo nei blocchi di gestione delle eccezioni delle procedure archiviate in modalità NONATOMIC.</p>
           <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE;</code></pre>
          
          <h2 id="r_PLpgSQL-transaction-control">Controllo della transazione</h2>
          <p>Utilizzare le istruzioni di controllo delle transazioni nel linguaggio PL/pgSQL utilizzato da Amazon Redshift. Per informazioni sull'utilizzo delle dichiarazioni COMMIT, ROLLBACK e TRUNCATE, all'interno di una procedura archiviata, consultare <a href="./stored-procedure-transaction-management.html">Gestione delle transazioni</a>. </p>  
          
          <p>Nelle procedure archiviate in modalità NONATOMIC, utilizza <code class="code">START TRANSACTION</code> per avviare un blocco di transazioni.</p>
          <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copia"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">START TRANSACTION;</code></pre>
          <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Nota</h6></div><div class="awsdocs-note-text"><p>Di seguito sono indicate le differenze tra l'istruzione PL/pgSQL START TRANSACTION e il comando SQL START TRANSACTION:</p><div class="itemizedlist">
               
               
            <ul class="itemizedlist"><li class="listitem"><p>All'interno delle procedure archiviate, START TRANSACTION non è sinonimo di BEGIN.</p></li><li class="listitem"><p>L'istruzione PL/pgSQL non supporta il livello di isolamento opzionale e le parole chiave di autorizzazione di accesso.</p></li></ul></div></div></div>

          
        <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Avvertimento" /> <strong>JavaScript è disabilitato o non è disponibile nel tuo browser.</strong></p><p>Per usare la documentazione AWS, JavaScript deve essere abilitato. Consulta le pagine della guida del browser per le istruzioni.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Convenzioni dei documenti</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./c_PLpgSQL-structure.html">Struttura di PL/pgSQL</div><div id="next" class="next-link" accesskey="n" href="./materialized-view-overview.html">Creazione di viste materializzate</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">Questa pagina ti è stata utile? - Sì</div><div class="content"><p>Grazie per averci comunicato che stiamo facendo un buon lavoro!</p><p>Se hai un momento, ti invitiamo a dirci che cosa abbiamo fatto che ti è piaciuto così possiamo offrirti altri contenuti simili.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">Questa pagina ti è stata utile? - No</div><div class="content"><p>Grazie per averci comunicato che questa pagina ha bisogno di essere modificata. Siamo spiacenti di non aver soddisfatto le tue esigenze.</p><p>Se hai un momento, ti invitiamo a dirci come possiamo migliorare la documentazione.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>