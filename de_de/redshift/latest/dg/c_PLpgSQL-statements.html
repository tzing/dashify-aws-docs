<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="de-DE"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Unterstützte PL/pgSQL-Anweisungen - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="c_PLpgSQL-statements" /><meta name="default_state" content="c_PLpgSQL-statements" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="description" content="Arbeiten mit den PL/pgSQL-Anweisungen, die von Amazon Redshift unterstützt werden." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="Datenbankentwicklerhandbuch" /><meta name="abstract" content="Erstellen und verwalten Sie ein Data Warehouse mit Amazon Redshift, einem vollständig verwalteten Petabyte-Data-Warehousing-Service auf Unternehmensniveau." /><meta name="guide-locale" content="de_de" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="Datenbankentwicklerhandbuch" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="Datenbankentwicklerhandbuch" /><meta id="panorama-serviceConsolePage" value="Unterstützte PL/pgSQL-Anweisungen" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Unterstützte PL/pgSQL-Anweisungen - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#c_PLpgSQL-statements" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,Cluster,Data Warehouse,Developer,Musterdaten,Datenbank,Database Developer,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Datenbankentwicklerhandbuch",
        "item" : "https://docs.aws.amazon.com/de_de/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Erstellen von gespeicherten Prozeduren in Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/de_de/redshift/latest/dg/stored-procedure-overview.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "PL/pgSQL-Sprachreferenz",
        "item" : "https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_pl_pgSQL_reference.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "Unterstützte PL/pgSQL-Anweisungen",
        "item" : "https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_pl_pgSQL_reference.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#c_PLpgSQL-statements" target="_blank" rel="noopener noreferrer" title="PDF öffnen"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Dokumentation</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">Datenbankentwicklerhandbuch</a></div><div id="page-toc-src"><a href="#r_PLpgSQL-assignment">Zuweisung</a><a href="#r_PLpgSQL-select-into">SELECT INTO</a><a href="#r_PLpgSQL-no-op">No-op</a><a href="#r_PLpgSQL-dynamic-sql">Dynamisches SQL</a><a href="#r_PLpgSQL-return">Ergebnis</a><a href="#r_PLpgSQL-conditionals-if">Bedingungen: IF </a><a href="#r_PLpgSQL-conditionals-case">Bedingungen: CASE</a><a href="#r_PLpgSQL-loops">Loops</a><a href="#r_PLpgSQL-cursors">Cursor</a><a href="#r_PLpgSQL-messages-errors">RAISE</a><a href="#r_PLpgSQL-transaction-control">Transaktionskontrolle</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><awsui-alert class="awsdocs-page-banner awsui-util-mb-l"><p>Die vorliegende Übersetzung wurde maschinell erstellt. Im Falle eines Konflikts oder eines Widerspruchs zwischen dieser übersetzten Fassung und der englischen Fassung (einschließlich infolge von Verzögerungen bei der Übersetzung) ist die englische Fassung maßgeblich.</p></awsui-alert><h1 class="topictitle" id="c_PLpgSQL-statements">Unterstützte PL/pgSQL-Anweisungen</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p> PL/pgSQL-Anweisungen erweitern SQL-Befehle mit prozeduralen Konstrukten, einschließlich Schleifen- und bedingten Ausdrücken, um den logischen Fluss zu steuern. Die meisten SQL-Befehle können verwendet werden, einschließlich der Data Manipulation Language (DML) wie COPY, UNLOAD und INSERT, und der Data Definition Language (DDL) wie CREATE TABLE. Eine Liste umfassender SQL-Befehle finden Sie unter <a href="./c_SQL_commands.html">SQL-Befehle</a>. Darüber hinaus werden die folgenden PL/pgSQL-Anweisungen von Amazon Redshift unterstützt. </p><div class="highlights" id="inline-topiclist"><h6>Themen</h6><ul><li><a href="#r_PLpgSQL-assignment">Zuweisung</a></li><li><a href="#r_PLpgSQL-select-into">SELECT INTO</a></li><li><a href="#r_PLpgSQL-no-op">No-op</a></li><li><a href="#r_PLpgSQL-dynamic-sql">Dynamisches SQL</a></li><li><a href="#r_PLpgSQL-return">Ergebnis</a></li><li><a href="#r_PLpgSQL-conditionals-if">Bedingungen: IF</a></li><li><a href="#r_PLpgSQL-conditionals-case">Bedingungen: CASE</a></li><li><a href="#r_PLpgSQL-loops">Loops</a></li><li><a href="#r_PLpgSQL-cursors">Cursor</a></li><li><a href="#r_PLpgSQL-messages-errors">RAISE</a></li><li><a href="#r_PLpgSQL-transaction-control">Transaktionskontrolle</a></li></ul></div>
            <h2 id="r_PLpgSQL-assignment">Zuweisung</h2>  
            
            <p>Die Zuweisungsanweisung ordnet einer Variablen einen Wert zu. Der Ausdruck muss einen einzelnen Wert zurückgeben.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">identifier := expression;</code></pre>
            
            <p>Die Verwendung des nicht standardmäßigen <code class="code">=</code> für die Anweisung, anstelle von <code class="code">:=</code>, wird auch akzeptiert.</p>
            
           <p>Wenn der Datentyp des Ausdrucks nicht mit dem Datentyp der Variablen übereinstimmt oder die Variable eine Größe oder Genauigkeit aufweist, wird der Ergebniswert implizit konvertiert.</p>
      <p>Es folgen Beispiele.</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">customer_number := 20;
tip := subtotal * 0.15;</code></pre>
            
          
            <h2 id="r_PLpgSQL-select-into">SELECT INTO</h2> 
            
           
            <p>Die SELECT INTO-Anweisung weist das Ergebnis mehrerer Spalten (jedoch nur eine Zeile) einer Datensatzvariablen oder Liste von skalaren Variablen zu.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">SELECT INTO <code class="replaceable">target</code> <code class="replaceable">select_expressions</code> FROM ...;</code></pre>  
            
            
            <p>In der vorhergehenden Syntax kann <code class="replaceable">Ziel</code> eine Datensatzvariable oder eine durch Kommata getrennte Liste einfacher Variablen und Datensatzfelder sein. Die <code class="replaceable">select_expressions</code>-Liste und der Rest des Befehls sind die gleichen wie bei regulärem SQL.</p>
            <p>Wenn eine Variablenliste als <code class="replaceable">Ziel</code> verwendet wird, müssen die ausgewählten Werte genau der Struktur des Ziels entsprechen oder ein Laufzeitfehler tritt auf. Wenn eine Datensatzvariable das Ziel ist, konfiguriert sie sich automatisch für den Zeilentyp der Abfrageergebnisspalten.</p>
            <p>Die INTO-Klausel kann fast überall in der SELECT-Anweisung erscheinen. Sie wird normalerweise direkt nach der SELECT-Klausel oder direkt vor der FROM-Klausel angezeigt. Das heißt, sie erscheint direkt vor oder nach der <code class="replaceable">select_expressions</code>-Liste.</p>
            <p>Wenn die Abfrage null Zeilen ausgibt, werden dem <code class="replaceable">Ziel</code> NULL-Werte zugewiesen. Wenn die Abfrage mehrere Zeilen ausgibt, wird die erste Zeile dem <code class="replaceable">Ziel</code> zugewiesen und der Rest wird verworfen. Sofern die Anweisung kein ORDER BY enthält, ist die erste Zeile nicht deterministisch.</p>
            <p>Um festzustellen, ob die Anweisung mindestens eine Zeile zurückgegeben hat, verwenden Sie die spezielle FOUND-Variable.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">SELECT INTO customer_rec * FROM cust WHERE custname = lname;
IF NOT FOUND THEN
  RAISE EXCEPTION 'employee % not found', lname;
END IF;
</code></pre>
            
            <p>Um herauszufinden, ob ein Datensatzergebnis null ist, können Sie die IS NULL-Bedingung verwenden. Es gibt keine Möglichkeit, zu bestimmen, ob zusätzliche Zeilen verworfen wurden. Das folgende Beispiel behandelt den Fall, bei dem keine Zeilen zurückgegeben wurden.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE select_into_null(return_webpage OUT varchar(256))
AS $$
DECLARE
  customer_rec RECORD;
BEGIN
  SELECT INTO customer_rec * FROM users WHERE user_id=3;
  IF customer_rec.webpage IS NULL THEN
    -- user entered no webpage, return "http://"
    return_webpage = 'http://';
  END IF;
END;
$$ LANGUAGE plpgsql;         
</code></pre>
            
          
            <h2 id="r_PLpgSQL-no-op">No-op</h2>  
           
            <p>Die no-op-Anweisung (<code class="code">NULL;</code>) ist eine Platzhalteranweisung, die nichts tut. Eine no-op-Anweisung kann anzeigen, dass eine Verzweigung einer IF-THEN-ELSE-Kette leer ist.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="">NULL;</code></pre> 
 
 
            
          
            <h2 id="r_PLpgSQL-dynamic-sql">Dynamisches SQL</h2>  
            
            <p>Zum Generieren dynamischer Befehle, die jedes Mal verschiedene Tabellen oder unterschiedliche Datentypen umfassen können, wenn sie von einer gespeicherten PL/pgSQL-Prozedur ausgeführt werden, verwenden Sie die <code class="code">EXECUTE</code>-Anweisung.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">EXECUTE <code class="replaceable">command-string</code> [ INTO target ];</code></pre> 
            
            <p>Im vorhergehenden Beispiel ist <code class="replaceable">command-string</code> ein Ausdruck, der eine Zeichenfolge (vom Typ Text) zum Ergebnis hat, die den auszuführenden Befehl enthält. Dieser <code class="replaceable">command-string</code>-Wert wird an die SQL-Engine gesendet. Es wird keine Ersetzung von PL/pgSQL-Variablen für die Befehlszeichenfolge vorgenommen. Die Werte von Variablen müssen in die Befehlszeichenfolge eingefügt werden, während sie erstellt wird.</p>
           
           <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Anmerkung</h6></div><div class="awsdocs-note-text"><p>Sie können COMMIT- und ROLLBACK-Anweisungen nicht innerhalb von dynamischem SQL verwenden. Informationen zur Verwendung von COMMIT- und ROLLBACK-Anweisungen innerhalb eines gespeicherten Verfahrens finden Sie unter <a href="./stored-procedure-transaction-management.html">Verwalten von Transaktionen</a>. </p></div></div> 
            
            <p>Bei der Arbeit mit dynamischen Befehlen müssen Sie sich häufig um das Escaping von einfachen Anführungszeichen kümmern. Wir empfehlen, dass Sie festen Text im Funktionstext mit der Dollaranführung in Anführungszeichen einschließen. Dynamische Werte, die in eine erstellte Abfrage eingefügt werden sollen, erfordern eine spezielle Vorgehensweisen, da sie selber Anführungszeichen enthalten können. Das folgende Beispiel setzt die Dollaranführung für die gesamte Funktion voraus, daher müssen keine doppelten Anführungszeichen verwendet werden.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">EXECUTE 'UPDATE tbl SET '
  || quote_ident(colname)
  || ' = '
  || quote_literal(newvalue)
  || ' WHERE key = '
  || quote_literal(keyvalue);               
</code></pre>
            
            <p>Das vorhergehende Beispiel zeigt die Funktionen <code class="code">quote_ident(text)</code> und <code class="code">quote_literal(text)</code>. Dieses Beispiel leitet Variablen, die Spalten- und Tabellenkennungen enthalten, an die <code class="code">quote_ident</code>-Funktion weiter. Es übermittelt auch Variablen, die Literalzeichenfolgen im erstellten Befehl enthalten, an die <code class="code">quote_literal</code>-Funktion. Beide Funktionen unternehmen alle erforderlichen Schritte, um den in doppelten oder einfachen Anführungszeichen eingeschlossenen Eingabetext entsprechend zurückzugeben. Dabei sind alle eingebetteten speziellen Zeichen ordnungsgemäß mit einem Escape-Zeichen versehen.</p>
            <p>Die Dollaranführung ist nur nützlich, wenn Sie Anführungszeichen für festen Text setzen. Schreiben Sie das vorhergehende Beispiel nicht in folgendem Format.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">EXECUTE 'UPDATE tbl SET '
  || quote_ident(colname)
  || ' = $$'
  || newvalue
  || '$$ WHERE key = '
  || quote_literal(keyvalue);               
</code></pre>
            
            <p>Sie tun dies nicht, weil im Beispiel Fehler auftreten, wenn der Inhalt von <code class="code">newvalue</code> zufällig $$ enthält. Dasselbe Problem gilt für alle anderen Dollaranführungstrennzeichen, die Sie auswählen können. Verwenden Sie die <code class="code">quote_literal</code>-Funktion, um vorher nicht bekannten Text sicher mit Anführungszeichen zu versehen.</p>
            
          
            <h2 id="r_PLpgSQL-return">Ergebnis</h2>   
            
            <p>Die RETURN-Anweisung wird aus einer gespeicherten Prozedur zum Aufrufer zurückgegeben.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="">RETURN;</code></pre>
            
            <p>Es folgt ein Beispiel.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE return_example(a int)
AS $$  
BEGIN
  FOR b in 1..10 LOOP
    IF b &lt; a THEN
      RAISE INFO 'b = %', b;
    ELSE
      RETURN;
    END IF;
  END LOOP;
END;
$$ LANGUAGE plpgsql;               
</code></pre>
            
          
            <h2 id="r_PLpgSQL-conditionals-if">Bedingungen: IF</h2>  
           
           
            
            <p>Die IF-Bedingungsanweisung kann folgende Formen in der PL/pgSQL-Sprache annehmen, die Amazon Redshift verwendet:</p>
            
            
            <div class="itemizedlist">
                
               
               
               
                  

                
            
            <ul class="itemizedlist"><li class="listitem"><p>IF ... THEN</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
END IF;
</code></pre>
                  
            <p>Es folgt ein Beispiel.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF v_user_id &lt;&gt; 0 THEN
  UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;               
</code></pre>
            
            </li><li class="listitem"><p>IF ... THEN ... ELSE</p>
 <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
ELSE
  statements
END IF;
</code></pre>
                  
               <p>Es folgt ein Beispiel.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF parentid IS NULL OR parentid = ''
THEN
  return_name = fullname;
  RETURN;
ELSE
  return_name = hp_true_filename(parentid) || '/' || fullname;
  RETURN;
END IF;           
</code></pre>
                  
               </li><li class="listitem"><p>IF ... THEN ... ELSIF ... THEN ... ELSE </p>
                  <p>Das Schlüsselwort ELSIF kann auch als ELSEIF angegeben werden.</p>                  
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
[ ELSIF boolean-expression THEN
  statements
[ ELSIF boolean-expression THEN
  statements
    ...] ]
[ ELSE
  statements ]
END IF;
</code></pre>                  
               

               
               <p>Es folgt ein Beispiel.</p>
               
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF number = 0 THEN
  result := 'zero';
ELSIF number &gt; 0 THEN
  result := 'positive';
ELSIF number &lt; 0 THEN
  result := 'negative';
ELSE
  -- the only other possibility is that number is null
  result := 'NULL';
END IF;                  
</code></pre>
               </li></ul></div>
            
           
            
          
            <h2 id="r_PLpgSQL-conditionals-case">Bedingungen: CASE</h2>  
           <p>Die CASE-Bedingungsanweisung kann folgende Formen in der PL/pgSQL-Sprache annehmen, die Amazon Redshift verwendet:</p>
            <div class="itemizedlist">
                
                 

            <ul class="itemizedlist"><li class="listitem"><p>Einfaches CASE </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CASE <code class="replaceable">search-expression</code>
WHEN <code class="replaceable">expression</code> [, <code class="replaceable">expression</code> [ ... ]] THEN
  <code class="replaceable">statements</code>
[ WHEN <code class="replaceable">expression</code> [, <code class="replaceable">expression</code> [ ... ]] THEN
  <code class="replaceable">statements</code>
  ... ]
[ ELSE
  <code class="replaceable">statements</code> ]
END CASE;
</code></pre>
                  
                  <p>Eine einfache CASE-Anweisung stellt eine Bedingungsausführung basierend auf der Gleichheit von Operanden bereit.</p>
                  
                  <p>Der <code class="replaceable">search-expression</code>-Wert wir ein Mal ausgewertet und aufeinanderfolgend mit jedem <code class="replaceable">Ausdruck</code> in der WHEN-Klausel verglichen. Bei einer Übereinstimmung werden die entsprechenden <code class="replaceable">Anweisungen</code> ausgeführt und die Kontrolle wird an die nächste Anweisung nach END CASE übergeben. Nachfolgende WHEN-Ausdrücke werden nicht ausgewertet. Bei keiner Übereinstimmung werden die ELSE-<code class="replaceable">Anweisungen</code> ausgeführt. Wenn ELSE jedoch nicht vorhanden ist, wird eine CASE_NOT_FOUND-Ausnahme ausgelöst.</p>
                  
               <p>Es folgt ein Beispiel.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CASE x
WHEN 1, 2 THEN
  msg := 'one or two';
ELSE
  msg := 'other value than one or two';
END CASE;                  
</code></pre>
                  
               </li><li class="listitem"><p>Gesuchtes CASE </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CASE
WHEN <code class="replaceable">boolean-expression</code> THEN
  statements
[ WHEN <code class="replaceable">boolean-expression</code> THEN
  statements
  ... ]
[ ELSE
  statements ]
END CASE;
</code></pre>
                  
                  <p>Die gesuchte CASE-Anweisung stellt Bedingungsausführungen basierend auf der Wahrheit von booleschen Ausdrücken bereit. </p>
                  
                  <p>Der <code class="replaceable">boolean-expression</code> jeder WHEN-Klausel wird dann ausgewertet, bis einer gefunden wird, der als Ergebnis „true“ zurück gibt. Anschließend werden die entsprechenden Anweisungen ausgeführt und die Kontrolle wird an die nächste Anweisung nach END CASE übergeben. Nachfolgende WHEN-<code class="replaceable">Ausdrücke</code> werden nicht ausgewertet. Wenn kein „true“-Ergebnis gefunden wird, werden die ELSE-<code class="replaceable">Anweisungen</code> ausgeführt. Wenn ELSE jedoch nicht vorhanden ist, wird eine CASE_NOT_FOUND-Ausnahme ausgelöst.</p>
                  
                  <p>Es folgt ein Beispiel.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CASE
WHEN x BETWEEN 0 AND 10 THEN
  msg := 'value is between zero and ten';
WHEN x BETWEEN 11 AND 20 THEN
  msg := 'value is between eleven and twenty';
END CASE;                                
</code></pre>
                  
               </li></ul></div>                      
            
          
            <h2 id="r_PLpgSQL-loops">Loops</h2>  
            
           <p>Loop-Anweisungen können folgende Formen in der PL/pgSQL-Sprache annehmen, die Amazon Redshift verwendet:</p>
            <div class="itemizedlist">
                
               
                 
               
                 
               
                
               
                 
               
                 
               
               
               
                                  
               
               
            <ul class="itemizedlist"><li class="listitem"><p>Einfacher Loop </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
LOOP
  statements
END LOOP [ label ];
</code></pre>
                  
                  <p>Ein einfacher Loop definiert einen bedingungslosen Loop, der unbegrenzt wiederholt wird, bis er von einer EXIT- oder RETURN-Anweisung beendet wird. Die optionale Bezeichnung kann von EXIT- und CONTINUE-Anweisungen in verschachtelten Loops verwendet werden, um anzugeben, auf welchen Loop sich die EXIT- und CONTINUE-Anweisungen beziehen.</p>
                  
               <p>Es folgt ein Beispiel.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE simple_loop()
LANGUAGE plpgsql
AS $$
BEGIN
  &lt;&lt;simple_while&gt;&gt;
  LOOP
    RAISE INFO 'I am raised once';  
    EXIT simple_while;
    RAISE INFO 'I am not raised';
  END LOOP;
  RAISE INFO 'I am raised once as well';
END;
$$;                
</code></pre>

               </li><li class="listitem"><p>Exit-Loop</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">EXIT [ <code class="replaceable">label</code> ] [ WHEN <code class="replaceable">expression</code> ];
</code></pre> 
                 <p>Wenn <code class="replaceable">Bezeichnung</code> nicht vorhanden ist, wird der innerste Loop beendet und die Anweisung als nächstes ausgeführt, die dem END LOOP folgt. Wenn <code class="replaceable">Bezeichnung</code> vorhanden ist, muss es sich um die Bezeichnung des aktuellen oder eines verschachtelten Loops oder Blocks der äußeren Ebene handeln. Anschließend wird der benannte Loop oder Block beendet und die Kontrolle fährt mit der Anweisung nach dem entsprechenden END des Loops oder Blocks fort.</p>
                  <p>Wenn WHEN angegeben ist, wird der Loop nur beendet, wenn <code class="replaceable">Ausdruck</code> „true“ lautet. Andernfalls wird die Kontrolle an die Anweisung nach EXIT weitergeleitet.</p>
                  <p>Sie können EXIT mit allen Arten von Loops verwenden. Es ist nicht auf die Nutzung mit bedingungslosen Loops beschränkt.</p>
                  <p>Bei Verwendung mit einem BEGIN-Block übergibt EXIT die Kontrolle an die nächste Anweisung nach dem Ende des Blocks. Zu diesem Zweck muss eine Bezeichnung verwendet werden. Ein nicht gekennzeichnetes EXIT gilt nie als übereinstimmend mit einem BEGIN-Block.</p>
                  <p>Es folgt ein Beispiel.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE simple_loop_when(x int)
LANGUAGE plpgsql
AS $$
DECLARE i INTEGER := 0;
BEGIN
  &lt;&lt;simple_loop_when&gt;&gt;
  LOOP
    RAISE INFO 'i %', i;
    i := i + 1;
    EXIT simple_loop_when WHEN (i &gt;= x);
  END LOOP;
END;
$$;                     
</code></pre>
               </li><li class="listitem"><p>Continue-Loop </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CONTINUE [ <code class="replaceable">label</code> ] [ WHEN <code class="replaceable">expression</code> ];
</code></pre> 
                  <p>Wenn <code class="replaceable">Bezeichnung</code> nicht angegeben ist, springt die Ausführung zur nächsten Iteration des innersten Loops. Das heißt, alle im Loop-Text verbleibenden Anweisungen werden übersprungen. Die Kontrolle geht dann an den Loop-Kontrollausdruck (falls vorhanden) zurück, um festzulegen, ob eine weitere Loop-Iteration erforderlich ist. Wenn <code class="replaceable">Bezeichnung</code> vorhanden ist, wird die Bezeichnung des Loops angegeben, dessen Ausführung fortgesetzt wird.</p>
                  <p>Wenn WHEN angegeben ist, wird die nächste Iteration des Loops nur dann begonnen, wenn <code class="replaceable">Ausdruck</code> „true“ lautet. Andernfalls wird die Kontrolle an die Anweisung nach CONTINUE weitergeleitet.</p>
                  <p>Sie können CONTINUE mit allen Arten von Loops verwenden. Es ist nicht auf die Nutzung mit bedingungslosen Loops beschränkt.</p>
                  
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CONTINUE mylabel;
</code></pre> 
                  
               </li><li class="listitem"><p>WHILE-Loop </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
WHILE expression LOOP
  statements
END LOOP [ label ];
</code></pre> 
                  
               <p>Die WHILE-Anweisung wiederholt eine Reihenfolge von Anweisungen solange der <code class="replaceable">boolean-expression</code> als „true“ ausgewertet wird. Der Ausdruck wird kurz vor jedem Eintritt in den Loop-Text geprüft.</p> 
               <p>Es folgt ein Beispiel.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
  -- some computations here
END LOOP;

WHILE NOT done LOOP
  -- some computations here
END LOOP;                  
</code></pre>
               </li><li class="listitem"><p>FOR-Loop (Ganzzahlvariante) </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR name IN [ REVERSE ] expression .. expression LOOP
  statements
END LOOP [ label ];
</code></pre> 
                  
                  <p>Der FOR-Loop (Ganzzahlvariante) erstellt einen Loop, der über einen Bereich von Ganzzahlwerten iteriert. Der Variablenname wird automatisch als Typ Ganzzahl definiert und existiert nur innerhalb des Loops. Jede vorhandene Definition des Variablennamen wird innerhalb des Loops ignoriert. Die zwei Ausdrücke, welche die Unter- und Obergrenze des Bereichs angeben, werden beim Eintritt in den Loop einmal ausgewertet. Wenn Sie REVERSE angeben, wird der Schrittwert nach jeder Iteration eher subtrahiert als addiert.</p> 
                  
                  <p>Wenn die Untergrenze größer ist als die Obergrenze (oder kleiner, im REVERSE-Fall), wird der Loop-Text nicht ausgeführt. Es wird kein Fehler ausgegeben.</p>
                  
                  <p>Wenn eine Bezeichnung einem FOR-Loop angefügt ist, können Sie unter Verwendung dieser Bezeichnung mit einem qualifizierten Namen auf die Ganzzahl-Loop-Variable verweisen.</p>
                  
               <p>Es folgt ein Beispiel.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">FOR i IN 1..10 LOOP
  -- i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop
END LOOP;

FOR i IN REVERSE 10..1 LOOP
  -- i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop
END LOOP;                
</code></pre>  

               </li><li class="listitem"><p>FOR-Loop (Ergebnissatzvariante) </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR <code class="replaceable">target</code> IN query LOOP
  statements
END LOOP [ label ];
</code></pre>
                  <p>Das <code class="replaceable">Ziel</code> ist eine Datensatzvariable oder eine durch Kommata getrennte Liste skalarer Variablen. Das Ziel wird jeder Zeile aufeinanderfolgend zugewiesen, die aus der Abfrage resultiert, und der Loop-Text wird für jede Abfrage ausgeführt.</p> 
                  
                  <p>Der FOR-Loop (Ergebnissatzvariante) ermöglicht einer gespeicherten Prozedur, die Ergebnisse einer Abfrage zu durchlaufen und diese Daten entsprechend zu bearbeiten.</p>
                  <p>Es folgt ein Beispiel.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE PROCEDURE cs_refresh_reports() AS $$
DECLARE
  reports RECORD;
BEGIN
  FOR reports IN SELECT * FROM cs_reports ORDER BY sort_key LOOP
    -- Now "reports" has one record from cs_reports
    EXECUTE 'TRUNCATE TABLE ' || quote_ident(reports.report_name);
    EXECUTE 'INSERT INTO ' || quote_ident(reports.report_name) || ' ' || reports.report_query;
  END LOOP;
  RETURN;
END;
$$ LANGUAGE plpgsql;                   
</code></pre>
               </li><li class="listitem"><p>FOR-Loop mit dynamischem SQL</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR record_or_row IN EXECUTE text_expression LOOP 
  statements
END LOOP;
</code></pre>
                  
                  <p>Der FOR-Loop mit dynamischem SQL ermöglicht einer gespeicherten Prozedur, die Ergebnisse einer dynamischen Abfrage zu durchlaufen und diese Daten entsprechend zu bearbeiten.</p>  
                  
               <p>Es folgt ein Beispiel.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE for_loop_dynamic_sql(x int)
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  query text;
BEGIN
  query := 'SELECT * FROM tbl_dynamic_sql LIMIT ' || x;
  FOR rec IN EXECUTE query
  LOOP
    RAISE INFO 'a %', rec.a;
  END LOOP;
END;
$$;</code></pre>
               </li></ul></div>                      
            
          
            <h2 id="r_PLpgSQL-cursors">Cursor</h2>  
            
            <p>Statt eine ganze Abfrage auf einmal auszuführen, können Sie einen Cursor einrichten. Ein <em>Cursor </em>kapselt eine Abfrage und liest jeweils wenige Zeilen des Abfrageergebnisses. Ein Grund hierfür ist das Vermeiden von Speicherüberlauf, wenn das Ergebnis eine große Anzahl von Zeilen enthält. Ein weiterer Grund ist die Rückgabe einer Referenz an einen Cursor, den eine gespeicherte Prozedur erstellt hat. Dies erlaubt dem Aufrufer, die Zeilen zu lesen. Dieser Ansatz bietet eine effiziente Methode, große Zeilensätze von gespeicherten Prozeduren zurückzugeben.</p>
           
           <p>Um Cursor in einer gespeicherten NONATOMIC-Prozedur zu verwenden, platzieren Sie die Cursor-Schleife zwischen START TRANSACTION...COMMIT.</p>

            
            
            
            

               <p>Zum Einrichten eines Cursors deklarieren Sie zuerst eine Cursor-Variable. Jeder Zugriff auf Cursor in PL/pgSQL durchläuft Cursor-Variablen, die immer vom speziellen Datentyp  sind <code class="code">refcursor</code>. Ein <code class="code">refcursor</code>-Datentyp hält einfach eine Referenz auf einen Cursor. </p>
      <p>Sie können eine Cursor-Variable erstellen, indem Sie sie als Variable des Typs  deklarieren <code class="code">refcursor</code>. Alternativ können Sie die folgende Cursor-Deklarationssyntax verwenden.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">name CURSOR [ ( <code class="replaceable">arguments</code> ) ] FOR <code class="replaceable">query</code> ;
</code></pre> 
                  <p>Im vorhergehenden Beispiel ist <code class="replaceable">Argumente</code> (wenn angegeben) eine durch Kommata getrennte Liste von <code class="replaceable">Name-Datentyp</code>-Paaren, die jeweils Namen definieren, die in <code class="replaceable">Abfrage</code> durch Parameterwerte ersetzt werden sollen. Die tatsächlichen Werte, durch die diese Namen ersetzt werden sollen, werden später beim Öffnen des Cursors angegeben.</p>
                  <p>Es folgen Beispiele.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">DECLARE
  curs1 refcursor;
  curs2 CURSOR FOR SELECT * FROM tenk1;
  curs3 CURSOR (key integer) IS SELECT * FROM tenk1 WHERE unique1 = key;                     
</code></pre>
                  <p>Alle drei dieser Variablen haben den Datentyp <code class="code">refcursor</code>, aber die erste kann mit jeder Abfrage verwendet werden. Im Gegensatz dazu verfügt die zweite über eine vollständig angegebene Abfrage, die bereits an sie gebunden ist, und die letzte über eine an sie gebundene parametrisierte Abfrage. Der <code class="code">key</code>-Wert wird durch einen Ganzzahl-Parameterwert ersetzt, wenn der Cursor geöffnet wird. Die Variable <code class="code">curs1</code> gilt als <em>ungebunden, </em> weil sie nicht an eine bestimmte Abfrage gebunden ist.</p>
               
              <p>Bevor Sie einen Cursor zum Abrufen von Zeilen verwenden können, muss er geöffnet werden. PL/pgSQL verfügt über drei Formen der OPEN-Anweisung. Zwei davon verwenden ungebundene Cursor-Variablen und die dritte eine gebundene Cursor-Variable:</p>
           <div class="itemizedlist">
              
              
              
           <ul class="itemizedlist"><li class="listitem">
                          <p>Öffnen zum Auswählen: Die Cursor-Variable wird geöffnet und die angegebene Abfrage zur Ausführung zugeteilt. Der Cursor darf nicht bereits geöffnet sein. Außerdem muss er als ungebundener Cursor deklariert worden sein (das heißt, als eine einfache <code class="code">refcursor</code>-Variable). Die SELECT-Abfrage wird genauso wie andere SELECT-Anweisungen in PL/pgSQL behandelt. </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN cursor_name FOR SELECT ...;                     
</code></pre> 
                  <p>Es folgt ein Beispiel.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;    
</code></pre>
             </li><li class="listitem">
                  <p>Öffnen zum Ausführen: Die Cursor-Variable wird geöffnet und die angegebene Abfrage zur Ausführung zugeteilt. Der Cursor darf nicht bereits geöffnet sein. Außerdem muss er als ungebundener Cursor deklariert worden sein (das heißt, als eine einfache <code class="code">refcursor</code>-Variable). Die Abfrage wird auf die gleiche Art und Weise als Zeichenfolgeausdruck angegeben wie im EXECUTE-Befehl. Dieser Ansatz bietet Flexibilität, sodass die Abfrage von einer Ausführung zur nächsten variieren kann.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN cursor_name FOR EXECUTE query_string;
</code></pre>
                  <p>Es folgt ein Beispiel.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs1 FOR EXECUTE 'SELECT * FROM ' || quote_ident($1);</code></pre>                 
             </li><li class="listitem">
                  <p>Öffnen eines gebundenen Cursors: Diese Form von OPEN wird zum Öffnen einer Cursor-Variablen verwendet, deren Abfrage beim Deklarieren an sie gebunden wurde. Der Cursor darf nicht bereits geöffnet sein. Eine Liste der tatsächlichen Argumentwertausdrücke muss angezeigt werden, wenn und nur wenn der Cursor zur Verwendung von Argumenten deklariert wurde. Diese Werte werden in der Abfrage ersetzt. </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN bound_cursor_name [ ( argument_values ) ];
</code></pre>

                  <p>Es folgt ein Beispiel.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs2;
OPEN curs3(42);
</code></pre>                            
             </li></ul></div>
                  <p>Nachdem ein Cursor geöffnet wurde, können Sie mit ihm arbeiten, indem Sie die Anweisungen verwenden, die im Folgenden beschrieben sind. Diese Anweisungen müssen nicht in derselben gespeicherten Prozedur ausgeführt werden, die den Cursor geöffnet hat. Sie können einen <code class="code">refcursor</code>-Wert aus einer gespeicherten Prozedur zurück geben und den Aufrufer mit dem Cursor arbeiten lassen. Alle Portale werden am Transaktionsende implizit geschlossen. Daher können Sie einen <code class="code">refcursor</code>-Wert für das Referenzieren eines offenen Cursors nur bis zum Ende der Transaktion verwenden.</p>
           <div class="itemizedlist">
              
              
           <ul class="itemizedlist"><li class="listitem">
                  <p>FETCH überträgt die nächste Zeile aus dem Cursor in ein Ziel. Dieses Ziel kann eine Zeilenvariable, eine Datensatzvariable oder eine durch Kommata getrennte Liste von einfachen Variablen wie bei SELECT INTO sein. Wie bei SELECT INTO können Sie in der speziellen FOUND-Variable überprüfen, ob eine Zeile bezogen wurde.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">FETCH cursor INTO target;
</code></pre> 
                  <p>Es folgt ein Beispiel.</p> 
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">FETCH curs1 INTO rowvar;</code></pre>               
             </li><li class="listitem">
                  <p>CLOSE schließt das Portal, das einem offenen Cursor zugrunde liegt. Sie können diese Anweisung verwenden, um Ressourcen noch vor dem Ende der Transaktion freizugeben. Sie können diese Anweisung auch verwenden, um die Cursor-Variable zu entblocken, damit sie wieder geöffnet werden kann.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CLOSE cursor;
</code></pre>
                <p>Es folgt ein Beispiel.</p> 
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CLOSE curs1;</code></pre>               
             </li></ul></div>
             
          
            <h2 id="r_PLpgSQL-messages-errors">RAISE</h2>
           
           
           <p>Verwenden Sie die <code class="code">RAISE level</code>-Anweisung zum Melden von Nachrichten und zum Auslösen von Fehlern.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE level 'format' [, variable [, ...]];</code></pre>
            <p>Mögliche Ebenen sind NOTICE, INFO, LOG, WARNING und EXCEPTION. EXCEPTION meldet einen Fehler, der die aktuelle Transaktion in der Regel abbricht. Die anderen Ebenen generieren nur Nachrichten mit unterschiedlichen Prioritätsstufen. </p>
           <p>Innerhalb der Formatzeichenfolge wird % durch die Zeichenfolgedarstellung des nächsten optionalen Arguments ersetzt. Schreiben Sie %% zum Übermitteln des Literals %. Derzeit müssen optionale Argumente einfache Variablen sein und nicht Ausdrücke, und das Format muss ein einfaches Zeichenfolgeliteral sein.</p>
            <p>Im folgenden Beispiel ersetzt der Wert von <code class="code">v_job_id</code> das % in der Zeichenfolge.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;</code></pre>
            
           
            
           <p>Verwenden Sie die <code class="code">RAISE</code>-Anweisung zum erneuten Auslösen der Ausnahme, die vom Ausnahmebehandlungsblock abgefangen wurde. Diese Anweisung ist nur in Ausnahmebehandlungsblöcken von gespeicherten Prozeduren im NONATOMIC-Modus gültig.</p>
           <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE;</code></pre>
          
          <h2 id="r_PLpgSQL-transaction-control">Transaktionskontrolle</h2>
          <p>Sie können mit Transaktionskontroll-Anweisungen in der PL/pgSQL-Sprache arbeiten, die Amazon Redshift verwendet. Informationen zur Verwendung von COMMIT-, ROLLBACK- und TRUNCATE-Anweisungen innerhalb eines gespeicherten Verfahrens finden Sie unter <a href="./stored-procedure-transaction-management.html">Verwalten von Transaktionen</a>. </p>  
          
          <p>Verwenden Sie für gespeicherte Prozeduren im NONATOMIC-Modus <code class="code">START TRANSACTION</code>, um einen Transaktionsblock zu starten.</p>
          <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Kopieren"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">START TRANSACTION;</code></pre>
          <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Anmerkung</h6></div><div class="awsdocs-note-text"><p>Die PL/pgSQL-Anweisung START TRANSACTION unterscheidet sich folgendermaßen vom SQL-Befehl START TRANSACTION:</p><div class="itemizedlist">
               
               
            <ul class="itemizedlist"><li class="listitem"><p>In gespeicherten Prozeduren ist START TRANSACTION nicht gleichbedeutend mit BEGIN.</p></li><li class="listitem"><p>Die PL/pgSQL-Anweisung unterstützt keine optionalen Schlüsselwörter für Isolationsstufe und Zugriffsberechtigungen.</p></li></ul></div></div></div>

          
        <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Warnung" /> <strong>JavaScript ist in Ihrem Browser nicht verfügbar oder deaktiviert.</strong></p><p>Zur Nutzung der AWS-Dokumentation muss JavaScript aktiviert sein. Weitere Informationen finden auf den Hilfe-Seiten Ihres Browsers.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Dokumentkonventionen</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./c_PLpgSQL-structure.html">Struktur von PL/pgSQL</div><div id="next" class="next-link" accesskey="n" href="./materialized-view-overview.html">Erstellen von materialisierten Ansichten</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">Hat Ihnen diese Seite geholfen? – Ja</div><div class="content"><p>Vielen Dank, dass Sie uns mitgeteilt haben, dass wir gute Arbeit geleistet haben!</p><p>Würden Sie sich einen Moment Zeit nehmen, um uns mitzuteilen, was wir richtig gemacht haben, damit wir noch besser werden?</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">Hat Ihnen diese Seite geholfen? – Nein</div><div class="content"><p>Vielen Dank, dass Sie uns mitgeteilt haben, dass diese Seite überarbeitet werden muss. Es tut uns Leid, dass wir Ihnen nicht weiterhelfen konnten.</p><p>Würden Sie sich einen Moment Zeit nehmen, um uns mitzuteilen, wie wir die Dokumentation verbessern können?</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>