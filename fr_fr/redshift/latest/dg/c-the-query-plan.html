<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="fr-FR"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Plan de requête - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="c-the-query-plan" /><meta name="default_state" content="c-the-query-plan" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-the-query-plan.html" /><meta name="description" content="Décrit comment interpréter un plan de requête." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="Guide du développeur de base de données" /><meta name="abstract" content="Créez et gérez un entrepôt de données avec Amazon Redshift, service d’entrepôt de données au niveau de l’entreprise, pouvant atteindre plusieurs Po et entièrement géré." /><meta name="guide-locale" content="fr_fr" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-the-query-plan.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c-the-query-plan.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c-the-query-plan.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c-the-query-plan.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c-the-query-plan.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c-the-query-plan.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c-the-query-plan.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c-the-query-plan.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c-the-query-plan.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-the-query-plan.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-the-query-plan.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c-the-query-plan.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c-the-query-plan.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c-the-query-plan.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c-the-query-plan.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-the-query-plan.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c-the-query-plan.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c-the-query-plan.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c-the-query-plan.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/c-the-query-plan.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/c-the-query-plan.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c-the-query-plan.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="Guide du développeur de base de données" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="Guide du développeur de base de données" /><meta id="panorama-serviceConsolePage" value="Plan de requête" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Plan de requête - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#c-the-query-plan" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-the-query-plan.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-the-query-plan.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-the-query-plan.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,cluster,entrepôt de données,développeur,exemples de données,database,développeur de base de données,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Guide du développeur de base de données",
        "item" : "https://docs.aws.amazon.com/fr_fr/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Réglage de performances des requêtes",
        "item" : "https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-optimizing-query-performance.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Traitement des requêtes",
        "item" : "https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-query-processing.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "Plan de requête",
        "item" : "https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-query-processing.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#c-the-query-plan" target="_blank" rel="noopener noreferrer" title="Ouvrir le PDF"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Documentation</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">Guide du développeur de base de données</a></div><div id="page-toc-src"><a href="#EXPLAIN-operators">Opérateurs EXPLAIN</a><a href="#joins-in-EXPLAIN">Jointures dans EXPLAIN</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><awsui-alert class="awsdocs-page-banner awsui-util-mb-l"><p>Les traductions sont fournies par des outils de traduction automatique. En cas de conflit entre le contenu d'une traduction et celui de la version originale en anglais, la version anglaise prévaudra.</p></awsui-alert><h1 class="topictitle" id="c-the-query-plan">Plan de requête</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p>Vous pouvez utiliser le plan de requête pour obtenir des informations sur les opérations individuelles requises pour exécuter une requête. Avant de travailler avec un plan de requête, nous vous recommandons de comprendre d’abord comment Amazon Redshift gère le traitement des requêtes et la création des plans de requête. Pour plus d'informations, consultez <a href="./c-query-planning.html">Workflow d’exécution et de planification de requête</a>.</p><p>Pour créer un plan de requête, exécutez la commande <a href="./r_EXPLAIN.html">EXPLAIN</a> suivie du texte de la requête réelle. Le plan de requête vous fournit les informations suivantes :</p><div class="itemizedlist">
             
             
             
             
             
         <ul class="itemizedlist"><li class="listitem">
               <p>Les opérations effectuées par le moteur d’exécution, en lisant les résultats de bas en haut.</p>
            </li><li class="listitem">
               <p>Le type d’étape effectué par chaque opération.</p>
            </li><li class="listitem">
               <p>Les tables et les colonnes utilisées dans chaque opération.</p>
            </li><li class="listitem">
               <p>La quantité de données traitée dans chaque opération, en termes de nombre de lignes et de largeur de données en octets.</p>
            </li><li class="listitem">
               <p>Le coût relatif de l’opération. <em>Cost</em> est une mesure qui compare les durées d’exécution relatives des étapes au sein d’un plan. Cost ne fournit pas d’informations précises sur les durées d’exécution ou la consommation de mémoire réelle, ni de comparaison significative des plans d’exécution. Il vous donne une indication des opérations d’une requête qui consomment le plus de ressources.</p>
            </li></ul></div><p>La commande EXPLAIN n’exécute pas réellement la requête. Elle montre seulement le plan que Amazon Redshift exécutera si la requête est exécutée dans les conditions d’utilisation actuelles. Si vous modifiez le schéma ou les données d’une table et que vous exécutez <a href="./r_ANALYZE.html">ANALYSE</a> à nouveau pour mettre à jour les métadonnées statistiques, le plan de requête peut être différent.</p><p>La sortie du plan de requête par EXPLAIN est une vue simplifiée et d’ensemble de l’exécution des requêtes. Il n’illustre pas les détails du traitement de requête parallèle. Pour consulter des informations détaillées, vous devez exécuter la requête elle-même, puis obtenir des informations récapitulatives sur la requête dans la vue SVL_QUERY_SUMMARY ou SVL_QUERY_REPORT. Pour plus d’informations sur l’utilisation de ces vues, consultez <a href="./c-analyzing-the-query-summary.html">Analyse du résumé de la requête</a>.</p><p>L’exemple suivant illustre la sortie EXPLAIN pour une requête GROUP BY simple sur la table EVENT :</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select eventname, count(*) from event group by eventname;

                            QUERY PLAN
-------------------------------------------------------------------
XN HashAggregate  (cost=131.97..133.41 rows=576 width=17)
  -&gt;  XN Seq Scan on event  (cost=0.00..87.98 rows=8798 width=17)</code></pre><p>EXPLAIN renvoie les métriques suivantes pour chaque opération :</p><div class="variablelist">
             
             
             
         <dl>
               <dt><b><span class="term">Coût</span></b></dt>
               <dd>
                  <p>Valeur relative utile pour comparer les opérations au sein d’un plan. Cost se compose de deux valeurs décimales séparées par des deux points, par exemple <code class="code">cost=131.97..133.41</code>. La première valeur, dans le cas présent 131.97, fournit le coût relatif du renvoi de la première ligne pour cette opération. La seconde valeur, dans le cas présent 133.41, fournit le coût relatif de l’exécution de l’opération. Les coûts du plan de requête sont cumulatifs au fur et à mesure que vous lisez le plan. Le  HashAggregate  coût de cet exemple (131.97.. 133.41) inclut le coût du Seq Scan situé en dessous (0,00.. 87,98).</p>
               </dd>
            
               <dt><b><span class="term">Lignes</span></b></dt>
               <dd>
                  <p>Estimation du nombre de lignes à renvoyer. Dans cet exemple, l’analyse devrait renvoyer 8 798 lignes. L' HashAggregate opérateur lui-même est censé renvoyer 576 lignes (une fois que les noms d'événements dupliqués ont été supprimés du jeu de résultats).</p>
                  <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>L’estimation de lignes repose sur les statistiques disponibles générées par la commande ANALYZE. Si ANALYZE n’a pas été exécutée récemment, l’estimation sera moins fiable.</p></div></div>
               </dd>
            
               <dt><b><span class="term">Largeur</span></b></dt>
               <dd>
                  <p>Largeur estimée de la ligne moyenne, en octets. Dans cet exemple, la ligne moyenne devrait avoir une largeur de 17 octets.</p>
               </dd>
            </dl></div><h2 id="EXPLAIN-operators">Opérateurs EXPLAIN</h2>
            
            <p>Cette section décrit brièvement les opérateurs que vous voyez le plus souvent dans la sortie EXPLAIN. Pour obtenir une liste complète des opérateurs, consultez <a href="./r_EXPLAIN.html">EXPLAIN</a> dans la section Commandes SQL.</p>
            <h3 id="scan-operator">Opérateur d’analyse séquentielle</h3>
               
               <p>L’opérateur d’analyse séquentiel (Seq Scan) indique une analyse de table. Seq Scan analyse chaque colonne de la tableau de manière séquentielle du début à la fin et évalue les contraintes de requête (dans la clause WHERE) de chaque ligne.</p>
             
            <h3 id="join-operators">Opérateurs de jointure</h3>
               
               <p>Amazon Redshift sélectionne les opérateurs de jointure en fonction de la conception physique des tables jointes, de l’emplacement des données requises pour la jointure et des exigences spécifiques à la requête elle-même.</p>
               <div class="itemizedlist">
                   
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">Boucle imbriquée</span></p>
                     <p>La jointure la moins optimale, une boucle imbriquée, est utilisée principalement pour les jointures croisées (produits cartésiens) et certaines jointures d’inégalité.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Hash Join and Hash</span></p>
                     <p>Généralement plus rapide qu’une boucle imbriquée, une jointure par hachage et un hachage sont utilisés pour les jointures internes et les jointures externes gauche et droite. Ces opérateurs sont utilisés lors de la jonction de tables, lorsque les colonnes de jointure ne sont pas des clés de distribution <em>et</em> des clés de tri. L’opérateur de hachage crée la table de hachage pour la table interne de la jointure ; l’opérateur de jointure par hachage lit la table externe, hache la colonne de jointure et recherche des correspondances dans la table de hachage interne.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Joindre par fusion</span></p>
                     <p>Généralement la jointure la plus rapide, une jointure par fusion est utilisée pour les jointures internes et externes. La jointure par fusion n’est pas utilisée pour les jointures complètes. Cet opérateur est utilisé lors de la jonction de tables lorsque les colonnes de jointure sont des clés de distribution <em>et</em> des clés de tri, et lorsque moins de 20 % des tables jointes sont non triées. Il lit les deux tables triées dans l’ordre et recherche les lignes correspondantes. Pour afficher le pourcentage de lignes non triées, interrogez la table système <a href="./r_SVV_TABLE_INFO.html">SVV_TABLE_INFO</a>.</p>
                  </li><li class="listitem"> 
                     <p><span class="topcom">Jointure spatiale</span></p>
                     <p>Il s’agit généralement d’une jointure rapide basée sur la proximité des données spatiales, utilisées pour les types de données <code class="code">GEOMETRY</code> et <code class="code">GEOGRAPHY</code>.</p>
                  </li></ul></div>
             
            <h3 id="aggregate-operators">Opérateurs d’agrégation</h3>
               
               <p>Le plan de requête utilise les opérateurs suivants dans les requêtes impliquant des fonctions d’agrégation et des opérations GROUP BY.</p>
               <div class="itemizedlist">
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">Regrouper</span></p>
                     <p>Opérateur de fonctions d’agrégation scalaires telles que AVG et SUM.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">HashAggregate</span></p>
                     <p>Opérateur des fonctions d’agrégation groupées non triées.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">GroupAggregate</span></p>
                     <p>Opérateur des fonctions d’agrégation groupées triées.</p>
                  </li></ul></div>
             
            <h3 id="sort-operators">Opérateurs de tri</h3>
               
               <p>Le plan de requête utilise les opérateurs suivants lorsque les requêtes doivent trier ou fusionner des jeux de résultats.</p>
               <div class="itemizedlist">
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">Tri</span></p>
                     <p>Evalue la clause ORDER BY et d’autres opérations de tri, telles que les tris requis par les requêtes UNION et les requêtes SELECT DISTINCT de jointure et les fonctions de fenêtrage.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Fusionner</span></p>
                     <p>Produit des résultats triés finaux selon les résultats triés intermédiaires qui proviennent d’opérations parallèles.</p>
                  </li></ul></div>
             
            <h3 id="UNION-INTERSECT-and-EXCEPT-operators">Opérateurs UNION, INTERSECT et EXCEPT</h3>
               
               <p>Le plan de requête utilise les opérateurs suivants pour des requêtes impliquant des opérations de jeu avec UNION, INTERSECT et EXCEPT.</p>
               <div class="itemizedlist">
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">Subquery</span></p>
                     <p>Utilisé pour exécuter des requêtes UNION.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Hash Intersect Distinct </span></p>
                     <p>Utilisé pour exécuter les requêtes INTERSECT .</p>
                  </li><li class="listitem">
                     <p><span class="topcom">SetOp Sauf</span></p>
                     <p>Utilisé pour exécuter des requêtes EXCEPT (ou MINUS).</p>
                  </li></ul></div>
             
            <h3 id="other-operators">Autres opérateurs</h3>
               
               <p>Les opérateurs suivants apparaissent également fréquemment dans la sortie EXPLAIN pour les requêtes courantes.</p>
               <div class="itemizedlist">
                   
                   
                   
                   
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">Unique</span></p>
                     <p>Supprime les doublons des requêtes SELECT DISTINCT et UNION.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Limite</span></p>
                     <p>Traite la clause LIMIT.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Fenêtre</span></p>
                     <p>Exécute les fonctions de fenêtrage.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Result</span></p>
                     <p>Exécute les fonctions scalaires qui n’impliquent pas un accès aux tables.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Subplan</span></p>
                     <p>Utilisé pour certaines sous-requêtes.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Réseau</span></p>
                     <p>Envoie des résultats intermédiaires au nœud principal en vue d’un traitement ultérieur.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">Materialize</span></p>
                     <p>Enregistre les lignes pour l’entrée des jointures de boucles imbriquées et quelques autres jointures de fusion.</p>
                  </li></ul></div>
             
         <h2 id="joins-in-EXPLAIN">Jointures dans EXPLAIN</h2>
            
            <p>L’optimiseur de requête utilise différents types de jointures pour récupérer les données de la table, en fonction de la structure de la requête et des tables sous-jacentes. La sortie EXPLAIN fait référence au type de jointure, aux tables utilisées et à la manière dont les données de la table sont distribuées dans le cluster afin de décrire le traitement de la requête.</p>

            <h3 id="join-types">Exemples de types de jointures</h3>
               
               <p>Les exemples suivants illustrent les différents types de jointures que l’optimiseur de requête peut utiliser. Le type de jointure utilisé dans le plan de requête dépend de la conception physique des tables impliquées.</p>
               <h4 id="hash-join-two-tables">Exemple : Joindre par hachage deux tables</h4>
                  
                  <p>La requête suivante joint EVENT et CATEGORY sur la colonne CATID. CATID est la clé de tri et de distribution pour CATEGORY, mais pas pour EVENT. Une jointure par hachage est effectuée avec EVENT en tant que table externe et avec CATEGORY en tant que table interne. Etant donné que CATEGORY est la table la plus petite, le planificateur en diffuse une copie aux nœuds de calcul au cours du traitement de la requête à l’aide de DS_BCAST_INNER. Le coût de la jointure de cet exemple représente la majeure partie du coût cumulé du plan.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select * from category, event where category.catid=event.catid;

                               QUERY PLAN
-------------------------------------------------------------------------
 XN Hash Join DS_BCAST_INNER  (cost=0.14..6600286.07 rows=8798 width=84)
   Hash Cond: ("outer".catid = "inner".catid)
   -&gt;  XN Seq Scan on event  (cost=0.00..87.98 rows=8798 width=35)
   -&gt;  XN Hash  (cost=0.11..0.11 rows=11 width=49)
         -&gt;  XN Seq Scan on category  (cost=0.00..0.11 rows=11 width=49)</code></pre>
                  <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>Les retraits alignés pour les opérateurs dans la sortie EXPLAIN indiquent parfois que ces opérations ne dépendent pas l’une de l’autre et peuvent démarrer en parallèle. Dans l’exemple précédent, bien que l’analyse de la table EVENT et l’opération de hachage soient alignées, l’analyse EVENT doit attendre que l’opération de hachage soit entièrement terminée.</p></div></div>
                
               <h4 id="merge-join-two-tables">Exemple : Joindre par fusion deux tables</h4>
                  
                  <p>La requête suivante utilise également SELECT *, mais elle joint SALES et LISTING sur la colonne LISTID, dans laquelle LISTID a été défini comme clé de tri et de distribution des deux tables. Une jointure par fusion est choisie et aucun redistribution des données n’est requise pour la jointure (DS_DIST_NONE).</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select * from sales, listing where sales.listid = listing.listid;
QUERY PLAN
-----------------------------------------------------------------------------
XN Merge Join DS_DIST_NONE  (cost=0.00..6285.93 rows=172456 width=97)
  Merge Cond: ("outer".listid = "inner".listid)
  -&gt;  XN Seq Scan on listing  (cost=0.00..1924.97 rows=192497 width=44)
  -&gt;  XN Seq Scan on sales  (cost=0.00..1724.56 rows=172456 width=53)</code></pre>
                  <p>L’exemple suivant illustre les différents types de jointures au sein de la même requête. Comme dans l’exemple précédent, SALES et LISTING sont jointes par fusion, mais la troisième table, EVENT, doit être jointe par hachage aux résultats de la jointure par fusion. Une fois encore, la jointure par hachage implique un coût de diffusion.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select * from sales, listing, event
where sales.listid = listing.listid and sales.eventid = event.eventid;
                                  QUERY PLAN
----------------------------------------------------------------------------
XN Hash Join DS_BCAST_INNER  (cost=109.98..3871130276.17 rows=172456 width=132)
  Hash Cond: ("outer".eventid = "inner".eventid)
  -&gt;  XN Merge Join DS_DIST_NONE  (cost=0.00..6285.93 rows=172456 width=97)
        Merge Cond: ("outer".listid = "inner".listid)
        -&gt;  XN Seq Scan on listing  (cost=0.00..1924.97 rows=192497 width=44)
        -&gt;  XN Seq Scan on sales  (cost=0.00..1724.56 rows=172456 width=53)
  -&gt;  XN Hash  (cost=87.98..87.98 rows=8798 width=35)
        -&gt;  XN Seq Scan on event  (cost=0.00..87.98 rows=8798 width=35)</code></pre>
                
               <h4 id="join-aggregate-and-sort-example">Exemple : Joindre, regrouper et trier</h4>
                  
                  <p>La requête suivante exécute une jointure par hachage des tables SALES et EVENT, suivie d’opérations d’agrégation et de tri afin de tenir compte de la fonction SUM groupée et de la clause ORDER BY. L’opérateur Sort initial s’exécute en parallèle sur les nœuds de calcul. Puis, l’opérateur Network envoie les résultats au nœud principal, dans lequel l’opérateur Merge produit les résultats triés finaux.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">explain select eventname, sum(pricepaid) from sales, event 
where sales.eventid=event.eventid group by eventname
order by 2 desc;
                                           QUERY PLAN
---------------------------------------------------------------------------------
 XN Merge  (cost=1002815366604.92..1002815366606.36 rows=576 width=27)
  Merge Key: sum(sales.pricepaid)
  -&gt;  XN Network  (cost=1002815366604.92..1002815366606.36 rows=576 width=27)
        Send to leader
        -&gt;  XN Sort  (cost=1002815366604.92..1002815366606.36 rows=576 width=27)
              Sort Key: sum(sales.pricepaid)
              -&gt;  XN HashAggregate  (cost=2815366577.07..2815366578.51 rows=576 width=27)
                    -&gt;  XN Hash Join DS_BCAST_INNER  (cost=109.98..2815365714.80 rows=172456 width=27)
                          Hash Cond: ("outer".eventid = "inner".eventid)
                          -&gt;  XN Seq Scan on sales  (cost=0.00..1724.56 rows=172456 width=14)
                          -&gt;  XN Hash  (cost=87.98..87.98 rows=8798 width=21)
                                -&gt;  XN Seq Scan on event  (cost=0.00..87.98 rows=8798 width=21)</code></pre>
                
             
            <h3 id="data-redistribution">Redistribution des données</h3>
               
               <p>La sortie EXPLAIN des jointures spécifie également une méthode permettant de déplacer les données autour d’un cluster pour faciliter la jointure. Ce mouvement des données peut être une diffusion ou une redistribution. Dans une diffusion, les valeurs de données d’un côté d’une jointure sont copiées à partir de chaque nœud de calcul dans tous les autres nœuds de calcul, afin que chaque nœud de calcul se retrouve avec une copie complète des données. Dans une redistribution, les valeurs de données participantes sont envoyés de leur tranche actuelle vers une nouvelle tranche (éventuellement sur un autre nœud). Les données sont généralement redistribuées pour correspondre à la clé de distribution de l’autre table participant à la jointure si cette clé de distribution est l’une des colonnes de jointure. Si aucune des tables ne dispose de clés de distribution sur l’une des tables de jointure, les deux tables sont distribuées ou la table interne est diffusée à chaque nœud.</p>
               <p>La sortie EXPLAIN fait également référence aux tables internes et externes. La table interne est analysée d’abord et s’affiche près de bas du plan de requête. La table interne est la table qui fait l’objet d’une recherche de correspondances. Elle est généralement conservée en mémoire, est généralement la table source pour le hachage et, si possible, est la plus petite des deux tables qui sont jointes. La table externe est la source des lignes à mettre en correspondant avec la table interne. Elle est généralement lue à partir du disque. L’optimiseur de requête choisit la table interne et la table externe en fonction des statistiques de la base de données obtenues lors de la dernière exécution de la commande ANALYZE. L’ordre des tables dans la clause FROM d’une requête ne détermine pas quelle table est interne et quelle table est externe.</p>
               <p>Utilisez les attributs suivants dans les plans de requête pour identifier la manière dont les données sont déplacées afin de simplifier une requête :</p>
               <div class="itemizedlist">
                   
                   
                   
                   
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem">
                     <p><span class="topcom">DS_BCAST_INNER</span></p>
                     <p>Une copie de la totalité de la table interne est diffusée à tous les nœuds de calcul.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_ALL_NONE</span></p>
                     <p>Aucun redistribution n’est obligatoire, car la table interne a déjà été distribuée à chaque nœud à l’aide de DISTSTYLE ALL.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_NONE</span></p>
                     <p>Aucune table n’est redistribuée. Les jointures colocalisées sont possibles, car les tranches correspondantes sont jointes sans transfert de données entre les nœuds.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_INNER</span></p>
                     <p>La table interne est redistribuée.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_OUTER</span></p>
                     <p>La table externe est redistribuée.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_ALL_INNER</span></p>
                     <p>La totalité de la table interne est redistribué à une seule tranche, car la table externe utilise DISTSTYLE ALL.</p>
                  </li><li class="listitem">
                     <p><span class="topcom">DS_DIST_BOTH</span></p>
                     <p>Les deux tables sont redistribuées.</p>
                  </li></ul></div>
             
         <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Avertissement" /> <strong>JavaScript est désactivé ou n'est pas disponible dans votre navigateur.</strong></p><p>Pour que vous puissiez utiliser la documentation AWS, Javascript doit être activé. Vous trouverez des instructions sur les pages d'aide de votre navigateur.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Conventions de rédaction</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./c-query-planning.html">Workflow d’exécution et de planification de requête</div><div id="next" class="next-link" accesskey="n" href="./reviewing-query-plan-steps.html">Révision des étapes du plan de requête</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">Cette page vous a-t-elle été utile ? - Oui</div><div class="content"><p>Merci de nous avoir fait part de votre satisfaction.</p><p>Si vous avez quelques minutes à nous consacrer, merci de nous indiquer ce qui vous a plu afin que nous puissions nous améliorer davantage.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Commentaire" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-the-query-plan.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">Cette page vous a-t-elle été utile ? - Non</div><div class="content"><p>Merci de nous avoir avertis que cette page avait besoin d'être retravaillée. Nous sommes désolés de ne pas avoir répondu à vos attentes.</p><p>Si vous avez quelques minutes à nous consacrer, merci de nous indiquer comment nous pourrions améliorer cette documentation.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Commentaire" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c-the-query-plan.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>