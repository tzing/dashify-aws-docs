<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="fr-FR"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Interrogation de données semi-structurées - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="query-super" /><meta name="default_state" content="query-super" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/query-super.html" /><meta name="description" content="Dans Amazon Redshift, vous pouvez utiliser le langage PartiQL pour un accès compatible SQL aux données semi-structurées." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="Guide du développeur de base de données" /><meta name="abstract" content="Créez et gérez un entrepôt de données avec Amazon Redshift, service d’entrepôt de données au niveau de l’entreprise, pouvant atteindre plusieurs Po et entièrement géré." /><meta name="guide-locale" content="fr_fr" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/query-super.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/query-super.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/query-super.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/query-super.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/query-super.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/query-super.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/query-super.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/query-super.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/query-super.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/query-super.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/query-super.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/query-super.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/query-super.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/query-super.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/query-super.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/query-super.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/query-super.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/query-super.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/query-super.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/query-super.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/query-super.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/query-super.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="Guide du développeur de base de données" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="Guide du développeur de base de données" /><meta id="panorama-serviceConsolePage" value="Interrogation de données semi-structurées" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Interrogation de données semi-structurées - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#query-super" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/query-super.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/query-super.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/query-super.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,cluster,entrepôt de données,développeur,exemples de données,database,développeur de base de données,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Guide du développeur de base de données",
        "item" : "https://docs.aws.amazon.com/fr_fr/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Ingestion et interrogation de données semi-structurées dans Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/super-overview.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Interrogation de données semi-structurées",
        "item" : "https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/super-overview.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#query-super" target="_blank" rel="noopener noreferrer" title="Ouvrir le PDF"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Documentation</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">Guide du développeur de base de données</a></div><div id="page-toc-src"><a href="#navigation">Navigation</a><a href="#unnest">Désimbriquer des requêtes</a><a href="#unpivoting">Dépivotement d’objet</a><a href="#dynamic-typing-lax-processing">Typage dynamique</a><a href="#lax-semantics">Sémantique laxiste</a><a href="#introspection">Types d’introspection</a><a href="#order-by">Classer par</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><awsui-alert class="awsdocs-page-banner awsui-util-mb-l"><p>Les traductions sont fournies par des outils de traduction automatique. En cas de conflit entre le contenu d'une traduction et celui de la version originale en anglais, la version anglaise prévaudra.</p></awsui-alert><h1 class="topictitle" id="query-super">Interrogation de données semi-structurées</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p>Amazon Redshift utilise le langage PartiQL pour offrir un accès compatible SQL aux données relationnelles, semi-structurées et imbriquées. </p><p>PartiQL fonctionne avec des types dynamiques. Cette approche permet un filtrage, une jonction et une agrégation intuitifs sur la combinaison de jeux de données structurés, semi-structurés et imbriqués. La syntaxe PartiQL utilise la notation par points et l’index de tableau pour la navigation dans les chemins lors de l’accès aux données imbriquées. Il permet également aux éléments de la clause FROM d’itérer sur des tableaux et de les utiliser pour des opérations de désimbrication. Ci-dessous, vous pouvez trouver des descriptions des différents modèles de requête qui combinent l’utilisation du type de données SUPER avec la navigation par chemin et par tableau, la désimbrication, le dépivotement ou les jointures. </p><p> Pour en savoir plus sur les tables utilisées dans l’exemple suivant, consultez <a href="./r_SUPER_sample_dataset.html">Jeu de données échantillon SUPER</a>. </p>
         <h2 id="navigation">Navigation</h2>
         <p>Amazon Redshift utilise PartiQL pour permettre la navigation dans les tableaux et les structures en utilisant respectivement la notation entre crochets [...] et la notation par points. En outre, vous pouvez mélanger la navigation dans des structures en utilisant notation par points avec la navigation dans des tableaux en utilisant la notation entre crochets. Par exemple, l’exemple suivant suppose que la colonne de données <code class="code">c_orders</code> SUPER est un tableau structuré et qu’un attribut est nommé <code class="code">o_orderkey</code>.</p>
         <p>Pour intégrer des données dans la table <code class="code">customer_orders_lineitem</code>, exécutez la commande suivante. Remplacez le rôle IAM par vos propres informations d’identification.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">COPY customer_orders_lineitem FROM 's3://redshift-downloads/semistructured/tpch-nested/data/json/customer_orders_lineitem'
REGION 'us-east-1' IAM_ROLE 'arn:aws:iam::xxxxxxxxxxxx:role/Redshift-S3'
FORMAT JSON 'auto';

SELECT c_orders[0].o_orderkey FROM customer_orders_lineitem;</code></pre>

         <p>Amazon Redshift utilise également un alias de table comme préfixe de la notation. L’exemple suivant est la même requête que celle de l’exemple précédent.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT cust.c_orders[0].o_orderkey FROM customer_orders_lineitem AS cust;</code></pre>
         
      <p>Vous pouvez utiliser la notation par points et crochets dans tous les types de requêtes, comme le filtrage, la jointure et l’agrégation. Vous pouvez utiliser ces notations dans une requête dans laquelle il y a normalement des références de colonne. L’exemple suivant utilise une instruction SELECT qui filtre les résultats.</p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT count(*) FROM customer_orders_lineitem WHERE c_orders[0]. o_orderkey IS NOT NULL;</code></pre>
         
         <p>L’exemple suivant utilise la notation par points et crochets dans les clauses GROUP BY et ORDER BY :</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c_orders[0].o_orderdate,
       c_orders[0].o_orderstatus,
       count(*)
FROM customer_orders_lineitem
WHERE c_orders[0].o_orderkey IS NOT NULL
GROUP BY c_orders[0].o_orderstatus,
         c_orders[0].o_orderdate
ORDER BY c_orders[0].o_orderdate;</code></pre>
    
         <h2 id="unnest">Désimbriquer des requêtes</h2>
         <p>Pour désimbriquer des requêtes, Amazon Redshift utilise la syntaxe PartiQL pour effectuer une itération sur des baies SUPER. Pour ce faire, il navigue dans le tableau à l’aide de la clause FROM d’une requête. En utilisant l’exemple précédent, le suivant itère sur les valeurs de l’attribut pour <code class="code">c_orders</code>.</p>
         
       <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.*, o FROM customer_orders_lineitem c, c.c_orders o;</code></pre>
         <p>La syntaxe de désimbrication est une extension de la clause FROM. Dans SQL standard, la clause FROM <code class="code">x (AS) y</code> signifie que <code class="code">y</code> itère sur chaque tuple dans la relation <code class="code">x</code>. Dans ce cas, <code class="code">x</code> fait référence à une relation et <code class="code">y</code> fait référence à un alias pour la relation <code class="code">x</code>. De même, la syntaxe PartiQL de désimbrication à l’aide de l’élément de clause FROM <code class="code">x (AS) y</code> signifie que<code class="code">y</code> effectue une itération sur chaque valeur (SUPER) de l’expression x du tableau (SUPER). Dans ce cas, <code class="code">x</code> est une expression SUPER et <code class="code">y</code> est un alias pour <code class="code">x</code>.</p>

         <p>L’opérande de gauche peut également utiliser la notation par points et crochets pour la navigation régulière. Dans l’exemple précédent, <code class="code">customer_orders_lineitem c</code> est l’itération sur la table de base <code class="code">customer_order_lineitem</code> et <code class="code">c.c_orders o</code> est l’itération sur le tableau <code class="code">c.c_orders</code>. Pour itérer sur l’attribut <code class="code">o_lineitems</code>, qui est un tableau dans un tableau, vous ajoutez plusieurs clauses.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.*, o, l FROM customer_orders_lineitem c, c.c_orders o, o.o_lineitems l;</code></pre>
         <p>Amazon Redshift prend également en charge un index de tableau lors de l’itération sur le tableau à l’aide du mot clé AT. La clause <code class="code">x AS y AT z</code> itère sur le tableau <code class="code">x</code> et génère le champ <code class="code">z,</code> qui est l’index du tableau. L’exemple suivant illustre le fonctionnement d’un index de tableau.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c_name,
       orders.o_orderkey AS orderkey,
       index AS orderkey_index
FROM customer_orders_lineitem c, c.c_orders AS orders AT index 
ORDER BY orderkey_index;

c_name             | orderkey | orderkey_index
-------------------+----------+----------------
Customer#000008251 | 3020007  |        0
Customer#000009452 | 4043971  |        0
  (2 rows)</code></pre>
         <p>L’exemple suivant itère sur un tableau scalaire</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">CREATE TABLE bar AS SELECT json_parse('<span>{</span>"scalar_array": [1, 2.3, 45000000]}') AS data;

SELECT index, element FROM bar AS b, b.data.scalar_array AS element AT index;

 index | element
-------+----------
     0 | 1
     1 | 2.3
     2 | 45000000
(3 rows)</code></pre>
         
         <p>L’exemple suivant itère sur un tableau de plusieurs niveaux. L’exemple utilise plusieurs clauses de désimbrication (unnest) pour effectuer une itération dans les tableaux les plus intérieurs. Le tableau AS <code class="code">f.multi_level_array</code> itère sur <code class="code">multi_level_array</code>. L’élément AS du tableau est l’itération sur les tableaux dans <code class="code">multi_level_array</code>.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">CREATE TABLE foo AS SELECT json_parse('[[1.1, 1.2], [2.1, 2.2], [3.1, 3.2]]') AS multi_level_array;

SELECT array, element FROM foo AS f, f.multi_level_array AS array, array AS element;

   array   | element
-----------+---------
 [1.1,1.2] | 1.1
 [1.1,1.2] | 1.2
 [2.1,2.2] | 2.1
 [2.1,2.2] | 2.2
 [3.1,3.2] | 3.1
 [3.1,3.2] | 3.2
(6 rows)</code></pre>
         <p>Pour plus d’informations sur la clause FROM, consultez <a href="./r_FROM_clause30.html">Clause FROM</a>.</p>
       
         <h2 id="unpivoting">Dépivotement d’objet</h2>
         <p>Pour effectuer le dépivotement des objets, Amazon Redshift utilise la syntaxe PartiQL pour effectuer une itération sur des objets SUPER. Pour ce faire, il utilise la clause FROM d’une requête avec le mot clé UNPIVOT. La requête suivante effectue une itération sur l’objet <code class="code">c.c_orders[0]</code>.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT attr as attribute_name, json_typeof(val) as value_type 
FROM customer_orders_lineitem c, UNPIVOT c.c_orders[0] AS val AT attr 
WHERE c_custkey = 9451;

 attribute_name  | value_type
-----------------+------------
 o_orderstatus   | string
 o_clerk         | string
 o_lineitems     | array
 o_orderdate     | string
 o_shippriority  | number
 o_totalprice    | number
 o_orderkey      | number
 o_comment       | string
 o_orderpriority | string
(9 rows)</code></pre>
         <p>Comme pour la désimbrication, la syntaxe de dépivotement est une extension de la clause FROM. La différence réside dans le fait que la syntaxe de dépivotement utilise le mot clé UNPIVOT pour indiquer qu’il effectue une itération sur un objet au lieu d’un tableau. Il utilise la <code class="code">value_alias</code> AS pour l’itération sur toutes les valeurs à l’intérieur d’un objet et utilise l’<code class="code">attribute_alias</code> AT pour effectuer une itération sur tous les attributs.</p>
           <p>Amazon Redshift prend également en charge l’utilisation du dépivotement d’objet et de la désimbrication de tableau dans une seule clause FROM, comme suit.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT attr as attribute_name, val as object_value
FROM customer_orders_lineitem c, c.c_orders AS o, UNPIVOT o AS val AT attr 
WHERE c_custkey = 9451;</code></pre>
         <p>Lorsque vous utilisez le dépivotement d’objet, Amazon Redshift ne prend pas en charge le dépivotement corrélé. Concrètement, supposons que vous ayez un cas où il existe plusieurs exemples de dépivotement dans différents niveaux de requête et que le dépivotement interne fait référence à l’externe. Amazon Redshift ne prend pas en charge ce type de dépivotement multiple.</p>
         <p>Pour plus d’informations sur la clause FROM, consultez <a href="./r_FROM_clause30.html">Clause FROM</a>. Pour bénéficier d’exemples montrant comment interroger des données structurées avec PIVOT et UNPIVOT, consultez <a href="./r_FROM_clause-pivot-unpivot-examples.html">Exemples PIVOT et UNPIVOT</a>.</p>
       
      <h2 id="dynamic-typing-lax-processing">Typage dynamique</h2>
      <p>Le typage dynamique ne nécessite pas de moulage explicite des données qui sont extraites des chemins en notation points et crochets. Amazon Redshift utilise le typage dynamique pour traiter des données SUPER sans schéma sans avoir à déclarer les types de données avant de les utiliser dans votre requête. Le typage dynamique utilise les résultats de la navigation dans les colonnes de données SUPER sans devoir les convertir explicitement en types Amazon Redshift. Le typage dynamique est le plus utile dans les jointures et les clauses GROUP BY. L’exemple suivant utilise une instruction SELECT qui ne nécessite aucune conversion explicite des expressions points et crochets aux types habituels d’Amazon Redshift. Pour plus d’informations sur la compatibilité et la conversion des types, consultez <a href="./c_Supported_data_types.html#r_Type_conversion">Compatibilité et conversion de types</a>.</p>
      
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c_orders[0].o_orderkey
FROM customer_orders_lineitem
WHERE c_orders[0].o_orderstatus = 'P';</code></pre>
      <p>Le signe d’égalité dans cette requête est évalué à <code class="code">true</code> lorsque c_orders[0].o_orderstatus est la chaîne « P ». Dans tous les autres cas, le signe d’égalité est évalué à <code class="code">false</code>, y compris lorsque les arguments de l’égalité sont de types différents.</p>

      
      
       
         <h3 id="dynamic-typing-lax-processing-dynamic-and-static">Typage dynamique et statique</h3>

      <p>Sans utiliser le typage dynamique, vous ne pouvez pas déterminer si c_orders[0].o_orderstatus est une chaîne, un entier ou une structure. Vous pouvez seulement déterminer que c_orders[0].o_orderstatus est un type de données SUPER, qui peut être un scalaire Amazon Redshift, un tableau ou une structure. Le type statique de c_orders[0].o_orderstatus est un type de données SUPER. Conventionnellement, un type est implicitement statique dans SQL.</p>
         
         <p>Amazon Redshift utilise le typage dynamique pour le traitement des données sans schéma. Lorsque la requête évalue les données, c_orders[0].o_orderstatus s’avère être un type spécifique. Par exemple, l’évaluation de c_orders[0].o_orderstatus sur le premier enregistrement de customer_orders_lineitem peut aboutir à un entier. L’évaluation sur le deuxième enregistrement peut résulter en une chaîne de caractères. Ce sont les types dynamiques de l’expression.</p>
         
        <p>Lors de l’utilisation d’un opérateur ou d’une fonction SQL avec des expressions de type point et crochets ayant des types dynamiques, Amazon Redshift produit des résultats similaires à l’utilisation d’un opérateur ou d’une fonction SQL standard avec les types statiques respectifs. Dans cet exemple, lorsque le type dynamique de l’expression de chemin est une chaîne, la comparaison avec la chaîne « P » est significative. Si le type dynamique de c_orders[0].o_orderstatus est d’un autre type de données que celui de chaîne de caractères, l’égalité renvoie faux. Les autres fonctions renvoient null lorsque des arguments mal typés sont utilisés.</p>
      <p>L’exemple suivant écrit la requête précédente avec un typage statique :</p>
      
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c_custkey
FROM customer_orders_lineitem
WHERE CASE WHEN JSON_TYPEOF(c_orders[0].o_orderstatus) = 'string'
           THEN c_orders[0].o_orderstatus::VARCHAR = 'P'
           ELSE FALSE END;</code></pre>
      <p>Notez la distinction suivante entre les prédicats d’égalité et les prédicats de comparaison. Dans l'exemple précédent, si vous remplacez le prédicat d'égalité par un  less-than-or-equal prédicat, la sémantique produit une valeur nulle au lieu de fausse.</p>
      
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c_orders[0]. o_orderkey
FROM customer_orders_lineitem
WHERE c_orders[0].o_orderstatus &lt;= 'P';</code></pre>
      <p>Dans cet exemple, si c_orders[0].o_orderstatus est une chaîne, Amazon Redshift renvoie true si elle est alphabétiquement égale ou inférieure à « P ». Amazon Redshift renvoie false si elle est alphabétiquement supérieure à « P ». Toutefois, si c_orders[0].o_orderstatus n’est pas une chaîne, Amazon Redshift renvoie null car Amazon Redshift ne peut pas comparer des valeurs de différents types, comme indiqué dans la requête suivante :</p>
      
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c_custkey
FROM customer_orders_lineitem
WHERE CASE WHEN JSON_TYPEOF(c_orders[0].o_orderstatus) = 'string'
           THEN c_orders[0].o_orderstatus::VARCHAR &lt;= 'P'
           ELSE NULL END;</code></pre>
      <p>Le typage dynamique n’exclut pas des comparaisons des types qui sont minimalement comparables. Par exemple, vous pouvez convertir les types scalaires CHAR et VARCHAR Amazon Redshift en SUPER. Ils sont comparables à des chaînes de caractères, y compris en ignorant les caractères d’espacement de fin de chaîne, comme pour les types CHAR et VARCHAR d’Amazon Redshift. De même, les valeurs entières, décimales et à virgule flottante sont comparables en tant que valeurs SUPER. Spécifiquement pour les colonnes décimales, chaque valeur peut également avoir une graduation différente. Amazon Redshift les considère quand même comme des types dynamiques.</p>
      <p>Amazon Redshift prend également en charge l’égalité sur les objets et les tableaux évalués comme étant profondément égaux, comme l’évaluation profonde des objets ou des tableaux et la comparaison de tous les attributs. Utilisez l’égalité profonde avec prudence, car le processus d’exécution de l’égalité profonde peut prendre du temps.</p>
       
      
       
         <h3 id="dynamic-typing-lax-processing-joins">Utilisation du typage dynamique pour les jointures</h3>
      <p>Pour les jointures, le typage dynamique fait automatiquement correspondre des valeurs avec différents types dynamiques sans avoir à effectuer une longue analyse CASE WHEN pour savoir quels types de données peuvent apparaître. Supposons par exemple que votre organisation ait changé le format qu’elle utilisait pour les clés partielles (part keys) au fil du temps.</p>
         <p>Les clés partielles de type entier initialement émises sont remplacées par des clés partielles de type chaîne de caractères, telles que ‘A55’, puis à nouveau par des clés partielles de type tableau, telles que [‘X’, 10] combinant une chaîne de caractères et un nombre. Amazon Redshift n’a pas besoin d’effectuer une longue analyse de cas sur les clés partielles et peut utiliser des jointures comme indiqué dans l’exemple suivant.</p>
      
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.c_name
    ,l.l_extendedprice
    ,l.l_discount
FROM customer_orders_lineitem c
    ,c.c_orders o
    ,o.o_lineitems l
    ,supplier_partsupp s
    ,s.s_partsupps ps
WHERE l.l_partkey = ps.ps_partkey
AND c.c_nationkey = s.s_nationkey
ORDER BY c.c_name;</code></pre>
      
      <p>L’exemple suivant montre à quel point la même requête peut être complexe et inefficace sans utiliser le typage dynamique :</p>
      
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.c_name
    ,l.l_extendedprice
    ,l.l_discount
FROM customer_orders_lineitem c
    ,c.c_orders o
    ,o.o_lineitems l
    ,supplier_partsupp s
    ,s.s_partsupps ps
WHERE CASE WHEN IS_INTEGER(l.l_partkey) AND IS_INTEGER(ps.ps_partkey)
           THEN l.l_partkey::integer = ps.ps_partkey::integer
           WHEN IS_VARCHAR(l.l_partkey) AND IS_VARCHAR(ps.ps_partkey)
           THEN l.l_partkey::varchar = ps.ps_partkey::varchar
           WHEN IS_ARRAY(l.l_partkey) AND IS_ARRAY(ps.ps_partkey)
                AND IS_VARCHAR(l.l_partkey[0]) AND IS_VARCHAR(ps.ps_partkey[0])
                AND IS_INTEGER(l.l_partkey[1]) AND IS_INTEGER(ps.ps_partkey[1])
           THEN l.l_partkey[0]::varchar = ps.ps_partkey[0]::varchar
                AND l.l_partkey[1]::integer = ps.ps_partkey[1]::integer
           ELSE FALSE END
AND c.c_nationkey = s.s_nationkey
ORDER BY c.c_name;</code></pre>
             
      
       
         <h2 id="lax-semantics">Sémantique laxiste</h2>
      <p>Par défaut, les opérations de navigation sur les valeurs SUPER renvoient null au lieu de renvoyer une erreur lorsque la navigation n’est pas valide. La navigation par objet est invalide si la valeur SUPER n’est pas un objet ou si la valeur SUPER est un objet mais ne contient pas le nom de l’attribut utilisé dans la requête. Par exemple, la requête suivante accède à un nom d’attribut non valide dans la colonne de données SUPER cdata :</p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.c_orders.something FROM customer_orders_lineitem c;</code></pre>
      <p>La navigation de tableau renvoie null si la valeur SUPER n’est pas un tableau ou si l’index du tableau est hors limites. La requête suivante renvoie null car c_orders[1][1] est hors limites. </p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.c_orders[1][1] FROM customer_orders_lineitem c;</code></pre>
      <p>La sémantique laxiste est particulièrement utile lorsqu’on utilise le typage dynamique pour convertir une valeur SUPER. Le transtypage d’une valeur SUPER en un type incorrect renvoie null au lieu d’une erreur si la conversion n’est pas valide. Par exemple, la requête suivante renvoie null car elle ne peut pas convertir la valeur de chaîne « Good » de l’attribut d’objet o_orderstatus en INTEGER. Amazon Redshift renvoie une erreur pour une conversion de VARCHAR en INTEGER mais pas pour une conversion en SUPER.</p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT c.c_orders.o_orderstatus::integer FROM customer_orders_lineitem c;</code></pre>
       
         <h2 id="introspection">Types d’introspection</h2>
      <p>Les colonnes de données SUPER prennent en charge les fonctions d’inspection qui renvoient le type dynamique et d’autres informations de type sur la valeur SUPER. L’exemple le plus courant est la fonction scalaire JSON_TYPEOF qui renvoie un VARCHAR avec les valeurs booléen (boolean), nombre (number), chaîne (string), objet (object), tableau (array) ou null, selon le type dynamique de la valeur SUPER. Amazon Redshift prend en charge les fonctions booléennes suivantes pour les colonnes de données SUPER :</p>
      <div class="itemizedlist">
          
          
          
          
          
          
          
          
                
            
          
          
          
      <ul class="itemizedlist"><li class="listitem"><p>DECIMAL_PRECISION</p></li><li class="listitem"><p>DECIMAL_SCALE</p></li><li class="listitem"><p>IS_ARRAY</p></li><li class="listitem"><p>IS_BIGINT</p></li><li class="listitem"><p>IS_CHAR</p></li><li class="listitem"><p>IS_DECIMAL</p></li><li class="listitem"><p>IS_FLOAT</p></li><li class="listitem"><p>IS_INTEGER</p></li><li class="listitem"><p>IS_OBJECT</p></li><li class="listitem"><p>IS_SCALAR</p></li><li class="listitem"><p>IS_SMALLINT</p></li><li class="listitem"><p>IS_VARCHAR</p></li><li class="listitem"><p>JSON_TYPEOF</p></li></ul></div>
      <p>Toutes ces fonctions renvoient false si la valeur d’entrée est nulle. IS_SCALAR, IS_OBJECT et IS_ARRAY s’excluent mutuellement et couvrent toutes les valeurs possibles à l’exception de null.</p>
       <p>Pour déduire les types correspondant aux données, Amazon Redshift utilise la fonction JSON_TYPEOF qui renvoie le type de (premier niveau de) la valeur SUPER comme indiqué dans l’exemple suivant :</p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT JSON_TYPEOF(r_nations) FROM region_nations;
 json_typeof
 -------------
 array
(1 row)</code></pre>
         
         
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT JSON_TYPEOF(r_nations[0].n_nationkey) FROM region_nations;
 json_typeof
 -------------
 number</code></pre>
      <p>Amazon Redshift voit cela comme une longue chaîne unique, ce qui revient à insérer cette valeur dans une colonne VARCHAR au lieu d’un SUPER. Puisque la colonne est SUPER, la chaîne unique est toujours une valeur SUPER valide et la différence est notée dans JSON_TYPEOF :</p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT IS_VARCHAR(r_nations[0].n_name) FROM region_nations;
 is_varchar
-------------
 true
(1 row)</code></pre>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">SELECT r_nations[4].n_name FROM region_nations
WHERE CASE WHEN IS_INTEGER(r_nations[4].n_nationkey) 
           THEN r_nations[4].n_nationkey::INTEGER = 15 
           ELSE false END;</code></pre>
    
         <h2 id="order-by">Classer par</h2>
         <p>Amazon Redshift ne définit pas de comparaisons SUPER entre des valeurs ayant des types dynamiques différents. Une valeur SUPER qui est une chaîne n’est ni plus petite ni plus grande qu’une valeur SUPER qui est un nombre. Pour utiliser les clauses ORDER BY avec les colonnes SUPER, Amazon Redshift définit un ordre total parmi les différents types à observer lorsque Amazon Redshift classe les valeurs SUPER à l’aide des clauses ORDER BY. L’ordre des types dynamiques est le suivant : booléen, nombre, chaîne, tableau, objet. L’exemple suivant montre les différents types d’ordres :</p>
         
      <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Texte"><awsui-icon name="copy"></awsui-icon></div></div><code class="">INSERT INTO region_nations VALUES 
(100,'name1','comment1','AWS'), 
(200,'name2','comment2',1),
(300,'name3','comment3',ARRAY(1, 'abc', null)),
(400,'name4','comment4',-2.5),
(500,'name5','comment5','Amazon');

SELECT r_nations FROM region_nations order by r_nations;

r_nations
----------------
 -2.5
 1
 "Amazon"
 "AWS"
 [1,"abc",null]
(5 rows)</code></pre>
         <p>Pour plus d’informations sur la clause ORDER BY, consultez <a href="./r_ORDER_BY_clause.html">Clause ORDER BY</a>.</p>
      <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Avertissement" /> <strong>JavaScript est désactivé ou n'est pas disponible dans votre navigateur.</strong></p><p>Pour que vous puissiez utiliser la documentation AWS, Javascript doit être activé. Vous trouverez des instructions sur les pages d'aide de votre navigateur.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Conventions de rédaction</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./unload-super-parquet.html">Déchargement de données semi-structurées au format Parquet</div><div id="next" class="next-link" accesskey="n" href="./operators-functions.html">Opérateurs et fonctions</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">Cette page vous a-t-elle été utile ? - Oui</div><div class="content"><p>Merci de nous avoir fait part de votre satisfaction.</p><p>Si vous avez quelques minutes à nous consacrer, merci de nous indiquer ce qui vous a plu afin que nous puissions nous améliorer davantage.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Commentaire" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/query-super.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">Cette page vous a-t-elle été utile ? - Non</div><div class="content"><p>Merci de nous avoir avertis que cette page avait besoin d'être retravaillée. Nous sommes désolés de ne pas avoir répondu à vos attentes.</p><p>Si vous avez quelques minutes à nous consacrer, merci de nous indiquer comment nous pourrions améliorer cette documentation.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Commentaire" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/query-super.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>