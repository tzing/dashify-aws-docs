<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="pt-BR"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Instruções da PL/pgSQL compatíveis - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="c_PLpgSQL-statements" /><meta name="default_state" content="c_PLpgSQL-statements" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="description" content="Trabalhe com as instruções PL/pgSQL aceitas pelo Amazon Redshift." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="Guia do desenvolvedor de banco de dados" /><meta name="abstract" content="Crie e gerencie um data warehouse com o Amazon Redshift, um serviço de data warehouse totalmente gerenciado, em escala de petabyte e de nível empresarial." /><meta name="guide-locale" content="pt_br" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/c_PLpgSQL-statements.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="Guia do desenvolvedor de banco de dados" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="Guia do desenvolvedor de banco de dados" /><meta id="panorama-serviceConsolePage" value="Instruções da PL/pgSQL compatíveis" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Instruções da PL/pgSQL compatíveis - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#c_PLpgSQL-statements" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,cluster,data warehouse,desenvolvedor,dados de amostra,banco de dados,desenvolvedor do banco de dados,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Guia do desenvolvedor de banco de dados",
        "item" : "https://docs.aws.amazon.com/pt_br/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Criar procedimentos armazenados no Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-overview.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Referência da linguagem PL/pgSQL",
        "item" : "https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_pl_pgSQL_reference.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "Instruções da PL/pgSQL compatíveis",
        "item" : "https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_pl_pgSQL_reference.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#c_PLpgSQL-statements" target="_blank" rel="noopener noreferrer" title="Abrir em PDF"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Documentação</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">Guia do desenvolvedor de banco de dados</a></div><div id="page-toc-src"><a href="#r_PLpgSQL-assignment">Atribuição</a><a href="#r_PLpgSQL-select-into">SELECT INTO</a><a href="#r_PLpgSQL-no-op">No-op</a><a href="#r_PLpgSQL-dynamic-sql">SQL dinâmico</a><a href="#r_PLpgSQL-return">Return</a><a href="#r_PLpgSQL-conditionals-if">Condicionais: IF </a><a href="#r_PLpgSQL-conditionals-case">Condicionais: CASE</a><a href="#r_PLpgSQL-loops">Loops</a><a href="#r_PLpgSQL-cursors">Cursores</a><a href="#r_PLpgSQL-messages-errors">RAISE</a><a href="#r_PLpgSQL-transaction-control">Controle da transação</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="c_PLpgSQL-statements">Instruções da PL/pgSQL compatíveis</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p> As instruções da PL/pgSQL aumentam comandos SQL com construções processuais, incluindo loops e expressões condicionais, a fim de controlar o fluxo lógico. A maioria dos comandos SQL pode ser usada, incluindo linguagem de manipulação de dados (DML), como COPY, UNLOAD e INSERT, e linguagem de definição de dados (DDL), como CREATE TABLE. Para obter a lista dos comandos SQL abrangentes, consulte <a href="./c_SQL_commands.html">Comandos SQL</a>. Além disso, as seguintes instruções PL/pgSQL são compatíveis com o Amazon Redshift. </p><div class="highlights" id="inline-topiclist"><h6>Tópicos</h6><ul><li><a href="#r_PLpgSQL-assignment">Atribuição</a></li><li><a href="#r_PLpgSQL-select-into">SELECT INTO</a></li><li><a href="#r_PLpgSQL-no-op">No-op</a></li><li><a href="#r_PLpgSQL-dynamic-sql">SQL dinâmico</a></li><li><a href="#r_PLpgSQL-return">Return</a></li><li><a href="#r_PLpgSQL-conditionals-if">Condicionais: IF</a></li><li><a href="#r_PLpgSQL-conditionals-case">Condicionais: CASE</a></li><li><a href="#r_PLpgSQL-loops">Loops</a></li><li><a href="#r_PLpgSQL-cursors">Cursores</a></li><li><a href="#r_PLpgSQL-messages-errors">RAISE</a></li><li><a href="#r_PLpgSQL-transaction-control">Controle da transação</a></li></ul></div>
            <h2 id="r_PLpgSQL-assignment">Atribuição</h2>  
            
            <p>A instrução de atribuição atribui um valor a uma variável. A expressão deve retornar um único valor.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">identifier := expression;</code></pre>
            
            <p>Usar o <code class="code">=</code> não padrão para a atribuição, em vez do <code class="code">:=</code>, também é aceito.</p>
            
           <p>Se o tipo de dados da expressão não corresponder ao tipo de dados da variável ou a variável tiver um tamanho ou uma precisão, o valor do resultado será convertido implicitamente.</p>
      <p>Veja a seguir alguns exemplos.</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">customer_number := 20;
tip := subtotal * 0.15;</code></pre>
            
          
            <h2 id="r_PLpgSQL-select-into">SELECT INTO</h2> 
            
           
            <p>A instrução SELECT INTO atribui o resultado de várias colunas (mas somente uma linha) a uma variável de registro ou uma lista de variáveis escalares.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">SELECT INTO <code class="replaceable">target</code> <code class="replaceable">select_expressions</code> FROM ...;</code></pre>  
            
            
            <p>Na sintaxe anterior, <code class="replaceable">target</code> pode ser uma variável de registro ou uma lista separada por vírgulas de variáveis simples e campos de registro. A lista <code class="replaceable">select_expressions</code> e o restante do comando são iguais ao SQL regular.</p>
            <p>Se uma lista de variáveis for usada como <code class="replaceable">target</code>, os valores selecionados deverão corresponder exatamente à estrutura do destino, caso contrário, ocorrerá um erro de tempo de execução. Quando uma variável de registro for o destino, ela se configura automaticamente para o tipo de linha das colunas do resultado da consulta.</p>
            <p>A cláusula INTO pode aparecer praticamente em qualquer lugar na instrução SELECT. Normalmente ela aparece logo após a cláusula SELECT ou imediatamente antes da cláusula FROM. Ou seja, ela aparece imediatamente antes ou logo após a lista <code class="replaceable">select_expressions</code>.</p>
            <p>Se a consulta não retornar nenhuma linha, valores NULL serão atribuídos a <code class="replaceable">target</code>. Se a consulta retornar várias linhas, a primeira linha será atribuída a <code class="replaceable">target</code> e o restante é descartado. A menos que a instrução contenha um ORDER BY, a primeira linha é não determinística.</p>
            <p>Para determinar se a atribuição retornou pelo menos uma fila, use a variável especial FOUND.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">SELECT INTO customer_rec * FROM cust WHERE custname = lname;
IF NOT FOUND THEN
  RAISE EXCEPTION 'employee % not found', lname;
END IF;
</code></pre>
            
            <p>Para testar se um resultado de registro é nulo, use o condicional IS NULL. Não é possível determinar se outras linhas adicionais foram descartadas. O exemplo a seguir lida com o caso em que nenhuma linha foi retornada.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE select_into_null(return_webpage OUT varchar(256))
AS $$
DECLARE
  customer_rec RECORD;
BEGIN
  SELECT INTO customer_rec * FROM users WHERE user_id=3;
  IF customer_rec.webpage IS NULL THEN
    -- user entered no webpage, return "http://"
    return_webpage = 'http://';
  END IF;
END;
$$ LANGUAGE plpgsql;         
</code></pre>
            
          
            <h2 id="r_PLpgSQL-no-op">No-op</h2>  
           
            <p>A instrução no-op (<code class="code">NULL;</code>) é uma instrução de espaço reservado que não faz nada. Uma instrução no-op pode indicar que uma ramificação de uma cadeia IF-THEN-ELSE está vazia.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="">NULL;</code></pre> 
 
 
            
          
            <h2 id="r_PLpgSQL-dynamic-sql">SQL dinâmico</h2>  
            
            <p>Para gerar comandos dinâmicos que podem involver diferentes tabelas ou diferentes tipos de dados toda vez que forem executados a partir de um procedimento armazenado em PL/pgSQL, use a instrução <code class="code">EXECUTE</code>.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">EXECUTE <code class="replaceable">command-string</code> [ INTO target ];</code></pre> 
            
            <p>Acima, <code class="replaceable">command-string</code> é uma expressão que gera uma string (do tipo texto) que contém o comando a ser executado. Esse valor de <code class="replaceable">command-string</code> é enviado ao mecanismo SQL. Nenhuma substituição das variáveis em PL/pgSQL é feita na string de comando. Os valores das variáveis deve ser inserido na string de comando à medida que é construída.</p>
           
           <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>nota</h6></div><div class="awsdocs-note-text"><p>Não é possível usar as instruções COMMIT e ROLLBACK em SQL dinâmico. Para obter informações sobre como usar as instruções COMMIT e ROLLBACK em um procedimento armazenado, consulte <a href="./stored-procedure-transaction-management.html">Gerenciamento de transações</a>. </p></div></div> 
            
            <p>Ao trabalhar com comandos dinâmicos, é usual precisar lidar com o escape de aspas simples. Recomendamos colocar texto fixo entre aspas no corpo da função usando cotação de dólar. Valores dinâmicos a serem inseridos em uma consulta construída exigem tratamento especial, pois eles mesmos podem conter aspas. O exemplo a seguir assume cotação de dólar para a função como um todo, para que as aspas não precisem ser duplicadas.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">EXECUTE 'UPDATE tbl SET '
  || quote_ident(colname)
  || ' = '
  || quote_literal(newvalue)
  || ' WHERE key = '
  || quote_literal(keyvalue);               
</code></pre>
            
            <p>O exemplo anterior mostra as funções <code class="code">quote_ident(text)</code> e <code class="code">quote_literal(text)</code>. Esse exemplo envia variáveis que contém identificadores de coluna e tabela para a função <code class="code">quote_ident</code>. Ele também envia variáveis que contém strings literais no comando construído para a função <code class="code">quote_literal</code>. Ambas as funções executam as etapas apropriadas para retornar o texto de entrada entre aspas duplas ou simples, respectivamente, com quaisquer caracteres especiais incorporados com escape adequado.</p>
            <p>A cotação de dólar só é útil para a cotação de texto fixo. Não grave o exemplo anterior no formato a seguir.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">EXECUTE 'UPDATE tbl SET '
  || quote_ident(colname)
  || ' = $$'
  || newvalue
  || '$$ WHERE key = '
  || quote_literal(keyvalue);               
</code></pre>
            
            <p>Não faça isso pois o exemplo trava se o conteúdo de <code class="code">newvalue</code> conter $$. O mesmo problema se aplica a qualquer outro delimitador de cotação de dólar que venha a escolher. Para citar com segurança um texto não conhecido previamente, use a função <code class="code">quote_literal</code>.</p>
            
          
            <h2 id="r_PLpgSQL-return">Return</h2>   
            
            <p>A instrução RETURN retorna para o chamador a partir de um procedimento armazenado.</p>
            
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="">RETURN;</code></pre>
            
            <p>Por exemplo:</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE return_example(a int)
AS $$  
BEGIN
  FOR b in 1..10 LOOP
    IF b &lt; a THEN
      RAISE INFO 'b = %', b;
    ELSE
      RETURN;
    END IF;
  END LOOP;
END;
$$ LANGUAGE plpgsql;               
</code></pre>
            
          
            <h2 id="r_PLpgSQL-conditionals-if">Condicionais: IF</h2>  
           
           
            
            <p>A instrução condicional IF pode assumir as seguintes formas na linguagem PL/pgSQL que o Amazon Redshift usa:</p>
            
            
            <div class="itemizedlist">
                
               
               
               
                  

                
            
            <ul class="itemizedlist"><li class="listitem"><p>IF ... THEN</p>
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
END IF;
</code></pre>
                  
            <p>Por exemplo:</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF v_user_id &lt;&gt; 0 THEN
  UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;               
</code></pre>
            
            </li><li class="listitem"><p>IF ... THEN ... ELSE</p>
 <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
ELSE
  statements
END IF;
</code></pre>
                  
               <p>Por exemplo:</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF parentid IS NULL OR parentid = ''
THEN
  return_name = fullname;
  RETURN;
ELSE
  return_name = hp_true_filename(parentid) || '/' || fullname;
  RETURN;
END IF;           
</code></pre>
                  
               </li><li class="listitem"><p>IF ... THEN ... ELSIF ... THEN ... ELSE </p>
                  <p>A palavra-chave ELSIF também pode ser escrita como ELSEIF.</p>                  
<pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">IF boolean-expression THEN
  statements
[ ELSIF boolean-expression THEN
  statements
[ ELSIF boolean-expression THEN
  statements
    ...] ]
[ ELSE
  statements ]
END IF;
</code></pre>                  
               

               
               <p>Por exemplo:</p>
               
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">IF number = 0 THEN
  result := 'zero';
ELSIF number &gt; 0 THEN
  result := 'positive';
ELSIF number &lt; 0 THEN
  result := 'negative';
ELSE
  -- the only other possibility is that number is null
  result := 'NULL';
END IF;                  
</code></pre>
               </li></ul></div>
            
           
            
          
            <h2 id="r_PLpgSQL-conditionals-case">Condicionais: CASE</h2>  
           <p>A instrução condicional CASE pode assumir as seguintes formas na linguagem PL/pgSQL que o Amazon Redshift usa:</p>
            <div class="itemizedlist">
                
                 

            <ul class="itemizedlist"><li class="listitem"><p>CASE simples </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CASE <code class="replaceable">search-expression</code>
WHEN <code class="replaceable">expression</code> [, <code class="replaceable">expression</code> [ ... ]] THEN
  <code class="replaceable">statements</code>
[ WHEN <code class="replaceable">expression</code> [, <code class="replaceable">expression</code> [ ... ]] THEN
  <code class="replaceable">statements</code>
  ... ]
[ ELSE
  <code class="replaceable">statements</code> ]
END CASE;
</code></pre>
                  
                  <p>Uma instrução CASE simples oferece execução condicional com base na igualdade dos operandos.</p>
                  
                  <p>O valor <code class="replaceable">search-expression</code> é avaliado uma vez e comparado sucessivamente com cada <code class="replaceable">expression</code> nas cláusulas WHEN. Se uma correspondência for encontrada, as <code class="replaceable">statements</code> correspondentes são executadas e o controle passa para a próxima instrução após END CASE. As expressions WHEN subsequentes não são avaliadas. Se nenhuma correspondência for encontrada, as <code class="replaceable">statements</code> ELSE são executadas. No entanto, se ELSE não estiver presente, uma exceção CASE_NOT_FOUND será gerada.</p>
                  
               <p>Por exemplo:</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CASE x
WHEN 1, 2 THEN
  msg := 'one or two';
ELSE
  msg := 'other value than one or two';
END CASE;                  
</code></pre>
                  
               </li><li class="listitem"><p>CASE pesquisado </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CASE
WHEN <code class="replaceable">boolean-expression</code> THEN
  statements
[ WHEN <code class="replaceable">boolean-expression</code> THEN
  statements
  ... ]
[ ELSE
  statements ]
END CASE;
</code></pre>
                  
                  <p>A formato pesquisado de CASE oferece execução condicional baseada na veracidade de expressões boolianas. </p>
                  
                  <p>A <code class="replaceable">boolean-expression</code> de cada cláusula WHEN é, por sua vez, avaliada até uma verdadeira ser encontrada. Depois, as instruções correspondentes são executadas e o controle passa para a próxima instrução após END CASE. As <code class="replaceable">expressions</code> WHEN subsequentes não são avaliadas. Se nenhum resultado verdadeiro for encontrado, as <code class="replaceable">statements</code> ELSE são executadas. No entanto, se ELSE não estiver presente, uma exceção CASE_NOT_FOUND será gerada.</p>
                  
                  <p>Por exemplo:</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CASE
WHEN x BETWEEN 0 AND 10 THEN
  msg := 'value is between zero and ten';
WHEN x BETWEEN 11 AND 20 THEN
  msg := 'value is between eleven and twenty';
END CASE;                                
</code></pre>
                  
               </li></ul></div>                      
            
          
            <h2 id="r_PLpgSQL-loops">Loops</h2>  
            
           <p>As instruções de loop podem assumir os seguintes formatos na linguagem PL/pgSQL que o Amazon Redshift usa:</p>
            <div class="itemizedlist">
                
               
                 
               
                 
               
                
               
                 
               
                 
               
               
               
                                  
               
               
            <ul class="itemizedlist"><li class="listitem"><p>Loop simples </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
LOOP
  statements
END LOOP [ label ];
</code></pre>
                  
                  <p>Um loop simples define um loop não condicional que é repetido indefinidamente até ser encerrado por uma instrução EXIT ou RETURN. O rótulo opcional pode ser usado pelas instruções EXIT e CONTINUE dentro de loops aninhados para especificar a qual loop as instruções EXIT e CONTINUE se referem.</p>
                  
               <p>Por exemplo:</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE simple_loop()
LANGUAGE plpgsql
AS $$
BEGIN
  &lt;&lt;simple_while&gt;&gt;
  LOOP
    RAISE INFO 'I am raised once';  
    EXIT simple_while;
    RAISE INFO 'I am not raised';
  END LOOP;
  RAISE INFO 'I am raised once as well';
END;
$$;                
</code></pre>

               </li><li class="listitem"><p>Loop de saída</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">EXIT [ <code class="replaceable">label</code> ] [ WHEN <code class="replaceable">expression</code> ];
</code></pre> 
                 <p>Se <code class="replaceable">label</code> não estiver presente, o loop mais interno será encerrado e a instrução após END LOOP será executada na sequência. Se <code class="replaceable">label</code> estiver presente, deverá ser o rótulo do loop atual ou de algum outro nível de loop ou bloco aninhado. Depois, o loop ou bloco nomeado será encerrado e o controle continuará com a instrução após END do loop ou bloco correspondente.</p>
                  <p>Se WHEN for especificada, a saída do loop ocorrerá apenas se a <code class="replaceable">expression</code> for verdadeira. Caso contrário, o controle passa para a instrução após EXIT.</p>
                  <p>Você pode usar EXIT com todos os tipos de loops, seu uso não se limita a loops não condicionais.</p>
                  <p>Quando usado com um bloco BEGIN, EXIT passa o controle para a próxima instrução após o final do bloco. Um rótulo pode ser usado para essa finalidade. Um EXIT sem rótulo nunca corresponderá a um bloco BEGIN.</p>
                  <p>Por exemplo:</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE simple_loop_when(x int)
LANGUAGE plpgsql
AS $$
DECLARE i INTEGER := 0;
BEGIN
  &lt;&lt;simple_loop_when&gt;&gt;
  LOOP
    RAISE INFO 'i %', i;
    i := i + 1;
    EXIT simple_loop_when WHEN (i &gt;= x);
  END LOOP;
END;
$$;                     
</code></pre>
               </li><li class="listitem"><p>Loop de continuação </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CONTINUE [ <code class="replaceable">label</code> ] [ WHEN <code class="replaceable">expression</code> ];
</code></pre> 
                  <p>Se <code class="replaceable">label</code> não for fornecido, a execução pulará para a próxima iteração do loop mais interno. Ou seja, todas as instruções restantes no corpo do loop serão ignoradas. Depois, o controle retornará para a expressão de controle do loop (se houver) a fim de determinar se há necessidade de outra iteração do loop. Se <code class="replaceable">label</code> estiver presente, ele especifica o rótulo do loop cuja execução será continuada.</p>
                  <p>Se WHEN for especificado, a próxima iteração do loop começará somente se a <code class="replaceable">expression</code> for verdadeira. Caso contrário, o controle passa para a instrução após CONTINUE.</p>
                  <p>Você pode usar CONTINUE com todos os tipos de loops, seu uso não se limita a loops não condicionais.</p>
                  
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CONTINUE mylabel;
</code></pre> 
                  
               </li><li class="listitem"><p>Loop WHILE </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
WHILE expression LOOP
  statements
END LOOP [ label ];
</code></pre> 
                  
               <p>A instrução WHILE repete uma sequência de instruções até a <code class="replaceable">boolean-expression</code> ser avaliada como verdadeira. A expressão é verificada imediatamente antes de cada entrada no corpo do loop.</p> 
               <p>Por exemplo:</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
  -- some computations here
END LOOP;

WHILE NOT done LOOP
  -- some computations here
END LOOP;                  
</code></pre>
               </li><li class="listitem"><p>Loop FOR (variante inteiro) </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR name IN [ REVERSE ] expression .. expression LOOP
  statements
END LOOP [ label ];
</code></pre> 
                  
                  <p>O loop FOR (variante inteiro) cria um loop que itera sobre um intervalo de valores inteiros. O nome da variável é definido automaticamente como o tipo inteiro e exite somente dentro do loop. Qualquer definição existente do nome da variável será ignorada dentro do loop. As duas expressões que fornecem os limites superior e inferior do intervalo são avaliadas uma vez ao entrar no loop. Se você especificar REVERSE, o valor da etapa será subtraído, em vez de adicionado, após cada iteração.</p> 
                  
                  <p>Se o limite inferior for maior que o limite superior (ou menor no caso REVERSE), o corpo do loop não será executado. Nenhum erro será gerado.</p>
                  
                  <p>Se um rótulo for anexado ao loop FOR, você pode referenciar a variável de loop inteira com um nome qualificado, usando esse rótulo.</p>
                  
               <p>Por exemplo:</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">FOR i IN 1..10 LOOP
  -- i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop
END LOOP;

FOR i IN REVERSE 10..1 LOOP
  -- i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop
END LOOP;                
</code></pre>  

               </li><li class="listitem"><p>Loop FOR (variante conjunto de resultados) </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR <code class="replaceable">target</code> IN query LOOP
  statements
END LOOP [ label ];
</code></pre>
                  <p>O <code class="replaceable">target</code> é uma variável de registro ou lista separada por vírgulas de variáveis escalares. O destino recebe todas as linhas resultantes da consulta e o corpo do loop é executado para cada linha.</p> 
                  
                  <p>O loop FOR (variante conjunto de resultados) habilita a iteração de um procedimento armazenado pelos resultados de uma consulta e manipula os dados de acordo.</p>
                  <p>Por exemplo:</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE PROCEDURE cs_refresh_reports() AS $$
DECLARE
  reports RECORD;
BEGIN
  FOR reports IN SELECT * FROM cs_reports ORDER BY sort_key LOOP
    -- Now "reports" has one record from cs_reports
    EXECUTE 'TRUNCATE TABLE ' || quote_ident(reports.report_name);
    EXECUTE 'INSERT INTO ' || quote_ident(reports.report_name) || ' ' || reports.report_query;
  END LOOP;
  RETURN;
END;
$$ LANGUAGE plpgsql;                   
</code></pre>
               </li><li class="listitem"><p>Loop FOR com SQL dinâmico</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">[&lt;&lt;label&gt;&gt;]
FOR record_or_row IN EXECUTE text_expression LOOP 
  statements
END LOOP;
</code></pre>
                  
                  <p>Um loop FOR com SQL dinâmico habilita a iteração de um procedimento armazenado pelos resultados de uma consulta dinâmica e manipula os dados de acordo.</p>  
                  
               <p>Por exemplo:</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CREATE OR REPLACE PROCEDURE for_loop_dynamic_sql(x int)
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  query text;
BEGIN
  query := 'SELECT * FROM tbl_dynamic_sql LIMIT ' || x;
  FOR rec IN EXECUTE query
  LOOP
    RAISE INFO 'a %', rec.a;
  END LOOP;
END;
$$;</code></pre>
               </li></ul></div>                      
            
          
            <h2 id="r_PLpgSQL-cursors">Cursores</h2>  
            
            <p>Em vez de executar uma consulta completa de uma só vez, é possível definir um cursor. Um <em>cursor </em>encapsula uma consulta e lê o resultado da consulta algumas linhas por vez. Um dos motivos para fazer isso é evitar o estouro de memória quando o resultado contiver um grande número de linhas. Outro motivo é retornar a referência a um cursor criado por um procedimento armazenado, o que permite ao chamador ler as linhas. Essa abordagem oferece uma maneira eficiente de retornar grandes conjuntos de linhas de procedimentos armazenados.</p>
           
           <p>Para usar cursores em um procedimento armazenado NONATOMIC, coloque o loop do cursor entre START TRANSACTION...COMMIT.</p>

            
            
            
            

               <p>Para configurar um cursor, primeiro declare uma variável de cursor. Todo o acesso a cursores na PL/pgSQL passa por variáveis de cursor, que sempre são do tipo de dados especial <code class="code">refcursor</code>. Um tipo de dados <code class="code">refcursor</code> apenas mantém uma referência a um cursor. </p>
      <p>Você pode criar uma variável de cursor declarando-a como uma variável do tipo <code class="code">refcursor</code>. Ou, use a sintaxe de declaração de cursor a seguir.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">name CURSOR [ ( <code class="replaceable">arguments</code> ) ] FOR <code class="replaceable">query</code> ;
</code></pre> 
                  <p>No trecho acima, <code class="replaceable">arguments</code> (se especificado) é uma lista separada por vírgulas de pares <code class="replaceable">name datatype</code> em que cada um define nomes a serem substituídos por valores de parâmetros em <code class="replaceable">query</code>. Os valores reais que substituirão esses nomes serão especificados posteriormente, quando o cursor for aberto.</p>
                  <p>Veja a seguir alguns exemplos.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">DECLARE
  curs1 refcursor;
  curs2 CURSOR FOR SELECT * FROM tenk1;
  curs3 CURSOR (key integer) IS SELECT * FROM tenk1 WHERE unique1 = key;                     
</code></pre>
                  <p>Essas três variáveis têm o tipo de dados <code class="code">refcursor</code>, mas a primeira pode ser usada com qualquer consulta. Por outro lado, a segunda tem uma consulta totalmente especificada já associada a ela, e a última tem uma consulta parametrizada associada a ela. O valor <code class="code">key</code> é substituído por um valor de parâmetro inteiro quando o cursor é aberto. Diz-se que a variável <code class="code">curs1</code> é <em>não associada </em>pois ela não está vinculada a nenhuma consulta específica.</p>
               
              <p>Antes de usar um cursor para recuperar linhas, ele deve ser aberto. PL/pgSQL possui três formas da instrução OPEN, das quais duas usam variáveis de cursor não associadas e a terceira usa uma variável de cursor associada:</p>
           <div class="itemizedlist">
              
              
              
           <ul class="itemizedlist"><li class="listitem">
                          <p>Abrir para seleção: a variável de cursor é aberta e recebe a consulta especificada para execução. O cursor não pode já estar aberto. Além disso, ele deverá ter sido declarado como um cursor não associado (isto é, como uma variável <code class="code">refcursor</code> simples). A consulta SELECT é tratada da mesma maneira que outras instruções SELECT na PL/pgSQL. </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN cursor_name FOR SELECT ...;                     
</code></pre> 
                  <p>Por exemplo:</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;    
</code></pre>
             </li><li class="listitem">
                  <p>Abrir para execução: a variável de cursor é aberta e recebe a consulta especificada para execução. O cursor não pode já estar aberto. Além disso, ele deverá ter sido declarado como um cursor não associado (isto é, como uma variável <code class="code">refcursor</code> simples). A consulta é especificada como uma expressão de string da mesma maneira que no comando EXECUTE. Essa abordagem oferece flexibilidade para que a consulta possa variar de uma execução para a próxima.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN cursor_name FOR EXECUTE query_string;
</code></pre>
                  <p>Por exemplo:</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs1 FOR EXECUTE 'SELECT * FROM ' || quote_ident($1);</code></pre>                 
             </li><li class="listitem">
                  <p>Abrir um cursor associado: essa forma de OPEN é usada para abrir uma variável de cursor cuja consulta foi associada a ela no momento em que foi declarada. O cursor não pode já estar aberto. Uma lista das expressões de valor de argumento reais deverá aparecer se, e somente se, o cursor tiver sido declarado para receber argumentos. Esses valores são substituídos na consulta. </p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">OPEN bound_cursor_name [ ( argument_values ) ];
</code></pre>

                  <p>Por exemplo:</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">OPEN curs2;
OPEN curs3(42);
</code></pre>                            
             </li></ul></div>
                  <p>Depois que um cursor tiver sido aberto, trabalhe com ele usando as instruções descritas a seguir. Essas instruções não precisam ocorrer no mesmo procedimento armazenado que abriu o cursor. Você pode retornar um valor <code class="code">refcursor</code> fora de um procedimento armazenado e deixar o chamador operar no cursor. Todos os portais são implicitamente fechados ao final da transação. Portanto, você pode usar um valor <code class="code">refcursor</code> para fazer referência a um cursor aberto somente até o final da transação.</p>
           <div class="itemizedlist">
              
              
           <ul class="itemizedlist"><li class="listitem">
                  <p>FETCH recupera a próxima linha do cursor em um destino. Esse destino pode ser uma variável de linha, uma variável de registro ou uma lista separada por vírgulas de variáveis simples, igual à SELECT INTO. Como na SELECT INTO, é possível verificar a variável especial FOUND para conferir se uma linha foi obtida.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">FETCH cursor INTO target;
</code></pre> 
                  <p>Por exemplo:</p> 
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">FETCH curs1 INTO rowvar;</code></pre>               
             </li><li class="listitem">
                  <p>CLOSE fecha o portal subjacente a um cursor aberto. Use essa instrução para liberar recursos antes do fim da transação. Você também pode usar essa instrução a fim de liberar a variável de cursor para que possa ser aberta novamente.</p>
                  <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CLOSE cursor;
</code></pre>
                <p>Por exemplo:</p> 
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="sql ">CLOSE curs1;</code></pre>               
             </li></ul></div>
             
          
            <h2 id="r_PLpgSQL-messages-errors">RAISE</h2>
           
           
           <p>Use a instrução <code class="code">RAISE level</code> para relatar mensagens e gerar erros.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE level 'format' [, variable [, ...]];</code></pre>
            <p>Os níveis possíveis são NOTICE, INFO, LOG, WARNING e EXCEPTION. EXCEPTION gera um erro, que normalmente cancela a transação atual. Os outros níveis geram apenas mensagens com diferentes níveis de prioridade. </p>
           <p>Dentro da string de formato, % é substituído pela representação de string do próximo argumento opcional. Escreva %% para emitir um % literal. No momento, argumentos opcionais devem ser variáveis simples, não expressões, e o formato deve ser uma string literal simples.</p>
            <p>No exemplo a seguir, o valor de <code class="code">v_job_id</code> substitui o % na string.</p>
            <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;</code></pre>
            
           
            
           <p>Use a instrução <code class="code">RAISE</code> para relançar a exceção capturada por um bloco de tratamento de exceções. Essa instrução só é válida em blocos de tratamento de exceções de procedimentos armazenados no modo NONATOMIC.</p>
           <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">RAISE;</code></pre>
          
          <h2 id="r_PLpgSQL-transaction-control">Controle da transação</h2>
          <p>Você pode trabalhar com instruções de controle de transação na linguagem PL/pgSQL que o Amazon Redshift usa. Para obter informações sobre como usar as instruções COMMIT, ROLLBACK e TRUNCATE em um procedimento armazenado, consulte <a href="./stored-procedure-transaction-management.html">Gerenciamento de transações</a>. </p>  
          
          <p>Nos procedimentos armazenados no modo NONATOMIC, use <code class="code">START TRANSACTION</code> para iniciar um bloco de transação.</p>
          <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">START TRANSACTION;</code></pre>
          <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>nota</h6></div><div class="awsdocs-note-text"><p>A instrução PL/pgSQL START TRANSACTION é diferente do comando SQL START TRANSACTION das seguintes formas:</p><div class="itemizedlist">
               
               
            <ul class="itemizedlist"><li class="listitem"><p>Nos procedimentos armazenados, START TRANSACTION não é sinônimo de BEGIN.</p></li><li class="listitem"><p>A instrução PL/pgSQL não é compatível com palavras-chave opcionais de nível de isolamento e permissão de acesso.</p></li></ul></div></div></div>

          
        <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Atenção" /> <strong>O Javascript está desativado ou não está disponível no seu navegador.</strong></p><p>Para usar a documentação da AWS, o Javascript deve estar ativado. Consulte as páginas de Ajuda do navegador para obter instruções.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Convenções do documento</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./c_PLpgSQL-structure.html">Estrutura da PL/pgSQL</div><div id="next" class="next-link" accesskey="n" href="./materialized-view-overview.html">Criar visualizações materializadas</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">Essa página foi útil? - Sim</div><div class="content"><p>Obrigado por nos informar que estamos fazendo um bom trabalho!</p><p>Se tiver tempo, conte-nos sobre o que você gostou para que possamos melhorar ainda mais.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">Essa página foi útil? - Não</div><div class="content"><p>Obrigado por nos informar que precisamos melhorar a página. Lamentamos ter decepcionado você.</p><p>Se tiver tempo, conte-nos como podemos melhorar a documentação.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/pt_br/redshift/latest/dg/c_PLpgSQL-statements.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>