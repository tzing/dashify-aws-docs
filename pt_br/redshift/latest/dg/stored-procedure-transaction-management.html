<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="pt-BR"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Gerenciamento de transações - Amazon Redshift</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="stored-procedure-transaction-management" /><meta name="default_state" content="stored-procedure-transaction-management" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-transaction-management.html" /><meta name="description" content="Gerencie transações para procedimentos armazenados no Amazon Redshift." /><meta name="deployment_region" content="IAD" /><meta name="product" content="Amazon Redshift" /><meta name="guide" content="Guia do desenvolvedor de banco de dados" /><meta name="abstract" content="Crie e gerencie um data warehouse com o Amazon Redshift, um serviço de data warehouse totalmente gerenciado, em escala de petabyte e de nível empresarial." /><meta name="guide-locale" content="pt_br" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-transaction-management.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/redshift/latest/dg/stored-procedure-transaction-management.html" hreflang="x-default" /><meta name="feedback-item" content="Redshift" /><meta name="this_doc_product" content="Amazon Redshift" /><meta name="this_doc_guide" content="Guia do desenvolvedor de banco de dados" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'redshift'}"></script><meta id="panorama-serviceSubSection" value="Guia do desenvolvedor de banco de dados" /><meta id="panorama-serviceConsolePage" value="Gerenciamento de transações" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Gerenciamento de transações - Amazon Redshift</title><meta name="pdf" content="redshift-dg.pdf#stored-procedure-transaction-management" /><meta name="rss" content="Dochistory.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=155" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-transaction-management.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-transaction-management.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-transaction-management.html" /><meta name="keywords" content="Amazon Redshift,AWS Redshift,Redshift,Redshift Spectrum,cluster,data warehouse,desenvolvedor,dados de amostra,banco de dados,desenvolvedor do banco de dados,HLL" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/redshift/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Guia do desenvolvedor de banco de dados",
        "item" : "https://docs.aws.amazon.com/pt_br/redshift/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Criar procedimentos armazenados no Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-overview.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Visão geral dos procedimentos armazenados no Amazon Redshift",
        "item" : "https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-create.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "Gerenciamento de transações",
        "item" : "https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-create.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="redshift-dg.pdf#stored-procedure-transaction-management" target="_blank" rel="noopener noreferrer" title="Abrir em PDF"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Documentação</a><a href="/redshift/index.html">Amazon Redshift</a><a href="welcome.html">Guia do desenvolvedor de banco de dados</a></div><div id="page-toc-src"><a href="#stored-procedure-transaction-management-default-mode">Gerenciamento de transações de procedimentos armazenados no modo padrão</a><a href="#stored-procedure-transaction-management-nonatomic-mode">Gerenciamento de transações de procedimentos armazenados no modo não atômico</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="stored-procedure-transaction-management">Gerenciamento de transações</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p>Você pode criar um procedimento armazenado com comportamento padrão de gerenciamento de transações ou comportamento não atômico. </p>           
            <h2 id="stored-procedure-transaction-management-default-mode">Gerenciamento de transações de procedimentos armazenados no modo padrão</h2>
                 
         <p>O comportamento de confirmação automática do modo de transações padrão faz com que cada comando SQL executado separadamente seja confirmado individualmente. Uma chamada para um procedimento armazenado é tratada como um único comando SQL. As instruções SQL dentro de um procedimento se comportam como se estivessem em um bloco de transações iniciado implicitamente quando a chamada começa, e que termina quando a chamada é encerrada. Uma chamada aninhada para outro procedimento é tratada como qualquer outra instrução SQL e opera dentro do contexto da mesma transação que o chamador. Para obter mais informações sobre o comportamento de confirmação automática, consulte <a href="./c_serial_isolation.html">Isolamento serializável</a>.</p>
         

         <p>Porém, suponha que você chame um procedimento armazenado a partir de um bloco de transações especificado pelo usuário (definido por BEGIN... COMMIT). Neste caso, todas as instruções do procedimento armazenado são executadas no contexto da transação especificada pelo usuário. O procedimento não é confirmado implicitamente na saída. O chamador controla a confirmação ou a reversão do procedimento.</p>
         
         <p>Se um erro for encontrado durante a execução de um procedimento armazenado, todas as alterações feitas na transação atual são revertidas.</p>

         <p>Você pode usar as seguintes instruções de controle de transação em um procedimento armazenado:</p> 
         <div class="itemizedlist">
             
                         
         <ul class="itemizedlist"><li class="listitem"><p>COMMIT - Confirma todo o trabalho realizado na transação atual e inicia implicitamente uma nova transação. Para obter mais informações, consulte <a href="./r_COMMIT.html">COMMIT</a>. </p></li><li class="listitem"><p>ROLLBACK - Reverte o trabalho realizado na transação atual e inicia implicitamente uma nova transação. Para obter mais informações, consulte <a href="./r_ROLLBACK.html">ROLLBACK</a>. </p></li></ul></div>
         
         <p>TRUNCATE é outra instrução que pode ser emitida em um procedimento armazenado e influencia o gerenciamento de transações. No Amazon Redshift, TRUNCATE emite uma confirmação implicitamente. Esse comportamento permanece o mesmo no contexto dos procedimentos armazenados. Quando uma instrução TRUNCATE for emitida a partir de um procedimento armazenado, ela confirma a transação atual e inicia uma nova. Para obter mais informações, consulte <a href="./r_TRUNCATE.html">TRUNCATE</a>. </p>
         
         <p>Todas as instruções que seguem uma instrução COMMIT, ROLLBACK ou TRUNCATE no contexto de uma nova transação. Elas fazem isso até uma instrução COMMIT, ROLLBACK ou TRUNCATE ser encontrada ou o procedimento armazenado ser encerrado.</p>
         
         <p>Ao usar uma instrução COMMIT, ROLLBACK ou TRUNCATE em um procedimento armazenado, as seguintes restrições são aplicadas:</p>
         <div class="itemizedlist">
             
             
                        
         <ul class="itemizedlist"><li class="listitem"><p>Se o procedimento armazenado for chamado em um bloco de transação, ele não poderá emitir uma instrução COMMIT, ROLLBACK ou TRUNCATE. Essa restrição se aplica ao corpo do próprio procedimento armazenado e a qualquer chamada de procedimento aninhada.</p></li><li class="listitem"><p>Se o procedimento armazenado for criado com opções <code class="code">SET config</code>, ele não poderá emitir uma instrução COMMIT, ROLLBACK ou TRUNCATE. Essa restrição se aplica ao corpo do próprio procedimento armazenado e a qualquer chamada de procedimento aninhada. </p></li><li class="listitem"><p>Qualquer cursor aberto (explícita ou implicitamente) será fechado automaticamente quando uma instrução COMMIT, ROLLBACK ou TRUNCATE for processada. Para obter as restrições sobre cursores explícitos ou implícitos, consulte <a href="./stored-procedure-constraints.html">Considerações para suporte a procedimentos armazenados</a>.</p></li></ul></div>
         
         <p>Além disso, não é possível executar COMMIT ou ROLLBACK com SQL dinâmico. No entanto, é possível executar TRUNCATE com SQL dinâmico. Para obter mais informações, consulte <a href="./c_PLpgSQL-statements.html#r_PLpgSQL-dynamic-sql">SQL dinâmico</a>. </p>
         
            
         
         <p>Ao trabalhar com procedimentos armazenados, considere que as instruções BEGIN e END em PL/pgSQL são somente para agrupamento. Elas não iniciam ou encerram uma transação. Para obter mais informações, consulte <a href="./c_PLpgSQL-structure.html#r_PLpgSQL-block">Bloco</a>. </p>
         
         
         
         <p>O exemplo a seguir demonstra o comportamento da transação ao chamar um procedimento armazenado a partir de um bloco de transações explícito. As duas instruções de inserção emitidas fora do procedimento armazenado e aquela emitida dentro dele fazem parte da mesma transação (3382). A transação é confirmada quando o usuário emite a confirmação explícita.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_insert_table_a(a int) LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO test_table_a values (a);
END;
$$;

Begin;
  insert into test_table_a values (1);
  Call sp_insert_table_a(2);
  insert into test_table_a values (3);
Commit; 

select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  | pid |  type   |               stmt_text
--------+------+-----+---------+----------------------------------------
    103 | 3382 | 599 | UTILITY | Begin;
    103 | 3382 | 599 | QUERY   | insert into test_table_a values (1);
    103 | 3382 | 599 | UTILITY | Call sp_insert_table_a(2);
    103 | 3382 | 599 | QUERY   | INSERT INTO test_table_a values ( $1 )
    103 | 3382 | 599 | QUERY   | insert into test_table_a values (3);
    103 | 3382 | 599 | UTILITY | COMMIT
</code></pre>
         
         <p>Por outro lado, pense em quando as mesmas instruções forem emitidas fora de um bloco de transações explícito e a sessão tiver a confirmação automática definida como ON. Nesse caso, cada instrução é executada em sua própria transação.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">insert into test_table_a values (1);
Call sp_insert_table_a(2);
insert into test_table_a values (3);

select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  | pid |  type   |                                                                    stmt_text
--------+------+-----+---------+-------------------------------------------------------------------------------------------------------------------------------------------------
    103 | 3388 | 599 | QUERY   | insert into test_table_a values (1);
    103 | 3388 | 599 | UTILITY | COMMIT
    103 | 3389 | 599 | UTILITY | Call sp_insert_table_a(2);
    103 | 3389 | 599 | QUERY   | INSERT INTO test_table_a values ( $1 )
    103 | 3389 | 599 | UTILITY | COMMIT
    103 | 3390 | 599 | QUERY   | insert into test_table_a values (3);
    103 | 3390 | 599 | UTILITY | COMMIT            
</code></pre>
         
         <p>O exemplo a seguir emite uma instrução TRUNCATE depois de inserir na <code class="code">test_table_a</code>. A instrução TRUNCATE emite uma confirmação implícita que confirma a transação atual (3335) e inicia uma nova (3336). A nova transação é confirmada quando o procedimento é encerrado.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_truncate_proc(a int, b int) LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO test_table_a values (a);
  TRUNCATE test_table_b;
  INSERT INTO test_table_b values (b);
END;
$$;

Call sp_truncate_proc(1,2);

select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  |  pid  |  type   |                                                                                             stmt_text
--------+------+-------+---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    103 | 3335 | 23636 | UTILITY | Call sp_truncate_proc(1,2);
    103 | 3335 | 23636 | QUERY   | INSERT INTO test_table_a values ( $1 )
    103 | 3335 | 23636 | UTILITY | TRUNCATE test_table_b
    103 | 3335 | 23636 | UTILITY | COMMIT
    103 | 3336 | 23636 | QUERY   | INSERT INTO test_table_b values ( $1 )
    103 | 3336 | 23636 | UTILITY | COMMIT    
</code></pre>
         
         <p>O exemplo a seguir emite uma TRUNCATE a partir de uma chamada aninhada. A TRUNCATE confirma todo o trabalho feito até agora nos procedimentos externo e interno em uma transação (3344). Ela inicia uma nova transação (3345). A nova transação é confirmada quando o procedimento externo é encerrado.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_inner(c int, d int) LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO inner_table values (c);
  TRUNCATE outer_table;
  INSERT INTO inner_table values (d);
END;
$$;

CREATE OR REPLACE PROCEDURE sp_outer(a int, b int, c int, d int) LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO outer_table values (a);
  Call sp_inner(c, d);
  INSERT INTO outer_table values (b);
END;
$$;

Call sp_outer(1, 2, 3, 4);

select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  |  pid  |  type   |                                                                                              stmt_text
--------+------+-------+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    103 | 3344 | 23636 | UTILITY | Call sp_outer(1, 2, 3, 4);
    103 | 3344 | 23636 | QUERY   | INSERT INTO outer_table values ( $1 )
    103 | 3344 | 23636 | UTILITY | CALL sp_inner( $1 , $2 )
    103 | 3344 | 23636 | QUERY   | INSERT INTO inner_table values ( $1 )
    103 | 3344 | 23636 | UTILITY | TRUNCATE outer_table
    103 | 3344 | 23636 | UTILITY | COMMIT
    103 | 3345 | 23636 | QUERY   | INSERT INTO inner_table values ( $1 )
    103 | 3345 | 23636 | QUERY   | INSERT INTO outer_table values ( $1 )
    103 | 3345 | 23636 | UTILITY | COMMIT
</code></pre>
         
         <p>O exemplo a seguir mostra que o cursor <code class="code">cur1</code> foi fechado quando a instrução TRUNCATE foi confirmada.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_open_cursor_truncate()
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  cur1 cursor for select * from test_table_a order by 1;
BEGIN
  open cur1;
  TRUNCATE table test_table_b;
  Loop
    fetch cur1 into rec;
    raise info '%', rec.c1;
    exit when not found;
  End Loop;
END
$$;

call sp_open_cursor_truncate();
ERROR: cursor "cur1" does not exist
CONTEXT: PL/pgSQL function "sp_open_cursor_truncate" line 8 at fetch
</code></pre>

         <p>O exemplo a seguir emite uma instrução TRUNCATE e não pode ser chamado dentro de um bloco de transações explícito.</p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_truncate_atomic() LANGUAGE plpgsql
AS $$
BEGIN
  TRUNCATE test_table_b;
END;
$$;

Begin;
  Call sp_truncate_atomic();
ERROR: TRUNCATE cannot be invoked from a procedure that is executing in an atomic context.
HINT: Try calling the procedure as a top-level call i.e. not from within an explicit transaction block. 
Or, if this procedure (or one of its ancestors in the call chain) was created with SET config options, recreate the procedure without them.
CONTEXT: SQL statement "TRUNCATE test_table_b"
PL/pgSQL function "sp_truncate_atomic" line 2 at SQL statement 
</code></pre>
         
         
         <p>O exemplo a seguir mostra que um usuário que não é um superusuário ou proprietário de uma tabela pode emitir uma instrução TRUNCATE na tabela. O usuário faz isso usando um procedimento <code class="code">Security Definer</code> armazenado. O exemplo mostra as seguintes ações: </p>
         <div class="itemizedlist">
             
             
             
             
         <ul class="itemizedlist"><li class="listitem"><p>O user1 cria a tabela <code class="code">test_tbl</code>. </p></li><li class="listitem"><p>O user1 cria o procedimento armazenado <code class="code">sp_truncate_test_tbl</code>. </p></li><li class="listitem"><p>O user1 concede privilégio <code class="code">EXECUTE</code> no procedimento armazenado para user2. </p></li><li class="listitem"><p>O user2 executa o procedimento armazenado para truncar a tabela <code class="code">test_tbl</code>. O exemplo mostra a contagem de linhas antes e depois do comando <code class="code">TRUNCATE</code>. </p></li></ul></div> 
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">set session_authorization to user1;
create table test_tbl(id int, name varchar(20));
insert into test_tbl values (1,'john'), (2, 'mary');
CREATE OR REPLACE PROCEDURE sp_truncate_test_tbl() LANGUAGE plpgsql
AS $$
DECLARE
  tbl_rows int;
BEGIN
  select count(*) into tbl_rows from test_tbl;
  RAISE INFO 'RowCount before Truncate: %', tbl_rows;
  TRUNCATE test_tbl;
  select count(*) into tbl_rows from test_tbl;
  RAISE INFO 'RowCount after Truncate: %', tbl_rows;
END;
$$ SECURITY DEFINER;
grant execute on procedure sp_truncate_test_tbl() to user2;
reset session_authorization;


set session_authorization to user2;
call sp_truncate_test_tbl();
INFO:  RowCount before Truncate: 2
INFO:  RowCount after Truncate: 0
CALL
reset session_authorization;         
</code></pre>
         
                     
         
  
         
         <p>O exemplo a seguir emite COMMIT duas vezes. O primeiro COMMIT confirma todo o trabalho feito na transação 10363 e começa implicitamente a transação 10364. A transação 10364 será confirmada pela segunda instrução COMMIT. </p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_commit(a int, b int) LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO test_table values (a);
  COMMIT;
  INSERT INTO test_table values (b);
  COMMIT;
END;
$$;

call sp_commit(1,2);

select userid, xid, pid, type, trim(text) as stmt_text
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;
 userid |  xid  | pid  |  type   |                                                                                    stmt_text
--------+-------+------+---------+-----------------------------------------------------------------------------------------------------------------
    100 | 10363 | 3089 | UTILITY | call sp_commit(1,2);
    100 | 10363 | 3089 | QUERY   | INSERT INTO test_table values ( $1 )
    100 | 10363 | 3089 | UTILITY | COMMIT
    100 | 10364 | 3089 | QUERY   | INSERT INTO test_table values ( $1 )
    100 | 10364 | 3089 | UTILITY | COMMIT
</code></pre>
 
   
    
         <p>O exemplo a seguir emitirá uma instrução ROLLBACK se <code class="code">sum_vals</code> for maior do que 2. A primeira instrução ROLLBACK reverte todo o trabalho feito na transação 10377 e começa uma nova transação 10378. A transação 10378 é confirmada quando o procedimento é encerrado. </p>
         
         <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_rollback(a int, b int) LANGUAGE plpgsql
AS $$
DECLARE
  sum_vals int;
BEGIN
  INSERT INTO test_table values (a);
  SELECT sum(c1) into sum_vals from test_table;
  IF sum_vals &gt; 2 THEN
    ROLLBACK;
  END IF;
  
  INSERT INTO test_table values (b);
END;
$$;

call sp_rollback(1, 2);

select userid, xid, pid, type, trim(text) as stmt_text
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

userid |  xid  | pid  |  type   |                                                                                    stmt_text
--------+-------+------+---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    100 | 10377 | 3089 | UTILITY | call sp_rollback(1, 2);
    100 | 10377 | 3089 | QUERY   | INSERT INTO test_table values ( $1 )
    100 | 10377 | 3089 | QUERY   | SELECT sum(c1) from test_table
    100 | 10377 | 3089 | QUERY   | Undoing 1 transactions on table 133646 with current xid 10377 : 10377
    100 | 10378 | 3089 | QUERY   | INSERT INTO test_table values ( $1 )
    100 | 10378 | 3089 | UTILITY | COMMIT
</code></pre>
          
               
               <h2 id="stored-procedure-transaction-management-nonatomic-mode">Gerenciamento de transações de procedimentos armazenados no modo não atômico</h2>
               
               
               
               <p>Um procedimento armazenado criado no modo NONATOMIC tem um comportamento de controle de transações diferente de um procedimento criado no modo padrão. Semelhante ao comportamento de confirmação automática dos comandos SQL fora dos procedimentos armazenados, cada instrução SQL dentro de um procedimento NONATOMIC é executada em sua própria transação e é confirmada automaticamente. Se um usuário iniciar um bloco de transação explícito em um procedimento armazenado NONATOMIC, as instruções SQL dentro do bloco não serão confirmadas automaticamente. O bloco de transação controla a confirmação ou a reversão das instruções contidas nele. </p>
               
               <p>Em procedimentos armazenados NONATOMIC, você pode abrir um bloco de transação explícito dentro do procedimento usando a instrução START TRANSACTION. No entanto, se já houver um bloco de transação aberto, essa instrução não fará nada porque o Amazon Redshift não é compatível com subtransações. A transação anterior continua.</p>
               
               <p>Ao trabalhar com loops FOR do cursor dentro de um procedimento NONATOMIC, certifique-se de abrir um bloco de transação explícito antes de percorrer os resultados de uma consulta. Caso contrário, o cursor será fechado quando a instrução SQL dentro do loop for confirmada automaticamente.</p>
               
               <p>Algumas considerações ao usar o comportamento do modo NONATOMIC são as seguintes:</p>
               <div class="itemizedlist">
                   
                   
                   
               <ul class="itemizedlist"><li class="listitem"><p>Cada instrução SQL dentro do procedimento armazenado será confirmada automaticamente se não houver um bloco de transação aberto e se a confirmação automática estiver ativada na sessão.</p></li><li class="listitem"><p>Você pode emitir uma instrução COMMIT/ROLLBACK/TRUNCATE para encerrar a transação se o procedimento armazenado for chamado de dentro de um bloco de transação. Isso não é possível no modo padrão.</p></li><li class="listitem"><p>Você pode emitir uma instrução START TRANSACTION para iniciar um bloco de transação dentro do procedimento armazenado.</p></li></ul></div>
               
               <p>Os exemplos a seguir demonstram o comportamento da transação ao trabalhar com procedimentos armazenados NONATOMIC. A sessão para todos os exemplos a seguir está com a confirmação automática ativada.</p>
               
               <p>No exemplo a seguir, um procedimento armazenado NONATOMIC tem duas instruções INSERT. Quando o procedimento é chamado fora de um bloco de transação, cada instrução INSERT dentro do procedimento é confirmada automaticamente. </p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE TABLE test_table_a(v int); 
CREATE TABLE test_table_b(v int); 

CREATE OR REPLACE PROCEDURE sp_nonatomic_insert_table_a(a int, b int) NONATOMIC AS
$$
BEGIN
    INSERT INTO test_table_a values (a);
    INSERT INTO test_table_b values (b);
END;
$$ 
LANGUAGE plpgsql;

Call sp_nonatomic_insert_table_a(1,2);

Select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  |    pid     |  type   |               stmt_text                
--------+------+------------+---------+----------------------------------------
      1 | 1792 | 1073807554 | UTILITY | Call sp_nonatomic_insert_table_a(1,2);
      1 | 1792 | 1073807554 | QUERY   | INSERT INTO test_table_a values ( $1 )
      1 | 1792 | 1073807554 | UTILITY | COMMIT
      1 | 1793 | 1073807554 | QUERY   | INSERT INTO test_table_b values ( $1 )
      1 | 1793 | 1073807554 | UTILITY | COMMIT
(5 rows)          
</code></pre>
               
               <p>No entanto, quando o procedimento é chamado de dentro de um bloco BEGIN…COMMIT, todas as instruções fazem parte da mesma transação (xid=1799). </p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">Begin;
  INSERT INTO test_table_a values (10);
  Call sp_nonatomic_insert_table_a(20,30);
  INSERT INTO test_table_b values (40);
Commit; 

Select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  |    pid     |  type   |                stmt_text                 
--------+------+------------+---------+------------------------------------------
      1 | 1799 | 1073914035 | UTILITY | Begin;
      1 | 1799 | 1073914035 | QUERY   | INSERT INTO test_table_a values (10);
      1 | 1799 | 1073914035 | UTILITY | Call sp_nonatomic_insert_table_a(20,30);
      1 | 1799 | 1073914035 | QUERY   | INSERT INTO test_table_a values ( $1 )
      1 | 1799 | 1073914035 | QUERY   | INSERT INTO test_table_b values ( $1 )
      1 | 1799 | 1073914035 | QUERY   | INSERT INTO test_table_b values (40);
      1 | 1799 | 1073914035 | UTILITY | COMMIT
(7 rows)
</code></pre>
               
               <p>Neste exemplo, duas instruções INSERT estão entre START TRANSACTION...COMMIT. Quando o procedimento é chamado fora de um bloco de transação, as duas instruções INSERT estão na mesma transação (xid=1866). </p>
               
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">CREATE OR REPLACE PROCEDURE sp_nonatomic_txn_block(a int, b int) NONATOMIC AS
$$
BEGIN
    START TRANSACTION;
    INSERT INTO test_table_a values (a);
    INSERT INTO test_table_b values (b);
    COMMIT;
END;
$$ 
LANGUAGE plpgsql;

Call sp_nonatomic_txn_block(1,2);

Select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  |    pid     |  type   |               stmt_text                
--------+------+------------+---------+----------------------------------------
      1 | 1865 | 1073823998 | UTILITY | Call sp_nonatomic_txn_block(1,2);
      1 | 1866 | 1073823998 | QUERY   | INSERT INTO test_table_a values ( $1 )
      1 | 1866 | 1073823998 | QUERY   | INSERT INTO test_table_b values ( $1 )
      1 | 1866 | 1073823998 | UTILITY | COMMIT
(4 rows)
</code></pre>
               
               <p>Quando o procedimento é chamado de dentro de um bloco BEGIN...COMMIT, o comando START TRANSACTION dentro do procedimento não faz nada porque já existe uma transação aberta. O comando COMMIT dentro do procedimento confirma a transação atual (xid=1876) e inicia uma nova.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">Begin;
  INSERT INTO test_table_a values (10);
  Call sp_nonatomic_txn_block(20,30);
  INSERT INTO test_table_b values (40);
Commit; 

Select userid, xid, pid, type, trim(text) as stmt_text 
from svl_statementtext where pid = pg_backend_pid() order by xid , starttime , sequence;

 userid | xid  |    pid     |  type   |               stmt_text                
--------+------+------------+---------+----------------------------------------
      1 | 1876 | 1073832133 | UTILITY | Begin;
      1 | 1876 | 1073832133 | QUERY   | INSERT INTO test_table_a values (10);
      1 | 1876 | 1073832133 | UTILITY | Call sp_nonatomic_txn_block(20,30);
      1 | 1876 | 1073832133 | QUERY   | INSERT INTO test_table_a values ( $1 )
      1 | 1876 | 1073832133 | QUERY   | INSERT INTO test_table_b values ( $1 )
      1 | 1876 | 1073832133 | UTILITY | COMMIT
      1 | 1878 | 1073832133 | QUERY   | INSERT INTO test_table_b values (40);
      1 | 1878 | 1073832133 | UTILITY | COMMIT
(8 rows)
</code></pre>
               
               <p>Este exemplo mostra como trabalhar com loops de cursor. A tabela test_table_a tem três valores. O objetivo é percorrer os três valores e inseri-los na tabela test_table_b. Se um procedimento armazenado NONATOMIC for criado conforme mostrado a seguir, será gerado um erro informando que o cursor “cur1" não existe depois da execução da instrução INSERT no primeiro loop. Isso ocorre porque a confirmação automática de INSERT fecha o cursor aberto.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">insert into test_table_a values (1), (2), (3);

CREATE OR REPLACE PROCEDURE sp_nonatomic_cursor() NONATOMIC
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  cur1 cursor for select * from test_table_a order by 1;
BEGIN
  open cur1;
  Loop
    fetch cur1 into rec;
    exit when not found;
    raise info '%', rec.v;
    insert into test_table_b values (rec.v);
  End Loop;
END
$$;

CALL sp_nonatomic_cursor();

INFO:  1
ERROR:  cursor "cur1" does not exist
CONTEXT:  PL/pgSQL function "sp_nonatomic_cursor" line 7 at fetch
</code></pre>
               
               <p>Para que o loop do cursor funcione, coloque-o entre START TRANSACTION...COMMIT.</p>
               <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copiar"><awsui-icon name="copy"></awsui-icon></div></div><code class="nohighlight">insert into test_table_a values (1), (2), (3);

CREATE OR REPLACE PROCEDURE sp_nonatomic_cursor() NONATOMIC
LANGUAGE plpgsql
AS $$
DECLARE
  rec RECORD;
  cur1 cursor for select * from test_table_a order by 1;
BEGIN
  START TRANSACTION;
  open cur1;
  Loop
    fetch cur1 into rec;
    exit when not found;
    raise info '%', rec.v;
    insert into test_table_b values (rec.v);
  End Loop;
  COMMIT;
END
$$;

CALL sp_nonatomic_cursor();

INFO:  1
INFO:  2
INFO:  3
CALL
</code></pre>
               
            <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Atenção" /> <strong>O Javascript está desativado ou não está disponível no seu navegador.</strong></p><p>Para usar a documentação da AWS, o Javascript deve estar ativado. Consulte as páginas de Ajuda do navegador para obter instruções.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Convenções do documento</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./stored-procedure-result-set.html">Retorno de um conjunto de resultados</div><div id="next" class="next-link" accesskey="n" href="./stored-procedure-trapping-errors.html">Retenção de erros</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">Essa página foi útil? - Sim</div><div class="content"><p>Obrigado por nos informar que estamos fazendo um bom trabalho!</p><p>Se tiver tempo, conte-nos sobre o que você gostou para que possamos melhorar ainda mais.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-transaction-management.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">Essa página foi útil? - Não</div><div class="content"><p>Obrigado por nos informar que precisamos melhorar a página. Lamentamos ter decepcionado você.</p><p>Se tiver tempo, conte-nos como podemos melhorar a documentação.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Redshift&amp;topic_url=https://docs.aws.amazon.com/pt_br/redshift/latest/dg/stored-procedure-transaction-management.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>